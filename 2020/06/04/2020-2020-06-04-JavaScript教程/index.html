<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="一. 基础知识1.1 JavaScript之HelloWorld123&lt;script&gt;   console.log(&quot;hello world!!!&quot;)&lt;&#x2F;script&gt;  script可以内联代码，也可以通过src属性来引入外部指定脚本代码 1.2 运算符运算元：  指的是运算符作用的对象 一元运算符： 作用于一个运算元 二元运算符： 作用于两个运算元 JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript教程">
<meta property="og:url" content="https://davidlee6688.github.io/2020/06/04/2020-2020-06-04-JavaScript%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="前端追梦人">
<meta property="og:description" content="一. 基础知识1.1 JavaScript之HelloWorld123&lt;script&gt;   console.log(&quot;hello world!!!&quot;)&lt;&#x2F;script&gt;  script可以内联代码，也可以通过src属性来引入外部指定脚本代码 1.2 运算符运算元：  指的是运算符作用的对象 一元运算符： 作用于一个运算元 二元运算符： 作用于两个运算元 JavaScript">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://img-blog.csdn.net/20180224085748686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2tpdGVfeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://davidlee6688.github.io/img/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9F%A5%E6%89%BE.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1797988/201912/1797988-20191215155708186-785877660.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151024134-512558007.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151615691-1017611190.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708152327825-11086376.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png">
<meta property="article:published_time" content="2020-06-04T09:56:44.000Z">
<meta property="article:modified_time" content="2020-06-19T09:54:36.817Z">
<meta property="article:author" content="davidLee">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://common.cnblogs.com/images/copycode.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://davidlee6688.github.io/2020/06/04/2020-2020-06-04-JavaScript教程/"/>





  <title>JavaScript教程 | 前端追梦人</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?52142fac57240aa25d9013d47e5ec0f1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">前端追梦人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">learn forever</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://davidlee6688.github.io/2020/06/04/2020-2020-06-04-JavaScript%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="davidLee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端追梦人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript教程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-04T17:56:44+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/04/2020-2020-06-04-JavaScript%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/2020-2020-06-04-JavaScript%E6%95%99%E7%A8%8B/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h1><h2 id="1-1-JavaScript之HelloWorld"><a href="#1-1-JavaScript之HelloWorld" class="headerlink" title="1.1 JavaScript之HelloWorld"></a>1.1 JavaScript之HelloWorld</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"hello world!!!"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>script可以内联代码，也可以通过src属性来引入外部指定脚本代码</p>
<h2 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 运算符"></a>1.2 运算符</h2><p>运算元：  指的是运算符作用的对象</p>
<p>一元运算符： 作用于一个运算元</p>
<p>二元运算符： 作用于两个运算元</p>
<p>JavaScript中运算符主要用于连接简单表达式，组成一个复杂的表达式。常见的有算数表达式、比较表达式、逻辑表达式、赋值表达式等，也有单目运算符，指操作原始表达式。大多数运算符都由标点符号组成（+、&gt;=、!），也有关键字表示的运算符，如typeof、delete、instanceof等。</p>
<ul>
<li><p>一、算数运算符：<br>1、加法运算符：a + b<br>2、减法运算符： a - b<br>3、乘法运算符： a * b<br>4、除法运算符：a / b<br>5、余数运算符：a % b<br>6、自增运算符：++a 或者a++<br>7、自减运算符：–a 或者 a–<br>8、求负运算符：-a<br>9、数值运算符： +a</p>
</li>
<li><p>二、赋值运算符：<br>赋值运算符用于给变量赋值,最常见的赋值运算符是等号，表达式a=b表示将b赋值给a.<br>1、a += b // 等同于 a = a + b<br>2、a -= b // 等同于 a = a - b<br>3、a *= b // 等同于 a = a * b<br>4、a /= b // 等同于 a = a / b<br>5、a %= b // 等同于 a = a % b<br>6、a &gt;&gt;= b // 等同于 a = a &gt;&gt; b<br>7、a &lt;&lt;= b // 等同于 a = a &lt;&lt; b<br>8、a &gt;&gt;&gt;= b // 等同于 a = a &gt;&gt;&gt; b<br>9、a &amp;= b // 等同于 a = a &amp; b<br>10、a |= b // 等同于 a = a | b<br>11、a ^= b // 等同于 a = a ^ b</p>
</li>
<li><p>三、比较运算符：<br>比较运算符比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript提供了8个比较运算符。<br>1、相等:==<br>2、严格相等: ===<br>3、不相等:!=<br>4、严格不相等:!==<br>5、小于:&lt;<br>6、小于或等于:&lt;=<br>7、大于:&gt;<br>8、大于或等于:&gt;=</p>
</li>
<li><p>四、三元运算符:<br>语法：表达式1 ? 表达式2 : 表达式3<br>说明：如果表达式1为true ，则整个表达式的结果就是表达式2的值，如果表达式false，则整个表达式的结果就是表达式3的值.</p>
</li>
<li><p>五、位运算符:<br>1、或运算：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。<br>2、与运算：符号为&amp;，表示两个二进制位都为1，则结果为1，否则为0。<br>3、否运算：符号为～，表示将一个二进制位变成相反值。<br>4、异或运算：符号为ˆ，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。<br>5、左移运算：符号为&lt;&lt;右<br>6、移运算：符号为&gt;&gt;</p>
</li>
</ul>
<p><strong>运算符的优先级</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>运算符</strong></th>
<th align="center"><strong>说明</strong></th>
<th align="center"><strong>结合性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>[]</code>、<code>.</code>、<code>()</code></td>
<td align="center">字段访问、数组索引、函数调用和表达式分组</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">++ – -~!delete new typeof void</td>
<td align="center">一元运算符、返回数据类型、对象创建、未定 义的值</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*、/、%</td>
<td align="center">相乘、相除、求余数</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+、-</td>
<td align="center">相加、相减、字符串串联</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
<td align="center">左位移、右位移、无符号右移</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td align="center">小于、小于或等于、大于、大于或等于、是否 为特定类的实例</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">==、!=、===、!==</td>
<td align="center">相等、不相等、全等，不全等</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;</td>
<td align="center">按位“与”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">^</td>
<td align="center">按位“异或”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">|</td>
<td align="center">按位“或”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&amp;&amp;</td>
<td align="center">短路与（逻辑“与”）</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">||</td>
<td align="center">短路或（逻辑“或”）</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">?:</td>
<td align="center">条件运算符</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">=、+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;、&lt;=、&gt;、&gt;=、&gt;&gt;=</td>
<td align="center">混合赋值运算符</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">,</td>
<td align="center">多个计算</td>
<td align="center">按优先级计算，然后从右向左</td>
</tr>
</tbody></table>
<h2 id="1-3-switch语句"><a href="#1-3-switch语句" class="headerlink" title="1.3 switch语句"></a>1.3 switch语句</h2><p><code>switch</code> 语句可以替代多个 <code>if</code> 判断。</p>
<p><code>switch</code> 语句为多分支选择的情况提供了一个更具描述性的方式。</p>
<p><code>switch</code> 语句有至少一个 <code>case</code> 代码块和一个可选的 <code>default</code> 代码块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    alert( <span class="string">'Too small'</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert( <span class="string">'Exactly!'</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert( <span class="string">'Too big'</span> );</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert( <span class="string">"I don't know such values"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任何表达式都可以成为</strong> <code>switch/case</code> <strong>的参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (+a) &#123;</span><br><span class="line">  <span class="keyword">case</span> b + <span class="number">1</span>:</span><br><span class="line">    alert(<span class="string">"this runs, because +a is 1, exactly equals b+1"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">"this doesn't run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>+a</code> 返回 <code>1</code>，这个值跟 <code>case</code> 中 <code>b + 1</code> 相比较，然后执行对应的代码。</p>
<p><strong>Case分组</strong></p>
<p>共享同一段代码的几个 <code>case</code> 分支可以被分为一组：</p>
<p>比如，如果我们想让 <code>case 3</code> 和 <code>case 5</code> 执行同样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert(<span class="string">'Right!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// (*) 下面这两个 case 被分在一组</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert(<span class="string">'Wrong!'</span>);</span><br><span class="line">    alert(<span class="string">"Why don't you take a math class?"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">'The result is strange. Really.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch的case执行的是严格相等，因此类型必须匹配</strong></p>
<h2 id="1-4-值的比较"><a href="#1-4-值的比较" class="headerlink" title="1.4 值的比较"></a>1.4 值的比较</h2><p>值的比较</p>
<p>我们知道，在数学中有很多用于比较大小的运算符：</p>
<ul>
<li>大于 / 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。</li>
<li>大于等于 / 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。</li>
<li>检查两个值的相等：<code>a == b</code>（注意表达式中是两个等号 <code>=</code>，若写为单个等号 <code>a = b</code> 则表示赋值）。</li>
<li>检查两个值不相等，在数学中使用 <code>≠</code> 符号，而在 JavaScript 中则通过在赋值符号前加叹号表示：`a != b</li>
</ul>
<p><a href="https://zh.javascript.info/comparison#bi-jiao-jie-guo-wei-boolean-lei-xing" target="_blank" rel="noopener">比较结果为 Boolean 类型</a></p>
<p>和其他运算符一样，比较运算符也会有返回值，返回值为布尔值（Boolean）。</p>
<ul>
<li><code>true</code> —— 表示“yes（是）”，“correct（正确）”或“the truth（真相）”。</li>
<li><code>false</code> —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真相）”。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="number">2</span> &gt; <span class="number">1</span> );  <span class="comment">// true（正确）</span></span><br><span class="line">alert( <span class="number">2</span> == <span class="number">1</span> ); <span class="comment">// false（错误）</span></span><br><span class="line">alert( <span class="number">2</span> != <span class="number">1</span> ); <span class="comment">// true（正确）</span></span><br></pre></td></tr></table></figure>

<p>和其他类型的值一样，比较的结果可以被赋值给任意变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">5</span> &gt; <span class="number">4</span>; <span class="comment">// 把比较的结果赋值给 result</span></span><br><span class="line">alert( result ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh.javascript.info/comparison#zi-fu-chuan-bi-jiao" target="_blank" rel="noopener">字符串比较</a></p>
<p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。</p>
<p>换言之，字符串是按字符（母）逐个进行比较的。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">'Z'</span> &gt; <span class="string">'A'</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">'Glow'</span> &gt; <span class="string">'Glee'</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">'Bee'</span> &gt; <span class="string">'Be'</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>字符串的比较算法非常简单：</p>
<ol>
<li>首先比较两个字符串的首位字符大小。</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。</li>
</ol>
<p>在上面的例子中，<code>&#39;Z&#39; &gt; &#39;A&#39;</code> 在算法的第 1 步就得到了返回结果，而字符串 <code>Glow</code> 与 <code>Glee</code> 则继续逐个字符比较：</p>
<ol>
<li><code>G</code> 和 <code>G</code> 相等。</li>
<li><code>l</code> 和 <code>l</code> 相等。</li>
<li><code>o</code> 比 <code>e</code> 大，算法停止，第一个字符串大于第二个。</li>
</ol>
<p><strong>非真正的字典顺序，而是 Unicode 编码顺序</strong></p>
<p>在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。</p>
<p>比如说，字符串比较对字母大小写是敏感的。大写的 <code>&quot;A&quot;</code> 并不等于小写的 <code>&quot;a&quot;</code>。哪一个更大呢？实际上小写的 <code>&quot;a&quot;</code> 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 <a href="https://zh.javascript.info/string" target="_blank" rel="noopener">字符串</a> 这章讨论更多关于字符串的细节。</p>
<p><a href="https://zh.javascript.info/comparison#bu-tong-lei-xing-jian-de-bi-jiao" target="_blank" rel="noopener">不同类型间的比较</a></p>
<p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">'2'</span> &gt; <span class="number">1</span> ); <span class="comment">// true，字符串 '2' 会被转化为数字 2</span></span><br><span class="line">alert( <span class="string">'01'</span> == <span class="number">1</span> ); <span class="comment">// true，字符串 '01' 会被转化为数字 1</span></span><br></pre></td></tr></table></figure>

<p>对于布尔类型值，<code>true</code> 会被转化为 <code>1</code>、<code>false</code> 转化为 <code>0</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="literal">true</span> == <span class="number">1</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="literal">false</span> == <span class="number">0</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>一个有趣的现象</strong></p>
<p>有时候，以下两种情况会同时发生：</p>
<ul>
<li>若直接比较两个值，其结果是相等的。</li>
<li>若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 <code>true</code>，一个是 <code>false</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">alert( <span class="built_in">Boolean</span>(a) ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"0"</span>;</span><br><span class="line">alert( <span class="built_in">Boolean</span>(b) ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">alert(a == b); <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 <code>&quot;0&quot;</code> 变成了 <code>0</code>）。若只是将一个变量转化为 <code>Boolean</code> 值，则会使用其他的类型转换规则。</p>
<p><a href="https://zh.javascript.info/comparison#yan-ge-xiang-deng" target="_blank" rel="noopener">严格相等</a></p>
<p>普通的相等性检查 <code>==</code> 存在一个问题，它不能区分出 <code>0</code> 和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="number">0</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也同样无法区分空字符串和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="string">''</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是因为在比较不同类型的值时，处于相等判断符号 <code>==</code> 两侧的值会先被转化为数字。空字符串和 <code>false</code> 也是如此，转化后它们都为数字 0。</p>
<p>如果我们需要区分 <code>0</code> 和 <code>false</code>，该怎么办？</p>
<p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
<p>换句话说，如果 <code>a</code> 和 <code>b</code> 属于不同的数据类型，那么 <code>a === b</code> 不会做任何的类型转换而立刻返回 <code>false</code>。</p>
<p>让我们试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="number">0</span> === <span class="literal">false</span> ); <span class="comment">// false，因为被比较值的数据类型不同</span></span><br></pre></td></tr></table></figure>

<p>同样的，与“不相等”符号 <code>!=</code> 类似，“严格不相等”表示为 <code>!==</code>。</p>
<p>严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。</p>
<p><a href="https://zh.javascript.info/comparison#dui-null-he-undefined-jin-hang-bi-jiao" target="_blank" rel="noopener">对 null 和 undefined 进行比较</a></p>
<p>当使用 <code>null</code> 或 <code>undefined</code> 与其他值进行比较时，其返回结果常常出乎你的意料。</p>
<ul>
<li><p>当使用严格相等 <code>===</code> 比较二者时</p>
<p>它们不相等，因为它们属于不同的类型。<code>alert( null === undefined ); // false</code></p>
</li>
<li><p>当使用非严格相等 <code>==</code> 比较二者时</p>
<p>JavaScript 存在一个特殊的规则，会判定它们相等。他们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。<code>alert( null == undefined ); // true</code></p>
</li>
<li><p>当使用数学式或其他比较方法 <code>&lt; &gt; &lt;= &gt;=</code> 时：</p>
<p><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</p>
</li>
</ul>
<p>下面让我们看看，这些规则会带来什么有趣的现象。同时更重要的是，我们需要从中学会如何远离这些特性带来的“陷阱”。</p>
<p><a href="https://zh.javascript.info/comparison#qi-guai-de-jie-guo-nullvs0" target="_blank" rel="noopener">奇怪的结果：null vs 0</a></p>
<p>通过比较 <code>null</code> 和 0 可得：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                               alert( <span class="literal">null</span> &gt; <span class="number">0</span> );  <span class="comment">// (1) false</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="number">0</span> ); <span class="comment">// (2) false</span></span><br><span class="line">alert( <span class="literal">null</span> &gt;= <span class="number">0</span> ); <span class="comment">// (3) true</span></span><br></pre></td></tr></table></figure>

<p>是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“<code>null</code> 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。</p>
<p>为什么会出现这种反常结果，这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。这就是为什么（3）中 <code>null &gt;= 0</code> 返回值是 true，（1）中 <code>null &gt; 0</code> 返回值是 false。</p>
<p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 <code>null == 0</code> 会返回 false。</p>
<p><a href="https://zh.javascript.info/comparison#te-li-du-hang-de-undefined" target="_blank" rel="noopener">特立独行的 undefined</a></p>
<p><code>undefined</code> 不应该被与其他值进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert( <span class="literal">undefined</span> &gt; <span class="number">0</span> ); <span class="comment">// false (1)</span></span><br><span class="line">alert( <span class="literal">undefined</span> &lt; <span class="number">0</span> ); <span class="comment">// false (2)</span></span><br><span class="line">alert( <span class="literal">undefined</span> == <span class="number">0</span> ); <span class="comment">// false (3)</span></span><br></pre></td></tr></table></figure>

<p>为何它看起来如此厌恶 0？返回值都是 false！</p>
<p>原因如下：</p>
<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
<p><a href="https://zh.javascript.info/comparison#gui-bi-cuo-wu" target="_blank" rel="noopener">规避错误</a></p>
<p>我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：</p>
<p>除了严格相等 <code>===</code> 外，其他凡是有 <code>undefined/null</code> 参与的比较，我们都需要额外小心。</p>
<p>除非你非常清楚自己在做什么，否则永远不要使用 <code>&gt;= &gt; &lt; &lt;=</code> 去比较一个可能为 <code>null/undefined</code> 的变量。对于取值可能是 <code>null/undefined</code> 的变量，请按需要分别检查它的取值情况。</p>
<p><a href="https://zh.javascript.info/comparison#zong-jie" target="_blank" rel="noopener">总结</a></p>
<ul>
<li>比较运算符始终返回布尔值。</li>
<li>字符串的比较，会按照“词典”顺序逐字符地比较大小。</li>
<li>当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。</li>
<li>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</li>
<li>在使用 <code>&gt;</code> 或 <code>&lt;</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</li>
</ul>
<h2 id="1-5-函数Function"><a href="#1-5-函数Function" class="headerlink" title="1.5 函数Function"></a>1.5 函数Function</h2><p>一、函数基本概念</p>
<p>　　为完成某一功能的程序指令(语句)的集合，称为函数。</p>
<p>二、JavaScript函数的分类</p>
<p>　　1、自定义函数(我们自己编写的函数)，如：function funName(){}</p>
<p>　　2、系统函数(JavaScript自带的函数)，如alert函数。</p>
<p>三、函数的调用方式</p>
<p>　　1、普通调用：functionName(实际参数…)</p>
<p>　　2、通过指向函数的变量去调用：</p>
<p>　　　　　　var myVar=函数名;</p>
<p>　　　　　　myVar(实际参数…);</p>
<p>四、函数返回值</p>
<p>　　1.当函数无明确返回值时，返回的值就是”undefined”。</p>
<p>　　2.当函数有返回值时，返回值是什么就返回什么。</p>
<p>五、函数的可变参数:</p>
<p>函数的参数列表可以是任意多个，并且数据类型可以是任意的类型，JavaScript的函数天然支持可变参数，JavaScript有一个arguments变量可以访问所有传到函数内部的参数。</p>
<p><strong>范例：JavaScript使用arguments创建参数可变的函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">/*add函数是一个参数可变的函数*/</span></span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">var</span> result=<span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line"> <span class="number">6</span>             <span class="comment">//alert(arguments[i]);</span></span><br><span class="line"> <span class="number">7</span>             result+=<span class="built_in">arguments</span>[i];</span><br><span class="line"> <span class="number">8</span>         &#125;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     alert(<span class="string">"add(1,2,3)="</span>+add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用add函数时传入3个参数</span></span><br><span class="line"><span class="number">13</span>     alert(<span class="string">"add(1,2,3,4,5,6)="</span>+add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));<span class="comment">//调用add函数时传入6个参数</span></span><br><span class="line"><span class="number">14</span>     alert(<span class="string">"add()="</span>+add());<span class="comment">//调用add函数时不传入参数</span></span><br><span class="line"><span class="number">15</span>     alert(<span class="string">"add(1,\"HelloWorld\")="</span>+add(<span class="number">1</span>,<span class="string">"HelloWorld"</span>));<span class="comment">//调用add函数时传入不同类型的参数</span></span><br><span class="line"><span class="number">16</span>   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>六、函数的动态创建</p>
<p>　　<strong>创建动态函数的基本格式：var 变量名 = new Function(“参数1”，”参数2”，”参数n”，”执行语句”);</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">var</span> square = <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"var sum ; sum = x+y;return sum;"</span>);</span><br><span class="line"><span class="number">3</span>     alert(<span class="string">"square(2,3)的结果是："</span>+square(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="number">4</span>   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>七、匿名函数</p>
<p>　直接声明一个匿名函数，立即使用。用匿名函数的好处就是省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突，一旦命名冲突以最后声明的为准。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="function"><span class="keyword">function</span>(<span class="params">i1, i2</span>) </span>&#123; <span class="keyword">return</span> i1 + i2; &#125;(<span class="number">10</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>八、JavaScript不支持函数重载</p>
<p>九. 函数表达式</p>
<p>另一种创建函数的语法称为 <strong>函数表达式</strong>。</p>
<p>通常会写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，函数被创建并像其他赋值一样，被明确地分配给了一个变量。不管函数是被怎样定义的，都只是一个存储在变量 <code>sayHi</code> 中的值。</p>
<p>上面这两段示例代码的意思是一样的：“创建一个函数，并把它存进变量 <code>sayHi</code>”。</p>
<p>我们还可以用 <code>alert</code> 打印这个变量值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( sayHi ); <span class="comment">// 显示函数代码</span></span><br></pre></td></tr></table></figure>

<p>注意，最后一行代码并不会运行函数，因为 <code>sayHi</code> 后没有括号。在其他编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。</p>
<p>在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。</p>
<p>的确，在某种意义上说一个函数是一个特殊值，我们可以像 <code>sayHi()</code> 这样调用它。</p>
<p>但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。</p>
<p>我们可以复制函数到其他变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// (1) 创建</span></span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;    <span class="comment">// (2) 复制</span></span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// Hello     // (3) 运行复制的值（正常运行）！</span></span><br><span class="line">sayHi(); <span class="comment">// Hello    //     这里也能运行（为什么不行呢）</span></span><br></pre></td></tr></table></figure>

<p>解释一下上段代码发生的细节：</p>
<ol>
<li><code>(1)</code> 行声明创建了函数，并把它放入到变量 <code>sayHi</code>。</li>
<li><code>(2)</code> 行将 <code>sayHi</code> 复制到了变量 <code>func</code>。请注意：<code>sayHi</code> 后面没有括号。如果有括号，<code>func = sayHi()</code> 会把 <code>sayHi()</code> 的调用结果写进<code>func</code>，而不是 <code>sayHi</code> <strong>函数</strong> 本身。</li>
<li>现在函数可以通过 <code>sayHi()</code> 和 <code>func()</code> 两种方式进行调用。</li>
</ol>
<p>注意，我们也可以在第一行中使用函数表达式来声明 <code>sayHi</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这两种声明的函数是一样的。</p>
<p><strong>为什么这里末尾会有个分号？</strong></p>
<p>你可能想知道，为什么函数表达式结尾有一个分号 <code>;</code>，而函数声明没有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>答案很简单：</p>
<ul>
<li>在代码块的结尾不需要加分号 <code>;</code>，像 <code>if { ... }</code>，<code>for { }</code>，<code>function f { }</code> 等语法结构后面都不用加。</li>
<li>函数表达式是在语句内部的：<code>let sayHi = ...;</code>，作为一个值。它不是代码块而是一个赋值语句。不管值是什么，都建议在语句末尾添加分号 <code>;</code>。所以这里的分号与函数表达式本身没有任何关系，它只是用于终止语句。</li>
</ul>
<h2 id="1-6-现代模式”use-strict”"><a href="#1-6-现代模式”use-strict”" class="headerlink" title="1.6 现代模式”use strict”"></a>1.6 现代模式”use strict”</h2><p>严格模式是在ES5中引入的，它可以视为JS的一个子集，在严格模式下，限制了JS的标准使用下一些行为。</p>
<ul>
<li>严格模式消除了一些 JavaScript的静默错误，通过改变它们来抛出错误。</li>
<li>严格的模式修复了 JavaScript引擎难以执行优化的错误：有时候，严格模式代码可以比非严格模式的相同的代码运行得更快。</li>
<li>严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。</li>
</ul>
<p>这个指令看上去像一个字符串 <code>&quot;use strict&quot;</code> 或者 <code>&#39;use strict&#39;</code>。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p>
<p><code>&quot;use strict&quot;</code> 可以被放在函数主体的开头，而不是整个脚本的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<p>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p>
<p>一旦进入了严格模式，就没有回头路了。</p>
<h4 id="一：简单介绍"><a href="#一：简单介绍" class="headerlink" title="一：简单介绍"></a>一：简单介绍</h4><p>严格模式是在ES5中引入的，它可以视为JS的一个子集，在严格模式下，限制了JS的标准使用下一些行为。</p>
<ul>
<li>严格模式消除了一些 JavaScript的静默错误，通过改变它们来抛出错误。</li>
<li>严格的模式修复了 JavaScript引擎难以执行优化的错误：有时候，严格模式代码可以比非严格模式的相同的代码运行得更快。</li>
<li>严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。</li>
</ul>
<p>但是需要注意的是：<strong>不支持严格模式的浏览器将会执行与支持严格模式的浏览器不同行为的严格模式代码。</strong>所以不要依靠严格模式，而是应当加强自己代码的鲁棒性</p>
<h4 id="二：使用方法"><a href="#二：使用方法" class="headerlink" title="二：使用方法"></a>二：使用方法</h4><p>严格模式可以应用于整个脚本或单个函数中。其中的<strong>脚本</strong>不仅仅包括了单个文件，还包括了<strong>dom中事件处理，eval()，Function()，以及window.setTimeOut()中的字符串</strong>。</p>
<h5 id="1：为某个脚本使用严格模式"><a href="#1：为某个脚本使用严格模式" class="headerlink" title="1：为某个脚本使用严格模式"></a>1：为某个脚本使用严格模式</h5><p>需要在<strong>所有代码</strong>前，声明</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure>

<p><em>PS：注意，必须为”use strict”;或者’use strict’;，且必须带分号结束。</em><br> 但这种使用方式在存在代码引用和合并的时候，会无法正常激活严格模式。因为，当一个声明了严格模式的脚本，被引入合并到一个新的未使用严格模式的脚本中的时候，由于声明并没有在<strong>所有代码</strong>前使用，从而导致严格模式声明失败。<br> 为了保证严格模式的正常使用，一般的做法是用一个外部匿名函数将使用严格模式的脚本封装，然后执行。代码一般如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">/**** 原有脚本代码 ****/</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，这种方法，会将原有的代码封装到一个全局环境的函数中，原有脚本代码的作用域由全局变为了函数内部作用域，因此在使用的时候，务必注意。<br> <em>PS:一个变通的方法是，将内部脚本需要全局的变量，直接声明为全局变量，即不用var或者let定义，比如a，不适用var a;或者let a;，而是直接 a = xxx</em></p>
<h5 id="2：单函数使用严格模式"><a href="#2：单函数使用严格模式" class="headerlink" title="2：单函数使用严格模式"></a>2：单函数使用严格模式</h5><p>单函数使用严格模式，只需要在函数代码开头声明</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure>

<p>即可</p>
<h4 id="三：严格模式带来的具体差异"><a href="#三：严格模式带来的具体差异" class="headerlink" title="三：严格模式带来的具体差异"></a>三：严格模式带来的具体差异</h4><h5 id="1：消除了静默错误，改为抛出错误"><a href="#1：消除了静默错误，改为抛出错误" class="headerlink" title="1：消除了静默错误，改为抛出错误"></a>1：消除了静默错误，改为抛出错误</h5><ul>
<li>无法静默声明全局变量<br> 全局变量必须显式声明，标准模式下，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i未声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的参数必须命名唯一<br> 在正常模式中，如果函数的参数中出现重名，则最后出现的重名参数替换之前出现的参数，但之前出现的参数依然可以通过arguments属性读取。在严格模式下，禁止出现这种情况，此时会跳出错误。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>)</span>&#123; <span class="comment">// !!! 语法错误</span></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">return</span> a + a + c; <span class="comment">// 代码运行到这里会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的属性名必须唯一<br> 严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">1</span>, <span class="attr">p</span>: <span class="number">2</span> &#125;; <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>禁止出现八进制数字数据<br> 在ES标准中，并没有八进制数据，但现在的浏览器都支持以0开头作为八进制数据。严格模式下禁止了这种数据类型，但在ES6中，新引入了’0o’前缀来表示八进制数据</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">015</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>o10; <span class="comment">// ES6: 八进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任何在正常模式下引起静默失败的赋值操作 (给不可赋值的全局变量赋值，给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 给不可扩展对象(<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FpreventExtensions" target="_blank" rel="noopener">non-extensible</a> object)的新属性赋值) 都会抛出异常</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="literal">NaN</span> = <span class="number">1</span>; <span class="comment">// 不可复制的全局变量</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> v() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"v"</span>, &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;); <span class="comment">// 不可写的属性</span></span><br><span class="line">o.v = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  <span class="keyword">get</span> v() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;  <span class="comment">// 只读属性</span></span><br><span class="line">&#125;;</span><br><span class="line">o1.v = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可扩展对象的新属性赋值</span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = <span class="string">"ohai"</span>; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>试图删除不可删除的属性时会抛出异常</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ECMAScript 6中的严格模式禁止设置<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2Fprimitive" target="_blank" rel="noopener">primitive</a>值的属性.</li>
</ul>
<h5 id="2：修复了JS的随意性，提升了优化能力"><a href="#2：修复了JS的随意性，提升了优化能力" class="headerlink" title="2：修复了JS的随意性，提升了优化能力"></a>2：修复了JS的随意性，提升了优化能力</h5><p>在标准模式下，JS的随意性，或者灵活性，是的很多变量，只有在运行时才能确切知道具体指向，这就使得变量名到内存的映射也只有到运行时才能完成。严格模式修复了大部分这种行为，使得所有的变量名在编译的时候，就已经可以一起进行优化，从而提升了执行速度。</p>
<ul>
<li>禁止使用with<br> 在标准模式中，使用with的时候，with代码块内的变量，只有在运行时，才能根据with引入的Obj是否存在相应的属性，来确定具体的指向。因此，严格模式禁止使用with</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">with</span> (obj) <span class="comment">// !!! 语法错误</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？</span></span><br><span class="line">  <span class="comment">// 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。</span></span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>eval不在为上层作用域引入新变量<br> 在标准模式下，如果某个函数内部引入了eval代码。那么在函数内部，所有出现的<em>名称</em>（也就是所有的变量名）应当映射到的变量，除了引用到函数的参数，以及函数的内部变量，可以在编译的时候确定外，其他所有的<em>名称</em>只有在运行的时候，执行完eval代码后才能映射到相应的变量。因为有些变量可能是由eval代码引入到函数作用域的。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> evalX = <span class="built_in">eval</span>(<span class="string">"'use strict'; var x = 42; x"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="number">17</span>); <span class="comment">// true  未能引入x，所以还是原来的x，但如果去掉 use strict，那么为false</span></span><br><span class="line"><span class="built_in">console</span>.log(evalX === <span class="number">42</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但在严格格式下，eval不在为上层作用域引入新的局部变量和全局变量。所有的eval中出现的变量，只在eval的字符串代码块中有效。<br> 另外如果判定eval是否为严格模式，也存在各种复杂的情况。<br> – 如果<em>直接</em>调用eval(…)代码的代码块显式使用了严格格式，那么eval()也执行严格格式。如下面代码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">eval</span>(...)  <span class="comment">// 无论eval中的字符串是否包含 use strict; 都会进入严格格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– 如果直接调用eval的代码块未使用严格模式，而是更上级别的代码块使用了严格模式，则eval代码按照标准模式执行，如下面代码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  f()&#123;&#125; <span class="comment">// 无论eval中的字符串是否包含 use strict; 都会进入严格格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– 如果eval(…)的字符串中显式使用了’use strict’; 则必然进入严格模式</p>
<ul>
<li>严格模式禁止删除声明变量</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// !!! 语法错误</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var y; delete y;"</span>); <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<h5 id="3：让eval和arguments变的更加简单"><a href="#3：让eval和arguments变的更加简单" class="headerlink" title="3：让eval和arguments变的更加简单"></a>3：让eval和arguments变的更加简单</h5><ul>
<li>严格模式下，eval和arguments作为保留字<br> 在严格模式下，不允许对eval和arguments进行赋值或者绑定，以下代码全部为错误语法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="number">17</span>;</span><br><span class="line"><span class="built_in">arguments</span>++;</span><br><span class="line">++<span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="keyword">set</span> p(arguments) &#123; &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">eval</span>) </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arguments"</span>, <span class="string">"'use strict'; return 17;"</span>);</span><br></pre></td></tr></table></figure>

<p>经过测试，这里的不得对arguments的复制，指的是arguments这个变量，而不是指的其中的元素，比如</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  a = <span class="number">42</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">17</span>;  <span class="comment">// 可以通过语法检测，但并不会修改b的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是允许的，也可以通过语法检测。</p>
<ul>
<li>严格模式下，参数的值，不会随arguments对象的值的变化而修改。arguments对象的值的修改也不会影响同名函数。<br> 在标准模式下，比如一个函数第一个参数为arg，那么在函数内部，修改arg的时候，也会同步修改arguments[0]，反之亦然。但在严格模式下，两者进行了隔离。函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。</li>
<li>不再支持arguments. callee</li>
</ul>
<h5 id="4：更加安全的JS"><a href="#4：更加安全的JS" class="headerlink" title="4：更加安全的JS"></a>4：更加安全的JS</h5><ul>
<li>对this的严格限制<br> 在普通模式下，无论任何情况下，this都是一个对象。需要注意：this的指向不在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，在标准模式下，只想调用函数的对象。但如果是箭头函数，则this为定义时上下文的this。<br> -使用new新建对象</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> test()</span><br><span class="line"><span class="built_in">console</span>.log(t)  <span class="comment">// this 为新建的对象</span></span><br></pre></td></tr></table></figure>

<p>-使用call，apply，bind传入this，如果传入的是数字，字符串，布尔值等，那么就会将这些基本数据的this转换为Number，String，Boolean对象类型。如果传入的是null和undefined，则为全局变量window，默认调用下，this也为window</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.log(typeof <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">()</span></span>);  <span class="comment">// window  需要注意，单独的此类 fun()，等价于window.fun()。所以为window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="number">2</span>)</span></span>); <span class="comment">// Number</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="string">'2018-01-01 10:00:00'</span>)</span></span>); <span class="comment">// String</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(<span class="literal">null</span>)</span></span>); <span class="comment">// window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(undefined)</span></span>); <span class="comment">// window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">bind</span><span class="params">(<span class="literal">true</span>)</span></span>()); <span class="comment">// Boolean</span></span><br></pre></td></tr></table></figure>

<p>上面的这种模式既增加了转换为对象的对象的开销，又因为将全局对象window暴露出来造成安全性问题。<br> 因此在严格模式下指定的this不再被封装为对象，而且如果没有指定this的话它值是undefined，上面的结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.log(typeof <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">()</span></span>);  <span class="comment">// undefined</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="number">2</span>)</span></span>); <span class="comment">// 2</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="string">'2018-01-01 10:00:00'</span>)</span></span>); <span class="comment">// '2018-01-01 10:00:00'</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(<span class="literal">null</span>)</span></span>); <span class="comment">// null</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(undefined)</span></span>); <span class="comment">// undefined</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">bind</span><span class="params">(<span class="literal">true</span>)</span></span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>禁止对函数扩展，fun.caller和fun.arguments进行读取和复制<br> 在普通模式下用这些扩展的话，当一个叫fun的函数正在被调用的时候，fun.caller是最后一个调用fun的函数，而且fun.arguments包含调用fun时用的形参。通过这些扩展，可以让<em>不安全</em>的用户操作到危险的属性。<br> 因此在严格模式下，fun.caller和fun.arguments都是不可删除的属性而且在存值、取值时都会报错</li>
</ul>
<h5 id="5：对未来的兼容"><a href="#5：对未来的兼容" class="headerlink" title="5：对未来的兼容"></a>5：对未来的兼容</h5><ul>
<li>增加了一些保留字<br> 在严格模式中一部分字符变成了保留的关键字。这些字符包括implements, interface, let, package, private, protected, public, static和yield</li>
<li>禁止不在脚本或者函数层面声明函数<br> 所谓的脚本层面，指的是文件的全局作用域。而函数层面，指的是函数的直接作用域，这里并不包括了脚本中的块作用域，以及函数中嵌套的块作用域</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 合法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eit</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 同样合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-变量"><a href="#1-7-变量" class="headerlink" title="1.7 变量"></a>1.7 变量</h2><p>如果将变量想象成一个“数据”的盒子，盒子上有一个唯一的标注盒子名字的贴纸。这样我们能更轻松地掌握“变量”的概念。</p>
<p>例如，变量 <code>message</code> 可以被想象成一个标有 <code>&quot;message&quot;</code> 的盒子，盒子里面的值为 <code>&quot;Hello!&quot;</code>：</p>
<p>我们可以在盒子内放入任何值。</p>
<p>并且，这个盒子的值，我们想改变多少次，就可以改变多少次：</p>
<p>当值改变的时候，之前的数据就被从变量中删除了：</p>
<p><strong>变量命名</strong></p>
<p>JavaScript 的变量命名有两个限制：</p>
<ol>
<li>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</li>
<li>首字符必须非数字。</li>
</ol>
<p><strong>全局变量和局部变量</strong></p>
<p>全局变量： 声明在全局环境下的变量或者在函数中未使用var而直接赋值的变量也会被自动提升到全局环境</p>
<p>局部变量： 在函数内容声明的变量，只在函数内部有效，如果与全局变量重名，则优先级更高</p>
<h2 id="1-8-条件运算符和"><a href="#1-8-条件运算符和" class="headerlink" title="1.8 条件运算符和?"></a>1.8 条件运算符和?</h2><p><code>if(...)</code> 语句计算括号里的条件表达式，如果计算结果是 <code>true</code>，就会执行对应的代码块。</p>
<p><code>if (…)</code> 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。</p>
<ul>
<li>数字 <code>0</code>、空字符串 <code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都会被转换成 <code>false</code>。因为他们被称为 “falsy” 值。</li>
<li>其他值被转换为 <code>true</code>，所以它们被称为 “truthy”。</li>
</ul>
<p>所以，下面这个条件下的代码永远不会执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">// 0 是 falsy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……但下面的条件 —— 始终有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="comment">// 1 是 truthy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以将未计算的布尔值传入 <code>if</code> 语句，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cond = (year == <span class="number">2015</span>); <span class="comment">// 相等运算符的结果是 true 或 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。</p>
<p>有时我们需要测试一个条件的几个变体。我们可以通过使用 <code>else if</code> 子句实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> year = prompt(<span class="string">'In which year was ECMAScript-2015 specification published?'</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">2015</span>) &#123;</span><br><span class="line">  alert( <span class="string">'Too early...'</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (year &gt; <span class="number">2015</span>) &#123;</span><br><span class="line">  alert( <span class="string">'Too late'</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert( <span class="string">'Exactly!'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>条件运算符</strong></p>
<p>这个运算符通过问号 <code>?</code> 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = condition ? value1 : value2;</span><br></pre></td></tr></table></figure>

<p>计算条件结果，如果结果为真，则返回 <code>value1</code>，否则返回 <code>value2</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> accessAllowed = (age &gt; <span class="number">18</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>技术上讲，我们可以省略 <code>age &gt; 18</code> 外面的括号。问号运算符的优先级较低，所以它会在比较运算符 <code>&gt;</code> 后执行。</p>
<p>下面这个示例会执行和前面那个示例相同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较运算符 “age &gt; 18” 首先执行</span></span><br><span class="line"><span class="comment">//（不需要将其包含在括号中）</span></span><br><span class="line"><span class="keyword">let</span> accessAllowed = age &gt; <span class="number">18</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-交互：alert、prompt-和-confirm"><a href="#1-9-交互：alert、prompt-和-confirm" class="headerlink" title="1.9 交互：alert、prompt 和 confirm"></a>1.9 交互：alert、prompt 和 confirm</h2><p><a href="https://zh.javascript.info/alert-prompt-confirm#alert" target="_blank" rel="noopener">alert</a></p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(message);</span><br></pre></td></tr></table></figure>

<p>运行这行代码，浏览器会弹出一个信息弹窗并暂停脚本，直到用户点击了“确定”。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p>
<p><a href="https://zh.javascript.info/alert-prompt-confirm#prompt" target="_blank" rel="noopener">prompt</a></p>
<p><code>prompt</code> 函数接收两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = prompt(title, [<span class="keyword">default</span>]);</span><br></pre></td></tr></table></figure>

<p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p>
<ul>
<li><p><code>title</code></p>
<p>显示给用户的文本</p>
</li>
<li><p><code>default</code></p>
<p>可选的第二个参数，指定 input 框的初始值。</p>
</li>
</ul>
<p>用户可以在 prompt 对话框的 input 框内输入一些内容，然后点击确定。或者他们可以通过按“取消”按钮或按下键盘的 Esc 键，以取消输入。</p>
<p><code>prompt</code> 将返回用户在 <code>input</code> 框内输入的文本，如果用户取消了输入，则返回 <code>null</code>。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = prompt(<span class="string">'How old are you?'</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`You are <span class="subst">$&#123;age&#125;</span> years old!`</span>); <span class="comment">// You are 100 years old!</span></span><br></pre></td></tr></table></figure>

<p><strong>IE 浏览器会提供默认值</strong></p>
<p>第二个参数是可选的。但是如果我们不提供的话，Internet Explorer 会把 <code>&quot;undefined&quot;</code> 插入到 prompt。</p>
<p>我们可以在 Internet Explorer 中运行下面这行代码来看看效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = prompt(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<p>所以，为了 prompt 在 IE 中有好的效果，我们建议始终提供第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = prompt(<span class="string">"Test"</span>, <span class="string">''</span>); <span class="comment">// &lt;-- for IE</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh.javascript.info/alert-prompt-confirm#confirm" target="_blank" rel="noopener">confirm</a></p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = confirm(question);</span><br></pre></td></tr></table></figure>

<p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p>
<p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoss = confirm(<span class="string">"Are you the boss?"</span>);</span><br><span class="line"></span><br><span class="line">alert( isBoss ); <span class="comment">// 如果“确定”按钮被按下，则显示 true</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>我们学习了与用户交互的 3 个浏览器的特定函数：</p>
<ul>
<li><p><code>alert</code></p>
<p>显示信息。</p>
</li>
<li><p><code>prompt</code></p>
<p>显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 <code>null</code>。</p>
</li>
<li><p><code>confirm</code></p>
<p>显示信息等待用户点击确定或取消。点击确定返回 <code>true</code>，点击取消或按下 Esc 键返回 <code>false</code>。</p>
</li>
</ul>
<p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<h2 id="1-10-数据类型"><a href="#1-10-数据类型" class="headerlink" title="1.10 数据类型"></a>1.10 数据类型</h2><p><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>
<p><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</p>
<blockquote>
<p><strong>注：</strong>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p>
</blockquote>
<p><strong>typeof 操作符</strong></p>
<p>你可以使用 <strong>typeof</strong> 操作符来查看 JavaScript 变量的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"John"</span>                 <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                   <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>                    <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                  <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]              <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;  <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;         <span class="comment">// 返回 function</span></span><br><span class="line"><span class="keyword">typeof</span> myCar                  <span class="comment">// 返回 undefined (如果 myCar 没有声明)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                   <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure>

<p>请注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组(Array)的数据类型是 object</li>
<li>日期(Date)的数据类型为 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型为 undefined<br>（很多开发人员将undefined和undeclared混为一谈，但在JavaScript中它们是两码事。undefined是值的一种,表示变量声明过但还没有进行赋值。undeclared则表示变量还没有被声明过。）</li>
</ul>
<p>如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 <strong>typeof</strong> 来判断他们的类型，因为都是 返回 object。</p>
<p><strong>constructor 属性</strong></p>
<p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"John"</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].constructor              <span class="comment">// 返回函数 Array()   &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.constructor  <span class="comment">// 返回函数 Object()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor             <span class="comment">// 返回函数 Date()    &#123; [native code] &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.constructor         <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 类型转换</strong></p>
<p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<p><strong>将数字转换为字符串</strong></p>
<p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br></pre></td></tr></table></figure>

<p>Number 方法 <strong>toString()</strong> 也是有同样的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.toString()</span><br><span class="line">(<span class="number">123</span>).toString()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).toString()</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.runoob.com/jsref/jsref-obj-number.html" target="_blank" rel="noopener">Number 方法</a> 章节中，你可以找到更多数字转换为字符串的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toExponential()</td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left">toFixed()</td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。(只包含小数位)</td>
</tr>
<tr>
<td align="left">toPrecision()</td>
<td align="left">把数字格式化为指定的长度。(包含整数位)</td>
</tr>
</tbody></table>
<p><strong>将布尔值转换为字符串</strong></p>
<p>全局方法 <strong>String()</strong> 可以将布尔值转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>)     <span class="comment">// 返回 "false"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>)     <span class="comment">// 返回 "true"</span></span><br></pre></td></tr></table></figure>

<p>Boolean 方法 <strong>toString()</strong> 也有相同的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>.toString()     <span class="comment">// 返回 "false"</span></span><br><span class="line"><span class="literal">true</span>.toString()      <span class="comment">// 返回 "true"</span></span><br></pre></td></tr></table></figure>

<p><strong>将日期转换为字符串</strong></p>
<p>Date() 返回字符串。</p>
<p>Date()   // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</p>
<p>全局方法 String() 可以将日期对象转换为字符串。</p>
<p>String(new Date())   // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</p>
<p>Date 方法 <strong>toString()</strong> 也有相同的效果。</p>
<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">obj.toString()  <span class="comment">// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>getDate()</th>
<th>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</th>
</tr>
</thead>
<tbody><tr>
<td>getDay()</td>
<td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>getMonth()</td>
<td>从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<p><strong>将字符串转换为数字</strong></p>
<p>全局方法 <strong>Number()</strong> 可以将字符串转换为数字。</p>
<p>字符串包含数字(如 “3.14”) 转换为数字 (如 3.14).</p>
<p>空字符串转换为 0。</p>
<p>其他的字符串会转换为 NaN (不是个数字)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"3.14"</span>)  <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">" "</span>)    <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">""</span>)    <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">"99 88"</span>)  <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>parseFloat()</th>
<th>解析一个字符串，并返回一个浮点数。</th>
</tr>
</thead>
<tbody><tr>
<td>parseInt()</td>
<td>解析一个字符串，并返回一个整数。</td>
</tr>
</tbody></table>
<p><strong>一元运算符 +</strong></p>
<p><strong>Operator +</strong> 可用于将变量转换为数字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"5"</span>;      <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;      <span class="comment">// x 是一个数字</span></span><br></pre></td></tr></table></figure>

<p>如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"John"</span>;   <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;      <span class="comment">// x 是一个数字 (NaN)</span></span><br></pre></td></tr></table></figure>

<p><strong>将布尔值转换为数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>)     <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>)      <span class="comment">// 返回 1</span></span><br></pre></td></tr></table></figure>

<p><strong>将日期转换为数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">全局方法 <span class="built_in">Number</span>() 可将日期转换为数字。</span><br><span class="line"></span><br><span class="line">d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">Number</span>(d)          <span class="comment">// 返回 1404568027739</span></span><br><span class="line">日期方法 getTime() 也有相同的效果。</span><br><span class="line"></span><br><span class="line">d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime()        <span class="comment">// 返回 1404568027739</span></span><br></pre></td></tr></table></figure>

<p><strong>自动转换类型</strong></p>
<p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="literal">null</span>    <span class="comment">// 返回 5         null 转换为 0</span></span><br><span class="line"><span class="string">"5"</span> + <span class="literal">null</span>  <span class="comment">// 返回"5null"   null 转换为 "null"</span></span><br><span class="line"><span class="string">"5"</span> + <span class="number">1</span>     <span class="comment">// 返回 "51"      1 转换为 "1" </span></span><br><span class="line"><span class="string">"5"</span> - <span class="number">1</span>     <span class="comment">// 返回 4         "5" 转换为 5</span></span><br></pre></td></tr></table></figure>

<p><strong>自动转换为字符串</strong></p>
<p>当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myVar;</span><br><span class="line"></span><br><span class="line">myVar = &#123;<span class="attr">name</span>:<span class="string">"Fjohn"</span>&#125;  <span class="comment">// toString 转换为 "[object Object]"</span></span><br><span class="line">myVar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]       <span class="comment">// toString 转换为 "1,2,3,4"</span></span><br><span class="line">myVar = <span class="keyword">new</span> <span class="built_in">Date</span>()      <span class="comment">// toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200"</span></span><br></pre></td></tr></table></figure>

<p>数字和布尔值也经常相互转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myVar = <span class="number">123</span>             <span class="comment">// toString 转换为 "123"</span></span><br><span class="line">myVar = <span class="literal">true</span>            <span class="comment">// toString 转换为 "true"</span></span><br><span class="line">myVar = <span class="literal">false</span>           <span class="comment">// toString 转换为 "false"</span></span><br></pre></td></tr></table></figure>

<p>下表展示了使用不同的数值转换为数字(Number), 字符串(String), 布尔值(Boolean):</p>
<table>
<thead>
<tr>
<th align="left">原始值</th>
<th align="left">转换为数字</th>
<th align="left">转换为字符串</th>
<th align="left">转换为布尔值</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">false</td>
<td align="left">0</td>
<td align="left">“false”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_false" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">true</td>
<td align="left">1</td>
<td align="left">“true”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_true" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">“0”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_number_0" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">“1”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_number_1" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“0”</td>
<td align="left">0</td>
<td align="left">“0”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_0" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“000”</td>
<td align="left">0</td>
<td align="left">“000”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_000" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“1”</td>
<td align="left">1</td>
<td align="left">“1”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_1" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">NaN</td>
<td align="left">NaN</td>
<td align="left">“NaN”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_nan" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">Infinity</td>
<td align="left">Infinity</td>
<td align="left">“Infinity”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_infinity" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">-Infinity</td>
<td align="left">-Infinity</td>
<td align="left">“-Infinity”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_infinity_minus" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“”</td>
<td align="left">0</td>
<td align="left">“”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_empty" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“20”</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_number" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“Runoob”</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_text" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[ ]</td>
<td align="left">0</td>
<td align="left">“”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_empty" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[20]</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_one_number" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[10,20]</td>
<td align="left">NaN</td>
<td align="left">“10,20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_two_numbers" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[“Runoob”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_one_string" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[“Runoob”,”Google”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob,Google”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_two_strings" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">function(){}</td>
<td align="left">NaN</td>
<td align="left">“function(){}”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_function" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">{ }</td>
<td align="left">NaN</td>
<td align="left">“[object Object]”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_object" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">0</td>
<td align="left">“null”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_null" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">NaN</td>
<td align="left">“undefined”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_undefined" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
</tbody></table>
<h3 id="2-0-1-值"><a href="#2-0-1-值" class="headerlink" title="2.0.1 值"></a>2.0.1 值</h3><ul>
<li><p>数组</p>
<ul>
<li>和其他强类型语言不同，在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组就是通过这种方式来实现的）</li>
<li>对数组声明后即可向其中加入值，不需要预先设定大小</li>
<li>使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化</li>
<li>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）</li>
<li>类数组<br>有时需要将类数组（一组通过数字索引的值）转换为真正的数组例如，一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）。工具函数slice(..)经常被用于这类转换：<br><code>Array.prototype.slice.call( arguments )</code></li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符串不可变: 指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
</li>
<li><p>许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串，如<code>Array.prototype.join.call(a, &quot;-&quot;)</code> <code>Array.prototype.map.call(a, (v) =&gt; {})</code>;<br>`Array.prototype<br><strong>数组逆序</strong>（借用Array.prototype.reverse(),但是这个函数只能作用于可变对象，字符串为不可变对象，因此进行变通使用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> c = a.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数字</p>
<ul>
<li><p>JavaScript只有一种数值类型：number（数字），包括“整数”和带小数的十进制数</p>
</li>
<li><p>由于数字值可以使用Number对象进行封装（参见第3章），因此数字值可以调用Number.prototype中的方法, <code>toFixed</code>, <code>toPrecision()</code>,等`</p>
</li>
<li><p>还可以使用指数形式<code>1E3</code>, 二进制，八进制和十六进制(0x)来表示</p>
</li>
<li><p>较小的数值： 二进制浮点数最大的问题（不仅JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现如下情况：<code>0.1 + 0.2 === 0.3</code> 为false</p>
<p>二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断结果为false。</p>
<p>那么应该怎样来判断0.1 + 0.2和0.3是否相等呢？最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript的数字来说，这个值通常是2^-52 (2.220446049250313e-16)。</p>
<p>从ES6开始，该值定义在<code>Number.EPSILON</code>，可以基于这个误差值来解决上述问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">n1, n2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(equal(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>));</span><br></pre></td></tr></table></figure>

<p><strong>整数的安全范围</strong></p>
<p>能够呈现的最大浮点数大约是1.798e+308（这是一个相当大的数字），它定义在Number. MAXVALUE中。最小浮点数定义在Number.MIN VALUE中，大约是5e-324，它不是负数，但无限接近于0！</p>
<p>数字的呈现方式决定了“整数”的安全值范围远远小于Number.MAX VALUE。</p>
<p>能够被“安全”呈现的最大整数是2^53-1，即9007199254740991，在ES6中被定义为Number.MAX SAFE INTEGER。最小整数是-9007199254740991，在ES6中被定义为Number.MIN SAFE INTEGER。<br><strong>整数检测</strong></p>
<p>ES6: <code>Number.isInteger()</code><br>Polyfill</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> num === <span class="string">"number"</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>安全整数检测</strong><br>ES6: <code>Number.isSafeInteger()</code></p>
<p>Polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp; <span class="built_in">Math</span>.abs(num) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>特殊的值</p>
<ul>
<li><p><strong>undefined和null</strong> : undefined类型只有一个值，即undefined。null类型也只有一个值，即null。它们的名称既是类型也是值。undefined和null常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。</p>
<p>例如：<br>• null指空值（empty value）• undefined指没有值（missing value）或者：• undefined指从未赋值• null指曾赋过值，但是目前没有值null是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而undefined却是一个标识符，可以被当作变量来使用和赋值。</p>
</li>
<li><p>void运算符: void并不改变表达式的结果，只是让表达式不返回值<br><code>return void setTImeout(doSomething, 100)</code></p>
</li>
<li><p>特殊的数字：<br><strong>NaN</strong>是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。ES6开始我们可以使用工具函数<code>Number.isNaN(..)</code>, ES6之前使用<code>window.isNaN</code></p>
<p><strong>Infinity和-Infinity</strong>:   如果数学运算（如加法）的结果超出处理范围，则由IEEE 754规范中的“就近取整”（round-to-nearest）模式来决定最后的结果。例如，相对于Infinity, Number.MAX VALUE +Math.pow(2, 969)与Number.MAX VALUE更为接近，因此它被“向下取整”（round down）；而Number.MAX VALUE + Math.pow(2, 970)与Infinity更为接近，所以它被“向上取整”（roundup）。</p>
<p><strong>+0和-0</strong>:   我们可以使用以下代码来区分+0和-0: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNegZero</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  n = <span class="built_in">Number</span>( n );</span><br><span class="line">  <span class="keyword">return</span> ( n === <span class="number">0</span> ) &amp;&amp; ( <span class="number">1</span> / n === -<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>特殊等式</strong><br>如前所述，NaN和-0在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..)（或者polyfill）。而-0等于0（对于===也是如此，参见第4章），因此我们必须使用isNegZero(..)这样的工具函数。ES6中新加入了一个工具方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有的特殊情况：<br>对于ES6之前的版本，Object.is(..)有一个简单的polyfill：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为-0</span></span><br><span class="line">    <span class="keyword">if</span>(v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/v1 === <span class="number">1</span>/v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是NaN</span></span><br><span class="line">    <span class="keyword">if</span>(v1 !== v1)&#123;</span><br><span class="line">        <span class="keyword">return</span> v2 !== v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="keyword">return</span> v1 === v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-0-2-原生函数"><a href="#2-0-2-原生函数" class="headerlink" title="2.0.2 原生函数"></a>2.0.2 原生函数</h3><p>常用的原生函数有：</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()——ES6中新加入的！实际上，它们就是内建函数。</li>
</ul>
<p><strong>内部属性[[Class]]</strong></p>
<p>所有typeof返回值为”object”的对象（如数组）都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/regexp-literal/i</span>));</span><br><span class="line"><span class="comment">// 基本类型值被各自的封装对象自动包装，所以它们的内部[[Class]]属性值分别为"String"、"Number"和"Boolean"。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"abc"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">42</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p><strong>封装对象包装</strong></p>
<p>封装对象（object wrapper）扮演着十分重要的角色。由于基本类型值没有．length和．toString()这样的属性和方法，需要通过封装对象才能访问，此时JavaScript会自动为基本类型值包装（box或者wrap）一个封装对象：</p>
<p>如果需要经常用到这些字符串属性和方法，比如在for循环中使用i &lt; a.length，那么从一开始就创建一个封装对象也许更为方便，这样JavaScript引擎就不用每次都自动创建了。但实际证明这并不是一个好办法，因为浏览器已经为．length这样的常见情况做了性能优化，直接使用封装对象来“提前优化”代码反而会降低执行效率。</p>
<p>一般情况下，我们不需要直接使用封装对象。最好的办法是让JavaScript引擎自己决定什么时候应该使用封装对象。换句话说，就是应该优先考虑使用”abc”和42这样的基本类型值，而非newString(“abc”)和new Number(42)。<br><strong>拆封</strong><br>如果想要得到封装对象中的基本类型值，可以使用valueOf()函数：<code>var a = new String(&quot;abc&quot;); console.log(a.valueOf());</code></p>
<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封(强制类型转换)<code>var a = new String(&quot;abc&quot;); var b = a + &quot;&quot;;</code></p>
<h3 id="2-0-3-强制类型转换"><a href="#2-0-3-强制类型转换" class="headerlink" title="2.0.3 强制类型转换"></a>2.0.3 <strong>强制类型转换</strong></h3><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。</p>
<p>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）</p>
<p>在介绍显示和隐式类型转换之前我们需要先掌握<strong>字符串</strong>，<strong>数字</strong>和<strong>布尔值</strong>之间类型转换的<strong>基本规则</strong>。</p>
<ul>
<li><p><strong>toString()</strong><br>它负责<strong>非字符串到字符串的强制类型转换</strong></p>
<ul>
<li><strong>基本类型值的字符串化规则</strong>为: null转换为”null”, undefined转换为”undefined”， true转换为”true”, 数字类型转化为带引号的字符串，数字的极大值，极小值转换为指数形式 </li>
<li><strong>普通对象</strong>，返回内部属性[[Class]](如”[object Object]”),如果对象有自己的toString()方法，就会使用该方法的返回值。</li>
<li><strong>数组的toString()</strong>就经过了重新定义，将所有单元字符串化以后再用<strong>“,”</strong>连接起来</li>
</ul>
<p><strong>JSON字符串化</strong><br>JSON.stringify()并非严格意义上的强制类型转换，因为其中也涉及toString()的相关规则，这里顺带介绍一下，<strong>对大多数简单值来说, JSON字符串化和toString()效果基本相同</strong>，只不过序列化的结果总是字符串，所有安全的JSON值(<strong>JSON-safe</strong>)都可以使用JSON.stringify()字符串化，安全的JSON值是指能够呈现为有效JSON格式的值。undefined, function, symbol和包含循环引用的对象都不符合JSON结构标准。<strong>JSON.stringify()在对象中遇到undefined，function和symbol时会自动将其忽略，在数组中返回null(以保证数组元素位置不变)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<p>对包含循环引用的对象执行JSON.stringify()会报错，如果对象定义了<strong>toJSON()</strong>方法，JSON字符串化会首先调用该方法，然后用它的返回值来进行序列化。<br>如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义toJSON()方法来返回一个安全的JSON</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用对象的字符串化会报错</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: o,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在a中创建一个循环引用</span></span><br><span class="line">o.e = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(a);  <span class="comment">// TypeError: Converting circular structure to JSON</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toJSON返回的应该是一个适当的值，可以是任何类型，然后再由JSON.stringify()对其进行格式化,</span></span><br><span class="line"><span class="comment">// 也就是toJSON()应该返回一个能够被字符串化的安全的JSON值，而不是返回一个JSON字符串</span></span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="keyword">this</span>.b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(a));  <span class="comment">// &#123;"b": 42&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以向JSON.stringify()传递一个参数<strong>replacer</strong>，它可以是数组或者函数，用来指定序列化过程中<strong>哪些属性应该被处理，哪些应该被排除</strong><br><strong>如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他属性将被忽略</strong><br>如果replacer是一个<strong>函数</strong>，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值，如果要忽略某个键就返回undefined，否则返回指定的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replacer参数排除属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    job: <span class="string">"frontender"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, [<span class="string">"name"</span>, <span class="string">"age"</span>])); <span class="comment">// &#123;"name":"david","age":27&#125;, jon属性被排除了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, (k, v) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用"</span>); <span class="comment">// 调用4次</span></span><br><span class="line">    <span class="keyword">if</span>(k !== <span class="string">"job"</span>)&#123; <span class="keyword">return</span> v &#125;  <span class="comment">// 排除job属性</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>JSON.stringify()还有一个参数<strong>space</strong>，用来指定输出的缩进格式，space为正整数时是指定每一级缩进的字符数,它可以为一个字符串，此时最前面的10个字符用于每一级的缩进</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用space参数指定缩进</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">"***"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>toNumber</strong><br><strong>true转换为1</strong>， <strong>false转换为0</strong>, <strong>undefined转换为NaN</strong>, <strong>null转换为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>));  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>为了将值转换为相应的基本类型值，抽象操作toPrimitive会<strong>首先该值是否有valueOf()方法</strong>，如果有并且返回基本类型的值，就是用该值进行强制类型转换，如果<strong>没有就使用toString()的返回值</strong>(如果存在)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">c.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">""</span>); <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(a)); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(b)); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(c)); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">""</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([]));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">0</span>])); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="string">"abc"</span>]));  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">* **toBoolean**</span><br><span class="line">首先，也是最重要的一点是，JavaScript中有两个关键词true和false，分别代表布尔类型中的真和假。我们常误以为数值1和0分别等同于true和false。在有些语言中可能是这样，但在JavaScript中布尔值和数字是不一样的。虽然我们可以将1强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。</span><br><span class="line">  </span><br><span class="line">  **假值**</span><br><span class="line">  JavaScript中的值可以分为以下两类：</span><br><span class="line">  (1) **可以被强制类型转换为false的值**</span><br><span class="line">  (2) 其他（被强制类型转换为true的值）</span><br><span class="line">  以下这些是假值：**undefined**， **null**， **false**， **+0**、**-0**和**NaN**， &quot;&quot;假值的布尔强制类型转换结果为false。</span><br><span class="line">**真值**</span><br><span class="line">  </span><br><span class="line">假值列表之外的值都是真值</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;javascript</span><br><span class="line">  var a &#x3D; &quot;false&quot;;</span><br><span class="line">  var b &#x3D; &quot;0&quot;;</span><br><span class="line">  var c &#x3D; &quot;&#39;&#39;&quot;;</span><br><span class="line">  &#x2F;&#x2F; 因为a,b,c都不是空字符串，因此转换成Boolean,都为真值</span><br><span class="line">  console.log(Boolean(a));  &#x2F;&#x2F; true</span><br><span class="line">  console.log(Boolean(b));  &#x2F;&#x2F; true</span><br><span class="line">  console.log(Boolean(c));  &#x2F;&#x2F; true</span><br><span class="line">  var d &#x3D; Boolean(a &amp;&amp; b &amp;&amp; c);</span><br><span class="line">  console.log(d);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>显示强制类型转换</strong><br><strong>字符串和数字之间的转换</strong>: 使用<strong>String</strong>()和<strong>Number</strong>()(没有new关键字), 转换规则分别遵守前面toString()和toNumber()规则<br>除了String(..)和Number(..)以外，还有其他方法可以实现字符串和数字之间的显式转换：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"3.14"</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<p>a.toString()是显式的（“toString”意为“to a string”），不过其中涉及隐式转换。因为toString()对42这样的基本类型值不适用，所以JavaScript引擎会<strong>自动为42创建一个封装对象</strong>，然后对该对象调用toString()。这里显式转换中含有隐式转换。</p>
<p>上例中<strong>+c是+运算符的一元（unary）形式（即只有一个操作数）。+运算符显式地将c转换为数字</strong>，而非数字加法运算（也不是字符串拼接）。<br>   <strong>日期显示转换为时间戳</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示将日期转换为时间戳</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(+d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript有一处奇特的语法，即构造函数没有参数时可以不用带()</span></span><br><span class="line"><span class="keyword">var</span> timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getTime显示获取可能更好些</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最好还是使用ES5中新增的Date.now()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br><span class="line"><span class="comment">// 为老版本提供polyfill</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Date</span>.now)&#123;</span><br><span class="line">    <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们不建议对日期类型使用强制类型转换，应该使用Date.now()来获得当前的时间戳，使用newDate(..).getTime()来获得指定时间的时间戳。</span></span><br></pre></td></tr></table></figure>

<p>   <strong>奇特的~运算符</strong></p>
<p>   ~运算符（即字位操作“非”）,它<strong>与某些特殊数字在一起使用时会产生类型强制类型转换的效果</strong>，返回另外一个数字, 它首先将值强制类型转换为32位数字，然后执行字位非（对每一个数字进行反转）</p>
<p>   还可以有另外一种诠释，源自早期的计算机科学和离散数学：<del>返回2的补码。这样一来问题就清楚多了！</del>x大致等同于-(x+1)。很奇怪，但相对更容易说明问题：</p>
<p>   <code>~42; // -(42 + 1) ==&gt; -43</code><br> 在-(x+1)中唯一能够得到0（或者严格说是-0）的x值是-1。也就是说如果x为-1时，~和一些数字值在一起会返回假值0，其他情况则返回真值。</p>
<p> -1是一个“<strong>哨位值</strong>”，哨位值是那些在各个类型中（这里是数字）被赋予了特殊含义的值。在C语言中我们用-1来代表函数执行失败，用大于等于0的值来代表函数执行成功。JavaScript中字符串的<strong>indexOf</strong>(..)方法也遵循这一惯例，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从0开始），否则返回-1。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello World"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(a.indexOf(<span class="string">"lo"</span>) &gt;= <span class="number">0</span> )&#123;  <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(a.indexOf(<span class="string">"lo"</span>) != <span class="number">-1</span> )&#123; <span class="comment">// true</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">if</span>(a.indexOf(<span class="string">"ol"</span>) &lt; <span class="number">0</span>)&#123;   <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"没有找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(a.indexOf(<span class="string">"ol"</span>) == <span class="number">-1</span>)&#123;  <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"没有找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// &gt;= 0和== -1这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，</span></span><br><span class="line">   <span class="comment">// 这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ~和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：</span></span><br><span class="line">   <span class="built_in">console</span>.log(~a.indexOf(<span class="string">"lo"</span>)); <span class="comment">// -4 真值</span></span><br><span class="line">   <span class="keyword">if</span>(~a.indexOf(<span class="string">"lo"</span>))&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(!~a.indexOf(<span class="string">"ol"</span>)); <span class="comment">// true</span></span><br><span class="line">   <span class="keyword">if</span>(!~a.indexOf(<span class="string">"ol"</span>))&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"未找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ~比&gt;= 0和== -1更简洁</span></span><br></pre></td></tr></table></figure>

<p>   <strong>字位截除</strong></p>
<p>   我们可以使用<code>~~1E20</code>或者<code>1E20 | 0</code> 两种方式来截取到Int32</p>
<p>   <strong>显示解析数字字符串</strong></p>
<p>   <strong>解析非字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">0.000008</span>)); <span class="comment">// "0"来自"0.000008"",  .不是数字，解析停止</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">0.0000008</span>));  <span class="comment">// 8  "8"来自8e-7</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="literal">false</span>, <span class="number">16</span>); <span class="comment">//250 "fa"来自于"false""</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>, <span class="number">16</span>); <span class="comment">//  15 "f"来自于"function""</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0x10"</span>)); <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"103"</span>, <span class="string">"2"</span>)); <span class="comment">// 2 3对于2进制转化超出有限值舍去</span></span><br></pre></td></tr></table></figure>

<p>   <strong>显示转换为布尔值</strong></p>
<p>与前面的String(..)和Number(..)一样，Boolean(..)（不带new）是显式的<strong>ToBoolean</strong>强制类型转换</p>
<p>一元运算符！显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值（或者将假值反转为真值）。所以<strong>显式强制类型转换为布尔值最常用的方法是！!</strong>，因为第二个！会将结果反转回原值</p>
</li>
<li><p><strong>隐式强制类型转换</strong><br><strong>字符串和数字之间的隐式强制类型转换</strong><br>通过重载，<strong>+运算符即能用于数字加法，也能用于字符串拼接</strong>。JavaScript怎样来判断我们要执行的是哪个操作？例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"42"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + b);</span><br><span class="line"><span class="built_in">console</span>.log(c + d);</span><br><span class="line"><span class="keyword">var</span> e = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> f = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//因为数组的valueOf()操作无法得到简单基本类型值，</span></span><br><span class="line"><span class="comment">// 于是它转而调用toString()。因此上例中的两个数组变成了"1,2"和"3,4"。+将它们拼接后返回"1,23,4"。</span></span><br><span class="line"><span class="built_in">console</span>.log(e+f);  <span class="comment">// 1,23,4</span></span><br><span class="line"><span class="comment">// 简单来说就是，如果+的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -是数字减法运算符，因此a -0会将a强制类型转换为数字。也可以使用a ＊ 1和a /1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。</span></span><br><span class="line"><span class="keyword">var</span> g = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> h = [<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(g-h);</span><br><span class="line"><span class="comment">// 为了执行减法运算，a和b都需要被转换为数字，它们首先被转换为字符串（通过toString()），然后再转换为数字。</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔值到数字的隐式强制类型转换</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyOne</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 跳过假值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>[i])&#123;</span><br><span class="line">            sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(onlyOne(b, a));</span><br></pre></td></tr></table></figure>

<p>通过sum += arguments[i]中的隐式强制类型转换，将真值（true/truthy）转换为1并进行累加。如果有且仅有一个参数为true，则结果为1；否则不等于1, sum == 1条件不成立。同样的功能也可以通过显式强制类型转换来实现<br><strong>隐式强制类型转换为布尔值</strong></p>
<p>下面的情况会发生布尔值隐式强制类型转换。</p>
<p>(1)  if (..)语句中的条件判断表达式。</p>
<p>(2) for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）。</p>
<p>(3) while (..)和do..while(..)循环中的条件判断表达式。</p>
<p>(4) ? ：中的条件判断表达式。</p>
<p>(5) 逻辑运算符||（逻辑或）和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>
<p><strong>||和&amp;&amp;</strong></p>
<p>称它们为“<strong>选择器运算符</strong>”（selector operators）或者“<strong>操作数选择器运算符</strong>”（operand selector operators）更恰当些。在JavaScript中它们返回的并不是布尔值。它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a || b); <span class="comment">// 42 </span></span><br><span class="line"><span class="built_in">console</span>.log(a &amp;&amp; b); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(c || b); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(c &amp;&amp; b); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换个角度来理解</span></span><br><span class="line"><span class="built_in">console</span>.log(a || b);</span><br><span class="line"><span class="built_in">console</span>.log(a?a:b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a&amp;&amp;b);</span><br><span class="line"><span class="built_in">console</span>.log(a?b:a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短路</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line">a &amp;&amp; foo();</span><br></pre></td></tr></table></figure>

<p>||和&amp;&amp;首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就<strong>先进行ToBoolean强制类型转换，然后再执行条件判断</strong>。</p>
<p>对于||来说，如果条件判断结果为true就返回第一个操作数（a和c）的值，如果为false就返回第二个操作数（b）的值。</p>
<p>&amp;&amp;则相反，如果条件判断结果为true就返回第二个操作数（b）的值，如果为false就返回第一个操作数（a和c）的值。</p>
<p>||和&amp;&amp;返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。c&amp;&amp; b中c为null，是一个假值，因此&amp;&amp;表达式的结果是null（即c的值），而非条件判断的结果false。<br><strong>符号的强制类型转换</strong></p>
<p>ES6中引入了符号类型，它的强制类型转换有一个坑，在这里有必要提一下。ES6允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"cool"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(s1));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"not cool"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2 + <span class="string">""</span>);  <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>

<p>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）</p>
</li>
<li><p><strong>宽松相等和严格相等</strong><br><strong>“==允许在相等比较中进行强制类型转换，而===不允许。”</strong><br><strong>相等比较操作的性能</strong><br>有人觉得==会比===慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。<br>如果进行比较的两个<strong>值类型相同，则==和===使用相同的算法</strong>，所以除了JavaScript引擎实现上的细微差别之外，它们之间并没有什么不同。<br><strong>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用==，没有就用===，不用在乎性能。</strong><br><strong>==和===都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同， ==会进行强制类型转换，而===不会。</strong><br>宽松不相等（loose not-equality）! =就是==的相反值，! ==同理<br><strong>1．字符串和数字之间的相等比较</strong>（将字符串转化为数字进行比较）<br>(1) 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。<br>(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。<br><strong>2．其他类型和布尔类型之间的相等比较</strong>（布尔值转化为数字进行比较）<br>(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果；<br>(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。<br><strong>3. null和undefined之间的相等比较</strong><br><strong>在==中null和undefined相等（它们也与其自身相等）</strong>，除此之外其他值都不存在这种情况。<br><strong>4．对象和非对象之间的相等比较</strong>（将对象转化为基本数据类型进行比较）<br>(1) 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果；<br>(2) 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x) == y的结果。<br><strong>5．安全运用隐式强制类型转换</strong><br>• 如果<strong>两边的值中有true或者false，千万不要使用==</strong>。<br>• 如果两边的值中有[]、””或者0，尽量不要使用==。完整比较图：</p>
<ul>
<li><p>红色：===</p>
</li>
<li><p>橙色：==</p>
</li>
<li><p>黄色：&lt;= 和 &gt;= 同时成立，== 不成立</p>
</li>
<li><p>蓝色：只有 &gt;=</p>
</li>
<li><p>绿色：只有 &lt;=</p>
<p><img src="https://img-blog.csdn.net/20180224085748686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2tpdGVfeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>抽象关系比较</strong><br>a &lt; b中涉及的隐式强制类型转换不太引人注意，不过还是很有必要深入了解一下。“抽象关系比较”（abstract relational comparison），分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。<strong>该算法仅针对a &lt; b, a=””&gt; b会被处理为b &lt; a</strong>比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">42</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">"43"</span>];</span><br><span class="line">a &lt; b <span class="comment">// true</span></span><br><span class="line">b &lt; a <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果<strong>比较双方都是字符串，则按字母顺序来进行比较</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"42"</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">"043"</span>];</span><br><span class="line">a &lt; b</span><br></pre></td></tr></table></figure>

<p>a和b并没有被转换为数字，因为ToPrimitive返回的是字符串，所以这里比较的是”42”和”043”两个字符串，它们分别以”4”和”0”开头。因为”0”在字母顺序上小于”4”，所以最后结果为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b</span><br><span class="line">结果还是<span class="literal">false</span>，因为a是[object <span class="built_in">Object</span>], b也是[object <span class="built_in">Object</span>](<span class="built_in">Object</span>.prototype.toString()获得[[Class]]属性值)，所以按照字母顺序a &lt; b并不成立。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="1-11-循环"><a href="#1-11-循环" class="headerlink" title="1.11 循环"></a>1.11 循环</h2><p>我们经常需要重复执行一些操作。</p>
<p>例如，我们需要将列表中的商品逐个输出，或者运行相同的代码将数字 1 到 10 逐个输出。</p>
<p><strong>循环</strong> 是一种重复运行同一代码的方法。</p>
<ul>
<li>for</li>
<li>forEach</li>
<li>do…while</li>
<li>while</li>
<li>for…in</li>
<li>for…of</li>
<li>for…in vs for…of</li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>您可以使用break中断for循环</li>
<li>您可以使用continue继续for循环的下一次迭代</li>
</ul>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>在ES5中引入。给定一个数组，您可以使用list.forEach（）迭代其属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//index is optional</span></span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过需要注意的是你无法摆脱这个循环。</p>
</blockquote>
<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; list.length)</span><br></pre></td></tr></table></figure>

<p>您可以使用break中断while循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>你可以使用continue跳转到下一个迭代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; list.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用break中断while循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用continue跳转到下一个迭代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do…while的区别在于do…while总是至少执行一次循环。</p>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p>迭代对象的所有可枚举属性，给出属性名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(property) <span class="comment">//property name</span></span><br><span class="line">  <span class="built_in">console</span>.log(object[property]) <span class="comment">//property value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>ES2015引入了for循环，它结合了forEach的简洁性和破解能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterate over the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the index as well, using `entries()`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用const。此循环在每次迭代中创建一个新范围，因此我们可以安全地使用它而不是let。</p>
<h3 id="for…in-VS-FOR…OF"><a href="#for…in-VS-FOR…OF" class="headerlink" title="for…in VS FOR…OF"></a>for…in VS FOR…OF</h3><p>与for…in的区别在于：</p>
<ul>
<li>for…of 迭代属性值</li>
<li>for…in 迭代属性名称</li>
</ul>
<h1 id="二-深入学习"><a href="#二-深入学习" class="headerlink" title="二. 深入学习"></a>二. 深入学习</h1><h2 id="2-1-作用域和闭包"><a href="#2-1-作用域和闭包" class="headerlink" title="2.1 作用域和闭包"></a>2.1 作用域和闭包</h2><h4 id="2-1-2-编译原理"><a href="#2-1-2-编译原理" class="headerlink" title="2.1.2 编译原理"></a>2.1.2 编译原理</h4><p>传统的编译语言中，程序中的一段源代码在执行之前会经历三个步骤，被称为”编译“</p>
<ol>
<li><strong>分词/词法分析（Tokenizing/Lexing）</strong><br>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</li>
<li><strong>解析/语法分析（Parsing）</strong><br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST）。var a = 2；的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。</li>
<li><strong>代码生成</strong><br><strong>将AST转换为可执行代码的过程被称为代码生成</strong>。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将var a = 2；的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。</li>
</ol>
<p>JavaScript引擎要复杂得多，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>
<h4 id="2-1-3-理解作用域"><a href="#2-1-3-理解作用域" class="headerlink" title="2.1.3 理解作用域"></a>2.1.3 理解作用域</h4><p><strong>重要概念</strong></p>
<ul>
<li>引擎从头到尾负责整个JavaScript程序的编译及执行过程。</li>
<li>编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活。</li>
<li>作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对<strong>这些标识符的访问权限</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>针对上述的代码语句，编译器将执行下述处理逻辑</p>
<ol>
<li>遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</li>
</ol>
<p><strong>引擎和作用域的对话</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。<br>引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？</p>
<ol>
<li><p>作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。</p>
</li>
<li><p>引擎：哥们太够意思了！好吧，我来执行一下foo。</p>
</li>
<li><p>引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？</p>
</li>
<li><p>作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。</p>
</li>
<li><p>引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。</p>
</li>
<li><p>引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？</p>
</li>
<li><p>作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console是个内置对象。给你。</p>
</li>
<li><p>引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。</p>
</li>
<li><p>引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。</p>
</li>
<li><p>作用域：放心吧，这个变量没有变动过，拿走，不谢。</p>
</li>
<li><p>引擎：真棒。我来把a的值，也就是2，传递进log(..)。</p>
</li>
</ol>
<p><strong>LHS和RHS</strong></p>
<p><code>LHS</code> 和 <code>RHS</code>是对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。<br> LHS(<code>Left-hand Side</code>)引用和RHS(<code>Right-hand Side</code>)引用。通常是指等号（赋值运算）的左右边的引用。</p>
<p><strong>RHS的目的是取得源值</strong></p>
<p><strong>LHS是取得源引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>LHS找到c</li>
<li>RHS寻找foo(2)的值</li>
<li>把2赋值给a时，LHS找到a</li>
<li>var b = a时候, LHS找到b, RHS找到a</li>
<li>return a + b时候，RHS找到a和b</li>
</ol>
<p>所以一共3次LHS，3次RHS</p>
<h4 id="2-1-4作用域嵌套"><a href="#2-1-4作用域嵌套" class="headerlink" title="2.1.4作用域嵌套"></a>2.1.4作用域嵌套</h4><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。</p>
<p>因此，回顾一下引擎和作用域之间的对话，会进一步听到：</p>
<ol>
<li>引擎：foo的作用域兄弟，你见过b吗？我需要对它进行RHS引用。</li>
<li>作用域：听都没听过，走开。</li>
<li>引擎：foo的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过b吗？我需要对它进行RHS引用。</li>
<li>作用域：当然了，给你吧。遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</li>
</ol>
<p><img src="/img/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9F%A5%E6%89%BE.jpg" alt="作用域查找.jpg"></p>
<p>这个建筑代表程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。LHS和RHS引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。</p>
<p><strong>为什么区分LHS和RHS</strong></p>
<p>因为在变量没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>第一次对b进行RHS查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得注意的是，ReferenceError是非常重要的异常类型。相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。“不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”</p>
<p>ES5中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<p><strong>总结</strong></p>
<p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。</p>
<p>如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<p>JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2这样的声明会被分解成两个独立的步骤：</p>
<ol>
<li>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>
<li>接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。</li>
</ol>
<h4 id="2-1-5-词法作用域"><a href="#2-1-5-词法作用域" class="headerlink" title="2.1.5 词法作用域"></a>2.1.5 词法作用域</h4><p>词法作用域就是定义在词法分析阶段的作用域</p>
<p>作用域查找会在找到第一个匹配的标识符时停止， 在多层的嵌套作用域中可以定义同名的标识符，这叫做”遮蔽效应“（内部的标识符遮蔽了外部的标识符）。</p>
<p>无论函数在哪里调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
<p>词法作用域只会查找一级标识符，比如a,   b,  c，类似于foo.bar.baz，词法作用域只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。</p>
<p><strong>注意</strong></p>
<p>通过eval和with可以做到欺骗词法，但是会导致性能大大降低，因此我们应该尽量避免使用eval和with</p>
<h4 id="2-1-6-函数作用域"><a href="#2-1-6-函数作用域" class="headerlink" title="2.1.6 函数作用域"></a>2.1.6 函数作用域</h4><p>属于这个函数的全部变量都可以在这个函数的范围内使用（在嵌套的作用域中也可以访问），这能够充分利用JavaScript变量可以根据需要动态改变值的特性。</p>
<p><strong>隐藏内部实现</strong></p>
<p>我们可以从缩写的代码中挑选出任意一个小片段，然后用函数声明对它进行包装，也就是说这段代码中涉及到的变量或者函数都将绑定在这个新创建的包装函数的作用域中。</p>
<blockquote>
<p>最小授权原则： 在软件设计中，应该最小限度地暴露必要的内容，而将其他内容都”隐藏“起来，比如某个某个模块或者对象的API的设计</p>
</blockquote>
<p><strong>规避冲突</strong></p>
<p>”隐藏“作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突，冲突会导致变量的值被恶意修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码因为变量冲突导致了死循环</p>
<p><strong>全局命名空间</strong></p>
<p>很多第三方库在全局作用域中声明一个名字足够独特的变量，通常是一个对象，这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addClass()&#123;&#125;,</span><br><span class="line">    removeClass()&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>模块管理</strong></p>
<p>另外一种避免全局冲突的方法是使用模块机制，如Seajs, require.js,commonjs等，这写工具并没有违反词法作用域规则，而是强制所有标识符都不能注入到共享作用域中，而是保持在私有的，无冲突的作用中。</p>
<h4 id="2-1-7-函数声明，函数表达式，匿名函数"><a href="#2-1-7-函数声明，函数表达式，匿名函数" class="headerlink" title="2.1.7 函数声明，函数表达式，匿名函数"></a>2.1.7 函数声明，函数表达式，匿名函数</h4><p>区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是第一行代码， 而是整个声明中的位置），如果function是声明中的第一个词，则为函数声明，否则就是一个函数表达式。</p>
<p>如以下两段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">2</span> ;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>第1段代码必须显示声明函数foo并显示调用，污染了所在的作用域</p>
<p>第2段代码为一个函数表达式，并使用匿名函数免除了对所在作用域的污染</p>
<p><strong>回调函数中的匿名函数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I wanted 1 second!!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用setTimeout的回调函数使用了匿名函数表达式</p>
<p>匿名函数表达式写起来非常简单快捷，但是同时也存在几个缺点：</p>
<ol>
<li>在追踪堆栈中不会显示出有意义的函数名，使得调试困难。</li>
<li>如果没有函数名，就只能通过过时的arguments.callee引用自身</li>
<li>函数名对于代码的可读性、可理解性很重要</li>
</ol>
<p><strong>始终给函数表达式添加函数名是最佳实践</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I wanted 1 second!!!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-立即执行函数-IIFE-Immediately-invoked-Function-Expression"><a href="#2-1-8-立即执行函数-IIFE-Immediately-invoked-Function-Expression" class="headerlink" title="2.1.8 立即执行函数(IIFE, Immediately invoked Function Expression)"></a>2.1.8 立即执行函数(IIFE, Immediately invoked Function Expression)</h4><p>由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如(function foo(){ .. })()。第一个()将函数变成表达式，第二个()执行了这个函数。</p>
<p><strong>IIFE传递参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(global.a);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>我们将window对象的引用传递进去，但将参数命名为global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。</p>
<p><strong>IIFE运行顺序的倒置，UMD代码封装用到</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">def</span>)</span>&#123;</span><br><span class="line">  def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(global.a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-9-块作用域"><a href="#2-1-9-块作用域" class="headerlink" title="2.1.9 块作用域"></a>2.1.9 块作用域</h4><p>下述两段代码暴露了一些问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">   <span class="keyword">var</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">   bar = something(bar);</span><br><span class="line">   <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环的循环变量会暴露到外部作用域，而不是只被限制在了for循环的范围内</p>
<p>而if内的变量声明也会暴露到外部作用域中</p>
<p>因此我们需要块作用域的存在</p>
<p><strong>with</strong></p>
<p>with的使用会创建出一个块级作用域</p>
<p><strong>try/catch</strong></p>
<p>非常少有人会注意到JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效</p>
<p><strong>let</strong></p>
<p>到目前为止，我们知道JavaScript在暴露块作用域的功能中有一些奇怪的行为。如果仅仅是这样，那么JavaScript开发者多年来也就不会将块作用域当作非常有用的机制来使用了。</p>
<p>幸好，ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。</p>
<p><strong>const</strong></p>
<p>除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。</p>
<h4 id="2-1-10-提升"><a href="#2-1-10-提升" class="headerlink" title="2.1.10 提升"></a>2.1.10 提升</h4><p>提升只会发生在函数声明和变量声明，函数表达式不会发生提升 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo());   </span><br><span class="line"><span class="built_in">console</span>.log(foo1());   <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(str);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello foo1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"hello str"</span>;</span><br></pre></td></tr></table></figure>

<p>在提升过程中，函数声明比变量声明优先级高</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码发生提升后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h4 id="2-1-11-作用域和闭包"><a href="#2-1-11-作用域和闭包" class="headerlink" title="2.1.11 作用域和闭包"></a>2.1.11 作用域和闭包</h4><p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取<a href="https://baike.baidu.com/item/局部变量/9844788" target="_blank" rel="noopener">局部变量</a>，所以闭包可以理解成“定义在一个<a href="https://baike.baidu.com/item/函数/301912" target="_blank" rel="noopener">函数</a>内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印5个5，因为5个匿名函数使用的i都为全局作用域的i,而setTimeout的回调函数会在for循环执行完成之后执行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常打印0,1,2,3,4,5，使用IIFE创建新的作用域，每个匿名函数产生闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常打印0,1,2,3,4,5, 使用let创建块级作用域，只在for循环内才能访问到i</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonUtils = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">"common utils"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printStr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        printStr: printStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">CommonUtils.printStr();</span><br></pre></td></tr></table></figure>

<p>IIFE匿名函数内部return回模块的公共API， 内部函数引用了外部作用域的变量，这样便构成了一个模块</p>
<p><strong>现代的模块机制</strong></p>
<p>一个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Modules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++)&#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Modules.define("bar", [], function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Modules.define(<span class="string">"foo"</span>, [<span class="string">"bar"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = Modules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo = Modules.get(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.hello(<span class="string">"hippo"</span>));</span><br><span class="line">foo.awesome();</span><br></pre></td></tr></table></figure>

<h2 id="2-2-this"><a href="#2-2-this" class="headerlink" title="2.2 this"></a>2.2 this</h2><p>当一个函数被调用的时候，引擎会创建执行上下文，用来记录函数在哪里被调用（调用栈），函数的调用方式，传入的参数信息，this就是这些记录的一个属性。this是在调用时候被绑定的，完全取决于函数的调用位置。</p>
<p>我们分析一下下述代码中的调用栈</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为: baz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"baz"</span>); </span><br><span class="line">    bar();  <span class="comment">// &lt;-- bar 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为baz -&gt; bar</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo 的代用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>

<p>我们可以把调用栈想象为一个函数调用链，我们也可以在每个函数内添加断点利用浏览器的开发者恐惧来得到调用栈。</p>
<h3 id="2-2-1-this的绑定规则"><a href="#2-2-1-this的绑定规则" class="headerlink" title="2.2.1 this的绑定规则"></a>2.2.1 this的绑定规则</h3><ul>
<li><p>默认绑定<br>函数直接调用，即不通过点操作符进行调用，非严格模式下,this指向window, 严格模式下为undefined</p>
</li>
<li><p>隐式绑定<br>调用位置如果被某个对象拥有或者包含</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>上述代码foo函数被调用时候调用位置会使用obj上下文来引用函数，因此我们可以说函数被调用时，obj对象拥有或者包含它<br>对象属性引用链可能包含多级属性引用，调用位置会把最后一层作为上下文来引用函数</p>
<p>如<code>obj1.obj2.foo()</code>会使用obj2作为foo函数调用时候的是上下文。<br><strong>隐式丢失</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span>;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>上述代码中，虽然bar是obj.foo的一个引用，它引用的是foo函数本身，因此此时bar()其实是一个函数的直接调用，因此会采用默认绑定规则。</p>
<p><strong>回调函数中也会发生隐式赋值，fn也只是引用foo函数本身，因此执行时候也是等同于函数的直接低啊用，会采用默认绑定规则</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a  = <span class="string">"oops, global"</span>;</span><br><span class="line">doFoo(obj.foo);</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示绑定(使用call和apply)<br>从this的绑定角度上来说，call和apply是一样的，二者不同点体现在其他参数上</p>
<ul>
<li><p>硬绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可以复用的辅助函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = bind(foo, obj);</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<p>我们也可以使用ES5提供的内置的方法Function.prototype.bind</p>
</li>
</ul>
</li>
<li><p>new绑定<br>在JavaScript中，构造函数只是一些使用new操作符调用的普通函数， 其实并不存在构造函数的调用，而是对于函数的”<strong>构造调用</strong>“<br>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行<strong>[[Prototype]]</strong>连接</li>
<li>这个新对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li>
</ol>
</li>
</ul>
<h3 id="2-2-2-this绑定规则的优先级"><a href="#2-2-2-this绑定规则的优先级" class="headerlink" title="2.2.2 this绑定规则的优先级"></a>2.2.2 this绑定规则的优先级</h3><p><strong>显示绑定优先级高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo();</span><br><span class="line">obj2.foo();</span><br><span class="line">obj1.foo.call(obj2);</span><br><span class="line">obj2.foo.call(obj1);</span><br></pre></td></tr></table></figure>

<p><strong>new绑定优先级高于隐式绑定优先级</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">obj1.foo(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log(obj1.a);   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示绑定</span></span><br><span class="line">obj1.foo.call(obj2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 绑定</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">/// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>new绑定和显示绑定的比较</strong></p>
<p>New不能和call,apply一起使用，我们使用硬绑定来测试它们的优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a  = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将foo函数的this应绑定到this上面</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>new bar(3)并没有像我们预计的那样把obj1.a修改为3,而是修改了硬绑定（到obj1）调用bar中的this,创建了一个新的对象</p>
<p><strong>判断this</strong></p>
<ol>
<li>函数是否使用new调用，如果是的话this绑定的是新创建的对象</li>
<li>函数是否通过call, apply显示绑定或者通过bind函数硬绑定调用，如果是的话，this绑定的是指定的对象</li>
<li>函数是否在某个上下文调用(隐式绑定),如果是的话，this绑定的是那个上下文对象</li>
<li>如果都不是的话，使用默认绑定，如果在严格模式下， 就绑定到undefined,否则绑定到全局对象。</li>
</ol>
<p><strong>绑定中的一些特殊情况</strong></p>
<ul>
<li><p>把null,undefined作为绑定的对象传入call,apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则（比如在进行函数柯里化或者this指向不重要的时候）</p>
<p>然而，总是使用null来忽略this绑定可能产生一些副作用，如果某个函数确实使用了this,那默认绑定规则会把this绑定到全局对象（在浏览器中这个对象是window），这将导致不可预计的结果（比如修改全局对象）</p>
</li>
<li><p>更安全的this<br>我们使用一个空的委托对象(或者叫非军事区对象DMZ: demilitarized zone)来表达我们希望this为空的意图</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a: "</span> + a + <span class="string">",b: "</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">foo.apply(ø, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(ø, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>软绑定</strong></p>
<p>硬绑定可以把this强制绑定到指定的对象(除了使用new时)，防止函数调用应用默认绑定规则，但是硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this的指向了。</p>
<p>如果可以给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</p>
<p>可以使用一种称为软绑定的方法来实现我们想要的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(! <span class="built_in">Function</span>.prototype.softBind )&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global))? obj : <span class="keyword">this</span>,</span><br><span class="line">                curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</span><br><span class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind(obj);</span><br><span class="line">fooOBJ();   <span class="comment">// name: obj</span></span><br><span class="line">fooOBJ.call(obj2)  <span class="comment">// name: obj2</span></span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo();    <span class="comment">// name: obj2</span></span><br><span class="line"></span><br><span class="line">setTimeout(obj2.foo, <span class="number">10</span>);  <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-箭头函数的this绑定规则"><a href="#2-2-3-箭头函数的this绑定规则" class="headerlink" title="2.2.3 箭头函数的this绑定规则"></a>2.2.3 箭头函数的this绑定规则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2);</span><br></pre></td></tr></table></figure>

<p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1,bar(引用箭头函数)的this也会绑定到obj1， 箭头函数的绑定无法被修改。(new也不行)</p>
<p>回调函数中使用箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo1.call(obj);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-对象"><a href="#2-3-对象" class="headerlink" title="2.3 对象"></a>2.3 对象</h2><p>对象的两种定义方式:</p>
<ul>
<li>使用对象字面量{}</li>
<li>使用构造函数Object</li>
</ul>
<h3 id="2-3-1-类型"><a href="#2-3-1-类型" class="headerlink" title="2.3.1 类型"></a>2.3.1 <strong>类型</strong></h3><p>JS包括六种主要类型</p>
<p>string, number, boolean, null, undefined, object</p>
<p><strong>内置对象</strong></p>
<p>内置对象表现形式像其他语言中的type或者class，但是在JS中，它们实际上只是一些内置函数，它们可以当做构造函数(使用new来调用)， 从而构造一个对应子类型的新对象。</p>
<h3 id="2-3-2-对象属性"><a href="#2-3-2-对象属性" class="headerlink" title="2.3.2 对象属性"></a>2.3.2 <strong>对象属性</strong></h3><p>对象的内容由一些存储在特定命名位置（任意类型）值组成，它们就是对象的属性，表现形式上属性好像存储在对象内部，但是在引擎内部这些值的存储方式是多种多样的，一般不会存在对象容器内，存储在对象容器内部的是这些属性的名称，它们就像指针（引用），指向这些值的真正的存储位置。</p>
<p><strong>属性的访问方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObj.a    <span class="comment">// 属性访问</span></span><br><span class="line">myObj[<span class="string">'a'</span>]  <span class="comment">// 键访问</span></span><br></pre></td></tr></table></figure>

<p>ES6新增了可计算属性名</p>
<p><code>myObj: { [prefix + &#39;bar&#39;]: &quot;hello&quot;}</code></p>
<p><strong>数组</strong></p>
<p>数组可以只用数组字面量[]或者Array构造函数来声明</p>
<p><code>var arr = [] or var arr = new Array()</code></p>
<p>数组元素类型没有限制，如果试图向数组添加一个属性，但是属性名看起来像一个数字，那它会作为下标</p>
<p><code>var arr[&#39;0&#39;] =  &#39;hello&#39;</code></p>
<h3 id="2-3-3-对象复制"><a href="#2-3-3-对象复制" class="headerlink" title="2.3.3 对象复制"></a>2.3.3 <strong>对象复制</strong></h3><p><strong>对于JSON安全</strong> (可以被序列化一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象来说，可以使用</p>
<p><code>var obj1 = JSON.parse(JSON.stringify(obj));</code></p>
<p><strong>ES6提供了Object.assign实现浅复制</strong></p>
<p><code>Object.assign({}, obj)</code></p>
<h3 id="2-3-4-属性描述符"><a href="#2-3-4-属性描述符" class="headerlink" title="2.3.4 属性描述符"></a>2.3.4 属性描述符</h3><p>ES5提供了属性描述符来描述属性的特性（<strong>值value</strong>, <strong>可写writable</strong>, <strong>可枚举enumerable(决定属性是否能被for..in循环和Object.keys()遍历到)</strong>, <strong>可配置configurable</strong>）</p>
<p>我们可以使用<strong>Object.defineProperty()</strong>来定义属性或者修改属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>configurable属性代表可配置性</p>
<p>值为false的话，不可以使用delete进行属性删除， 可以把writable由true改为false, 不能由false改为true</p>
<p><strong>对象常量</strong></p>
<p>结合writable: false和configurable: false就可以创建一个真正的属性常量(不可修改，重定义或者删除)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"FAVORITE NUMBER"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>禁止扩展</strong></p>
<p>禁止一个对象添加新属性并且保留已有属性，可以使用<strong>Object.preventExtensions()</strong></p>
<p>在严格模式下会抛出TypeError， 非严格模式下静默失败</p>
<p><strong>密封</strong></p>
<p>在Object.preventExtensions()的基础上把现有所有属性设置为configurable: false可以使用 <strong>Object.seal()</strong> </p>
<p>密封后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（可以修改属性的值）</p>
<p><strong>冻结</strong></p>
<p><strong>Object.freeze()</strong>   在密封基础上把现有所有属性设置为writable: false</p>
<p>禁止对于对象本身及其任意直接属性的修改（不过，这个对象引用的其他对象是不受影响的）， 如果要实现</p>
<p><strong>深度冻结</strong>则需要遍历调用Object.freeze()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objDeepFreeze = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"被冻结对象不能为空"</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"被冻结目标必须是对象"</span>);</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = obj[key];</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> value === <span class="string">'object'</span> )&#123;</span><br><span class="line">       dhelper.objDeepFreeze(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-setter和getter"><a href="#2-3-5-setter和getter" class="headerlink" title="2.3.5 setter和getter"></a>2.3.5 <strong>setter和getter</strong></h3><p>1.通过对象初始化器在创建对象的时候指明（也可以称为通过字面值创建对象时声明）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    a : <span class="number">7</span>,</span><br><span class="line">    <span class="keyword">get</span> b()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a +<span class="number">1</span>;&#125;,<span class="comment">//通过 get,set的 b,c方法间接性修改 a 属性</span></span><br><span class="line">    <span class="keyword">set</span> c(x)&#123;<span class="keyword">this</span>.a = x/<span class="number">2</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">  o.c = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>2.使用 Object.create 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="literal">null</span>;</span><br><span class="line">  o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,<span class="comment">//指定原型为 Object.prototype</span></span><br><span class="line">      &#123;</span><br><span class="line">        bar:&#123;</span><br><span class="line">          <span class="keyword">get</span> :function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">set</span> : function (val) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Setting `o.a` to "</span>,val);</span><br><span class="line">            <span class="keyword">this</span>.a = val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">//第二个参数</span></span><br><span class="line">    );</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">  o.a = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>Object.prototype也可以替换成想要继承的原型对象，如<code>var o = {a: 10};</code></p>
<p>3.使用 Object.defineProperty 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123; <span class="attr">a</span> : <span class="number">1</span>&#125;<span class="comment">//声明一个对象,包含一个 a 属性,值为1</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o,<span class="string">"b"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> : function (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.a = val;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">  o.b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>4.使用 Object.defineProperties方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="string">"string"</span>&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(obj,&#123;</span><br><span class="line">    <span class="string">"A"</span>:&#123;</span><br><span class="line">      <span class="keyword">get</span>:function()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a+<span class="number">1</span>;&#125;,</span><br><span class="line">      <span class="keyword">set</span>:function(val)&#123;<span class="keyword">this</span>.a = val;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"B"</span>:&#123;</span><br><span class="line">      <span class="keyword">get</span>:function()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.b+<span class="number">2</span>;&#125;,</span><br><span class="line">      <span class="keyword">set</span>:function(val)&#123;<span class="keyword">this</span>.b = val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(obj.A);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.B);</span><br><span class="line">  obj.A = <span class="number">3</span>;</span><br><span class="line">  obj.B = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.A);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.B);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>5.使用 Object.prototype.<strong>defineGetter</strong> 以及 Object.prototype.<strong>defineSetter</strong> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">  o.__defineGetter__(<span class="string">"giveMeA"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;);</span><br><span class="line">  o.__defineSetter__(<span class="string">"setMeNew"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = val;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(o.giveMeA);</span><br><span class="line">  o.setMeNew = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.giveMeA);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="2-3-6-使用in-或者-hasOwnProperty判断属性存在性"><a href="#2-3-6-使用in-或者-hasOwnProperty判断属性存在性" class="headerlink" title="2.3.6 使用in 或者 hasOwnProperty判断属性存在性"></a>2.3.6 使用in 或者 hasOwnProperty判断属性存在性</h3><p>属性返回值可能为undefined，但是这个undefined可能是属性中存储的undefined也可能是因为属性不存在所以返回undefined，可以使用hasOwnProperty函数来区分这两种情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span> <span class="keyword">in</span> myObj);</span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure>

<p>如果通过Object.create(null)来创建对象，原型没有连接到Object.prototype，这种情况下可以使用更强硬的方法来进行判断:</p>
<p><code>Object.prototype.hasOwnProperty.call(myObj, &#39;a&#39;);</code></p>
<p>它借用了基础的hasOwnProperty()方法并把它显示绑定到myObj上</p>
<p><strong>注意</strong></p>
<p>in操作符是判断某个属性名是否存在，对于数组[2,4,6], 属性名为0,1,2，因此<code>4 in [2,4,6]</code>会得到false值</p>
<p><strong>一些常用的属性操作函数</strong></p>
<ul>
<li>obj.propertyIsEnumable()检查给定属性是否可枚举</li>
<li>Object.keys()会返回一个数组，包含所有可枚举属性</li>
<li>Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论他们是否可以枚举</li>
<li>Object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性，不会查找原型链[[Prototype]]</li>
<li>in和hasOwnProperty的区别在于是否查找原型链， in会查找原型链， hasOwnProperty不会查找原型链</li>
<li>目前没有内置方法获取in操作符使用的属性列表（对象本身的属性及原型链中的属性），我们可以递归某个对象的整条原型链并保存每一层中使用Object.keys()得到的属性列表—只包含可枚举属性。</li>
</ul>
<h3 id="2-3-7-对象的遍历"><a href="#2-3-7-对象的遍历" class="headerlink" title="2.3.7 对象的遍历"></a>2.3.7 对象的遍历</h3><ul>
<li>for..in循环可以用来遍历对象的可枚举属性列表（包括[[Prototype]]链）</li>
<li>对于数值索引的数组来说，可以使用标准的for循环来遍历值：</li>
<li>ES5中增加了一些数组的辅助迭代器，包括<strong>forEach(..)</strong>、<strong>every(..)</strong>和<strong>some(..)</strong>。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。forEach(..)会遍历数组中的所有值并忽略回调函数的返回值。every(..)会一直运行直到回调函数返回false（或者“假”值）, some(..)会一直运行直到回调函数返回true（或者“真”值）。every(..)和some(..)中特殊的返回值和普通for循环中的break语句类似，它们会提前终止遍历</li>
<li>遍历数组下标时候采用的数字顺序，但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样，因此，在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们是不可靠的。</li>
<li>ES6增加了一种用来遍历数组的for..of循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</li>
</ul>
<h2 id="2-4-类-继承-混入"><a href="#2-4-类-继承-混入" class="headerlink" title="2.4 类, 继承, 混入"></a>2.4 类, 继承, 混入</h2><p>类不是JS必须的编程基础，而是一种可选的代码抽象。JS实际上并没有类，类只是一种设计模式，我们可以使用一些方法来实现近似类的功能，为了满足对于类设计模式的最普遍的需求，JavaScript提供了一些近似类的语法。</p>
<h3 id="2-4-1-类的机制"><a href="#2-4-1-类的机制" class="headerlink" title="2.4.1 类的机制"></a>2.4.1 类的机制</h3><p><strong>类和实例</strong></p>
<p>一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有的数据属性。这个对象就是类中描述的所有特性的一份副本。</p>
<p><strong>构造函数</strong></p>
<p>类的实例由一个特殊的类方法构造，这个方法名通常和类名相同，被称为构造函数，这个方法的任务就是初始化实例需要的所有信息（状态）</p>
<h3 id="2-4-2-类的继承"><a href="#2-4-2-类的继承" class="headerlink" title="2.4.2 类的继承"></a><strong>2.4.2 类的继承</strong></h3><p>JS中 类的声明有两种形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES6中的class声明</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而实例化类，就是一个简单的 new 就完了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(), <span class="keyword">new</span> Animal2());</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1797988/201912/1797988-20191215155708186-785877660.jpg" alt=""></p>
<ol>
<li><p><strong>原型链继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将原型对象赋值为另一个类型的实例，原型对象将包含一个指向另一个原型的指针</span></span><br><span class="line"><span class="comment"> * 构成实例与原型的链条</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象赋值为父类的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child().__proto__.__proto__.constructor);  <span class="comment">// Function Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象是共用的</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child();</span><br><span class="line">s1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.arr, s2.arr);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>通过原型链实现继承时候，不能使用对象字面量创建原型方法，因为这样会重写原型链<br>这种继承方式会实现为各个实例共享原型对象， 且在创建子类型的时候不能向超类型的构造函数中传递参数。</p>
</li>
<li><p><strong>构造函数方式继承</strong><br>用子类型的构造函数内部调用要继承的父类的构造函数，构造函数去继承构造函数，不存在共享和无法传递参数的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    <span class="comment">// 调用超类的构造函数，构造函数继承了构造函数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child();</span><br><span class="line">s1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.arr, s2.arr);</span><br><span class="line"><span class="comment">// TypeError: s1.sayName is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.sayName());</span><br></pre></td></tr></table></figure>

<p>最大优势是可以在调用超累的构造函数时候传递参数<br>问题是：无法继承原型中的方法和属性， 且因为使用构造函数来实现，创建每个实例时候，超类的方法和属性都要在每个实例上重新创建一遍，性能损耗严重。</p>
</li>
<li><p><strong>组合继承</strong><br>将原型链继承和构造函数继承相结合进行使用，原型链继承来实现对原型链上方法和属性的继承（实现属性和方法的共用），构造函数继承实现对实例属性的继承（实现私有的实例化），这样既实现了原型上方法和属性的复用，又能够保证每个实例有自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    <span class="comment">// 构造函数继承， 第一次调用Person()</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承，第二次调用Person()</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor); <span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); <span class="comment">// [Function: Person]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复constructor的指向,否则无法继承后无法区分p和c的具体类型</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor);  <span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor);  <span class="comment">// [Function: Child]</span></span><br></pre></td></tr></table></figure>

<p>这种方式的最大问题是要调用两次超类的构造函数</p>
<p><strong>组合继承的优化</strong><br>优化步骤1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对两次调用超类构造函数的问题优化版本1</span></span><br><span class="line"><span class="comment"> * 修改原型链继承方式，作为继承超类原型来用，</span></span><br><span class="line"><span class="comment"> * 完善借用构造函数继承无法继承到超类原型的缺点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类的原型指向了超类的原型</span></span><br><span class="line">Child.prototype = Person.prototype;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">// 无法区分s的具体类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Child, s <span class="keyword">instanceof</span> Person); <span class="comment">// true, true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: Person]</span></span><br></pre></td></tr></table></figure>

<p>优化步骤2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对两次调用超类构造函数的问题优化版本2</span></span><br><span class="line"><span class="comment"> * 修改子类的constructor指向</span></span><br><span class="line"><span class="comment"> * 利用Object.create() 去 创建中间对象从而将子类和超类区分开；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Object.create来作为中间链，将子类和超类区分开，且保持正确的链接</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"><span class="comment">// 修复constructor指向</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Child, s <span class="keyword">instanceof</span> Person); <span class="comment">// true, true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: Person]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于Object.create()函数的原型继承</strong><br>Object.create函数规范化了原型继承，这个函数接收两个参数，第一个参数为原型对象，第二个参数为为新对象定义的额外属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelly"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">"person1 name"</span>;</span><br><span class="line">person1.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">"person2 name"</span>;</span><br><span class="line">person2.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);</span><br></pre></td></tr></table></figure>

<p>Object.create中继承的参数的内容并不是直接放到子类中,而是存在与子类的原型中; 所以会出现覆盖(实例属性覆盖继承的原型属性)和共享属性的特征（如上例中的person.friends）</p>
</li>
<li><p><strong>寄生式继承</strong><br>与原型式继承紧密相关的一种思路,即创建一个用于封装过程的函数，该函数在内部以某种方式增强对象，最后就像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone  = <span class="built_in">Object</span>.create(origin);</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    friends: [<span class="string">"Sheldy"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"tom"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure>

<p>使用寄生继承来为对象添加函数，不能做到函数复用而降低性能，这一点与构造函数继承类似</p>
</li>
<li><p><strong>寄生组合继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subtype, supertype</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 以超类的原型对象为参数创建新对象，新对象的原型链接到超类的原型</span></span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Object</span>.create(supertype.prototype);</span><br><span class="line">    <span class="comment">// 中间对象的构造函数指定为子类的构造函数</span></span><br><span class="line">    middle.constructor = subtype;</span><br><span class="line">    <span class="comment">// 指定middle为子类的原型对象</span></span><br><span class="line">    subtype.prototype = middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数，完成实例属性的继承</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需先完成原型继承(这一步从父类原型链上继承来所有方法和属性)，然后再扩展子类的原型，否则会覆盖掉在SubType.prototype上面定义的方法</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">instance1.sayName();</span><br><span class="line">instance1.sayAge();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">instance2.sayName();</span><br><span class="line">instance2.sayAge();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 class使用extends完成继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Polygon"</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I am a "</span>, <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Square"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.area = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mySquare = <span class="keyword">new</span> Square(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mySquare);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-5-原型和原型链"><a href="#2-5-原型和原型链" class="headerlink" title="2.5 原型和原型链"></a>2.5 原型和原型链</h2><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。</p>
<p>当你通过各种语法进行属性查找时都会查找[[Prototype]]链，直到找到属性或者查找完整条原型链。</p>
<p><strong>但是到哪里是[[Prototype]]的“尽头”呢？</strong></p>
<p>所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把[[Prototype]]链的顶端设置为）这个Object.prototype对象，所以它包含JavaScript中许多通用的功能。</p>
<h3 id="一、prototype"><a href="#一、prototype" class="headerlink" title="一、prototype"></a>一、prototype</h3><p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age       </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'kavin'</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">//kavin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)  <span class="comment">//kavin</span></span><br></pre></td></tr></table></figure>

<p>上述例子中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。</p>
<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151024134-512558007.png" alt="img"></p>
<h3 id="二、proto"><a href="#二、proto" class="headerlink" title="二、proto"></a>二、<strong>proto</strong></h3><p>这是每个对象(除null外)都会有的属性，叫做<strong>proto</strong>，这个属性会指向该对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>而关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img"></p>
<p>补充说明：</p>
<p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h3><p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person===Person.prototype.constructor)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>所以再更新下关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151615691-1017611190.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h3 id="四、实例与原型"><a href="#四、实例与原型" class="headerlink" title="四、实例与原型"></a>四、实例与原型</h3><p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'Daisy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h3 id="五、原型的原型"><a href="#五、原型的原型" class="headerlink" title="五、原型的原型"></a>五、原型的原型</h3><p> 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708152327825-11086376.png" alt="img"></p>
<h3 id="六、原型链"><a href="#六、原型链" class="headerlink" title="六、原型链"></a>六、原型链</h3><p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>
<p>其实简单来说，就是上述四-五的过程。</p>
<p>继上述五中所说，那 Object.prototype 的原型呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png" alt="img"></p>
<p>图中由相互关联的原型组成的链状结构就是<strong>原型链</strong>，也就是蓝色的这条线。</p>
<h3 id="七-属性的设置和屏蔽"><a href="#七-属性的设置和屏蔽" class="headerlink" title="七. 属性的设置和屏蔽"></a>七. <strong>属性的设置和屏蔽</strong></h3><p>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性。</p>
<p><code>myObject.foo = &quot;bar&quot;</code></p>
<ul>
<li><p>如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
</li>
<li><p>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作。如果原型链上找不到foo, foo就会被直接添加到myObject上。然而，如果foo存在于原型链上层，赋值语句myObject.foo = “bar”的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍</p>
</li>
<li><p>如果属性名foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性。屏蔽比我们想象中更加复杂。下面我们分析一下如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = “bar”会出现的三种情况。</p>
<ol>
<li><p>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    value: <span class="string">"person"</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;  <span class="comment">// TypeError: Cannot assign to read only property 'type' of object '#&lt;Student&gt;'</span></span><br><span class="line"><span class="built_in">console</span>.log(s.type); <span class="comment">// student</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    value: <span class="string">"person"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;  <span class="comment">// TypeError: Cannot assign to read only property 'type' of object '#&lt;Student&gt;'</span></span><br><span class="line"><span class="built_in">console</span>.log(s.type);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>._type = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._type</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setter: "</span> + val);</span><br><span class="line">        <span class="keyword">this</span>._type = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.type);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="2-6-行为委托"><a href="#2-6-行为委托" class="headerlink" title="2.6 行为委托"></a>2.6 行为委托</h2><p>  下面是一个行为委托的小例子</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> Task = &#123;</span><br><span class="line">      setId: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.id = ID;</span><br><span class="line">      &#125;,</span><br><span class="line">      outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.id)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将XYZ对象委托给Task</span></span><br><span class="line">  <span class="keyword">var</span> XYZ = <span class="built_in">Object</span>.create(Task);</span><br><span class="line">  XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID, Label</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setId(ID);</span><br><span class="line">      <span class="keyword">this</span>.label = Label;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.outputID();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.label);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  XYZ.prepareTask(<span class="number">11</span>, <span class="string">"javascript"</span>);</span><br><span class="line">  XYZ.outputTaskDetails();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ABC = Object.create(Task);</span></span><br><span class="line"><span class="comment">// ABC ...</span></span><br></pre></td></tr></table></figure>

<p>  在这段代码中，Task和XYZ并不是类（或者函数），它们是对象。XYZ通过Object. create(..)创建，它的[[Prototype]]委托了Task对象（参见第5章）。</p>
<p>  相比于面向类（或者说面向对象），这种编码风格称为“对象关联”（OLOO, objectslinked to other objects）。我们真正关心的只是XYZ对象（和ABC对象）委托了Task对象。</p>
<p>  <strong>对象关联风格的代码还有一些不同之处</strong></p>
<ol>
<li><p>在上面的代码中，id和label数据成员都是直接存储在XYZ上（而不是Task）。通常来说，在[[Prototype]]委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。</p>
<ol start="2">
<li>在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有outputTask方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义（参见第4章）。这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。</li>
</ol>
</li>
<li><p>this.setID(ID); XYZ中的方法首先会寻找XYZ自身是否有setID(..)，但是XYZ中并没有这个方法名，因此会通过[[Prototype]]委托关联到Task继续寻找，这时就可以找到setID(..)方法。此外，由于调用位置触发了this的隐式绑定规则（参见第2章），因此虽然setID(..)方法在Task中，运行时this仍然会绑定到XYZ，这正是我们想要的。在之后的代码中我们还会看到this.outputID()，原理相同。换句话说，我们和XYZ进行交互时可以使用Task中的通用方法，因为XYZ委托了Task。委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。</p>
<p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p>
</li>
</ol>
<p>下面再看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>, who);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identity() + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>上面的代码是典型的类设计模式的实现代码，下面用行为委托来进行改写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用行为委托来进行改写</span></span><br><span class="line"><span class="keyword">var</span> Foo = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = who;</span><br><span class="line">    &#125;,</span><br><span class="line">    identity: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Bar = <span class="built_in">Object</span>.create(Foo);</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identity() + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b1.init(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b2.init(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p><strong>一个登陆控制的例子</strong><br>类设计模式写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors = [];</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.showDialog = <span class="function"><span class="keyword">function</span>(<span class="params">title, msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(title + msg);</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.success = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Success"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.failure = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.push(err);</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Error"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Controller.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype = <span class="built_in">Object</span>.create(Controller.prototype);</span><br><span class="line">LoginController.prototype.constructor = LoginController;</span><br><span class="line">LoginController.prototype.getUser = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype.getPassword = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).value;</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype.validateEntry = <span class="function"><span class="keyword">function</span>(<span class="params">user, pw</span>)</span>&#123;</span><br><span class="line">    user  = user || <span class="keyword">this</span>.getUser();</span><br><span class="line">    pw = pw || <span class="keyword">this</span>.getPassword();</span><br><span class="line">    <span class="keyword">if</span>(!(user &amp;&amp; pw))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Please enter a username &amp; password!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pw.length &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Password must be 5+ characters!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.success(<span class="string">"login success!!!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LoginController.prototype.failure = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    Controller.prototype.failure.call(<span class="keyword">this</span>, <span class="string">"Login invalid: "</span> + err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./登陆控制(类设计模式写法).js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">onsubmit</span>=<span class="string">"return onSubmit()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="function"><span class="keyword">function</span> <span class="title">onSubmit</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> lc = <span class="keyword">new</span> LoginController();</span></span><br><span class="line">            lc.validateEntry();</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>行为委托写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Controller = &#123;</span><br><span class="line">  errors: [],</span><br><span class="line">  showDialog: <span class="function"><span class="keyword">function</span>(<span class="params">title, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(title + msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Success"</span>, msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.push(err);</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Error"</span>, err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将LoginController委托给Controller</span></span><br><span class="line"><span class="keyword">var</span> LoginController = <span class="built_in">Object</span>.create(Controller);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(LoginController, &#123;</span><br><span class="line">  getUser: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getPassword: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  validateEntry: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">user, pw</span>) </span>&#123;</span><br><span class="line">      user = user || <span class="keyword">this</span>.getUser();</span><br><span class="line">      pw = pw || <span class="keyword">this</span>.getPassword();</span><br><span class="line">      <span class="keyword">if</span> (!(user &amp;&amp; pw)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Please enter a username &amp; password!"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pw.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Password must be 5+ characters!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.success(<span class="string">"login success!!!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在JavaScript中努力实现类机制（参见第4和第5章），也可以拥抱更自然的[[Prototype]]委托机制。</p>
<h2 id="2-6-异步和性能"><a href="#2-6-异步和性能" class="headerlink" title="2.6 异步和性能"></a>2.6 异步和性能</h2><h3 id="2-6-1-事件循环"><a href="#2-6-1-事件循环" class="headerlink" title="2.6.1 事件循环"></a>2.6.1 事件循环</h3><h4 id="（1）JS为何设计为单线程"><a href="#（1）JS为何设计为单线程" class="headerlink" title="（1）JS为何设计为单线程"></a>（1）JS为何设计为单线程</h4><hr>
<h5 id="js设计为单线程还是跟他的用途有关"><a href="#js设计为单线程还是跟他的用途有关" class="headerlink" title="js设计为单线程还是跟他的用途有关"></a>js设计为单线程还是跟他的用途有关</h5><p>试想一下 如果js设计为多线程 那么同时修改和删除同一个dom 浏览器又该如何执行?</p>
<p>#JS为何需要异步</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">9999</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我在执行 但用户不知道"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"你好啊"</span>)</span><br></pre></td></tr></table></figure>

<p>上图例子 for循环耗时会很久</p>
<p>这意味着 用户得不到 ‘你好啊’ 的响应 就会下意识会认为浏览器卡死了 所以js必须要有异步</p>
<p>js通过事件循环来实现异步 这也是js的运行机制</p>
<hr>
<h4 id="（2）JS事件的循环"><a href="#（2）JS事件的循环" class="headerlink" title="（2）JS事件的循环"></a>（2）JS事件的循环</h4><h5 id="1-归类"><a href="#1-归类" class="headerlink" title="1.归类"></a>1.归类</h5><p>遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task)。</p>
<p>宏任务：整体的<em>Scrip*t *setTimeout</em> <em>setInterval</em><br> 微任务：<em>Promise</em>      process.nextTick    </p>
<p> 示例代码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个同步任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>)            --------&gt; 直接被执行</span><br><span class="line">                                      目前打印结果为：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个宏任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    --------&gt; 整体的setTimeout被放进宏任务列表</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)                    目前宏任务列表记为【s2】</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是同步任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);         --------&gt; 直接被执行</span><br><span class="line">  resolve();                          目前打印结果为：<span class="number">1</span>、<span class="number">3</span></span><br><span class="line">  <span class="comment">// then是一个微任务</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       --------&gt; 整体的then[包含里面的setTimeout]被放进微任务列表</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)                    目前微任务列表记为【t45】</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一轮小结：</span><br><span class="line">执行到这里的结果：<span class="number">1</span>、<span class="number">3</span></span><br><span class="line"></span><br><span class="line">宏任务列表如下：</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>住：promise对象详解：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p>
<h5 id="2-有微则微，无微则宏"><a href="#2-有微则微，无微则宏" class="headerlink" title="2.有微则微，无微则宏"></a>2.有微则微，无微则宏</h5><p>如果微任务列表里面有任务 会执行完毕后在执行宏任务。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">浏览器瞅了一眼微任务列表 发现里面有微任务 就开始全部执行</span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)            --------&gt; 直接被执行</span><br><span class="line">                                        目前打印结果为：<span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    --------&gt; 被放进宏任务列表了</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)                    目前宏任务列表记为【s2、s5】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">浏览器发现微任务执行完毕了</span><br><span class="line"></span><br><span class="line">开始执行宏任务列表</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)   --------&gt; 直接被执行</span><br><span class="line">                               目前打印结果为：<span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)   --------&gt; 直接被执行</span><br><span class="line">                               目前打印顺序为： <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span>、<span class="number">5</span>、<span class="number">5</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">最终结果为： <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span>、<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h5 id="3-总结-实战"><a href="#3-总结-实战" class="headerlink" title="3.总结 + 实战"></a>3.总结 + 实战</h5><p>反复执行以上步骤 就是事件循环(event loop) 一定要分的清任务类型 (宏任务 和 微任务)</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">TIP: 为了容易辨别起名为p1（p开头 里面打印<span class="number">1</span>）</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         --------&gt; 被放微任务列表</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'1'</span>);                             微任务列表记为：【p1】</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'2'</span>);                   --------&gt; 直接执行</span><br><span class="line">   resolve();                                    目前打印顺序为：<span class="number">2</span></span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 --------&gt; 整体的then被放进微任务列表[包含其中的setTimeout <span class="number">4</span>]</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'3'</span>);                             微任务列表记为：【p1 t34】</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;              --------&gt; 被放宏任务列表</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'5'</span>)                              宏任务列表记为：【s5】</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            --------&gt; 被放宏任务列表</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'6'</span>)                            宏任务列表记为：【s5 s6】</span><br><span class="line">   &#125;);</span><br><span class="line">   resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 --------&gt; 整体的then被放进微任务列表[包含其中的setTimeout和其中的多层嵌套]</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                      微任务列表记为：【p1 t34 t789】</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">       &#125;);</span><br><span class="line">       resolve()</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'10'</span>)                      --------&gt; 直接执行</span><br><span class="line">                                                  目前打印顺序为：<span class="number">2</span>、<span class="number">10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">第一轮小结：</span><br><span class="line">执行结果为：<span class="number">2</span>、<span class="number">10</span></span><br><span class="line"></span><br><span class="line">宏任务列表如下：</span><br><span class="line"><span class="comment">// s5</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s6</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t34</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// t789</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">开始执行第二轮：</span><br><span class="line">有微任务 先执行微任务</span><br><span class="line">将微任务列表代码块搬下来</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             --------&gt; 执行p1</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);                                 目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t34</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);                       --------&gt; 直接执行</span><br><span class="line">                                                    目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                --------&gt; 被放宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)                                宏任务列表记为：【s5 s6 s4】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// t789</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;              --------&gt; 被放宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>)                              宏任务列表记为：【s5 s6 s4 s789】</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">微任务执行完毕了 该执行我们的宏任务列表了</span><br><span class="line">因为微任务里面包含一部分宏任务</span><br><span class="line">所以现在的宏任务列表已经增加了</span><br><span class="line">现在把当前的宏任务列表搬下来</span><br><span class="line"><span class="comment">//s5</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s5</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s6</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s6</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s4</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s4</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// s789</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s789</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       --------&gt; 被放宏任务列表</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'8'</span>)                       宏任务列表记为：【s8】</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            --------&gt; 整体的then被放微任务列表[包含里面的setTimeout]</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 微任务列表记为：【t9】</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">再次小结：</span><br><span class="line">当前结果：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span></span><br><span class="line">马上就要执行完了心里万分激动啊 （ 浏览器的内心独白 ^▽^  ...）</span><br><span class="line">宏任务列表如下：</span><br><span class="line"><span class="comment">// s8</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line"><span class="comment">// t9</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">继续执行 依旧遵循有微则微 无微则宏</span><br><span class="line">浏览器发现有一条微任务</span><br><span class="line">那就开始执行吧~</span><br><span class="line"><span class="comment">//t9</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   --------&gt; 执行t9 把里面的setTimeout放入宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>)                   宏任务列表记为：【s8 s9】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表执行完毕</span><br><span class="line">开始执行宏任务（宏任务刚刚又有新增哦~[s9]）</span><br><span class="line"><span class="comment">// s8</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     --------&gt; 执行s8</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)                     目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span>、<span class="number">8</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// s9</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     --------&gt; 执行s9</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>)                     目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">到这里 微任务列表 和 宏任务列表均为空 就执行完毕了</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-回调"><a href="#2-6-2-回调" class="headerlink" title="2.6.2 回调"></a>2.6.2 回调</h3><h5 id="异步回调的问题"><a href="#异步回调的问题" class="headerlink" title="异步回调的问题"></a>异步回调的问题</h5><h6 id="1-调用函数过早"><a href="#1-调用函数过早" class="headerlink" title="1.调用函数过早"></a>1.调用函数过早</h6><p>调用函数过早的最值得让人注意的问题， 是你不小心定义了一个函数，使得作为函数参数的回调可能延时调用，也可能立即调用。 也即你使用了一个可能同步调用， 也可能异步调用的回调。 这样一种难以预测的回调。</p>
<p>在英语世界里， 这种可能同步也可能异步调用的回调以及包裹它的函数， 被称作是 “Zalgo” （一种都市传说中的魔鬼）， 而编写这种函数的行为， 被称作是”release Zalgo” (将Zalgo释放了出来)</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line">zalgoFunction () &#123;</span><br><span class="line">  <span class="comment">// 这里还有很多其他代码,使得a = 2可能被异步调用也可能被同步调用</span></span><br><span class="line">    [<span class="meta">  a = 2  </span>]</span><br><span class="line">  &#125;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<p>结果会输出什么呢？ 如果zalgoFunction是同步的， 那么a 显然等于2， 但如果 zalgoFunction是异步的，那么 a显然等于1。于是， 我们陷入了无法判断调用影响的窘境。</p>
<p>这只是一个极为简单的场景， 如果场景变得相当复杂， 结果又会如何呢？你可能想说： 我自己写的函数我怎么会不知道呢？<strong>很多时候这个不确定的函数来源于它人之手，甚至来源于完全无法核实的第三方代码。我们把这种不确定的情况稍微变得夸张一些： 这个函数中传入的回调， 有99%的几率被异步调用， 有1%的几率被同步调用。</strong></p>
<h6 id="2-调用次数过多"><a href="#2-调用次数过多" class="headerlink" title="2.调用次数过多"></a>2.调用次数过多</h6><p>这里取《你不知道的javascript（中卷）》的例子给大家看一看：</p>
<p>作为一个公司的员工，你需要开发一个网上商城， payWithYourMoney是你在确认购买后执行的扣费的函数， 由于公司需要对购买的数据做追踪分析， 这里需要用到一个做数据分析的第三方公司提供的analytics对象中的purchase函数。 代码看起来像这样</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">analytics.purchase( purchaseData, <span class="function"><span class="keyword">function</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">      payWithYourMoney ()</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>在这情况下，可能我们会忽略的一个事实是： 我们已经把payWithYourMoney 的控制权完全交给了analytics.purchase函数了，这让我们的回调“任人宰割”，这种控制权的转移， 被叫做“控制反转”。</p>
<p>然后上线后的一天， 数据分析公司的一个隐蔽的bug终于显露出来， <strong>让其中一个原本只执行一次的payWithYourMoney执行了5次</strong>， 这让那个网上商城的客户极为恼怒， 并投诉了你们公司。可你们公司也很无奈， 这个时候惊奇的发现： payWithYourMoney的控制完全不在自己的手里 ！！！！！后来， 为了保证只支付一次， 代码改成了这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 判断是否已经分析（支付）过一次了</span></span><br><span class="line"><span class="keyword">var</span> analysisFlag  = <span class="literal">true</span></span><br><span class="line">analytics.purchase( purchaseData, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (！analysisFlag) &#123;</span><br><span class="line">           payWithYourMoney ()</span><br><span class="line">           analysisFlag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>但是， 这种方式虽然巧妙， 但却仍不够简洁优雅（后文提到的Promise将改变这一点）。而且， 在回调函数的无数“痛点”中， 它只能规避掉一个， 如果你尝试规避掉所有的“痛点”，代码将比上面更加复杂而混乱。</p>
<h6 id="3-太晚调用或根本没有调用"><a href="#3-太晚调用或根本没有调用" class="headerlink" title="3.太晚调用或根本没有调用"></a>3.太晚调用或根本没有调用</h6><p>因为你失去了对回调的控制权， 你的回调可能会出现预期之外的过晚调用或者不调用的情况（为了处理这个“痛点”你又将混入一些复杂的代码逻辑）</p>
<h6 id="4-吞掉报错"><a href="#4-吞掉报错" class="headerlink" title="4.吞掉报错"></a>4.吞掉报错</h6><p>回调内的报错是可能被包裹回调的外部函数捕捉而不报错，（为了处理这个“痛点”你又又又将混入一些复杂的代码逻辑）</p>
<h6 id="5-复杂情况下可读性差"><a href="#5-复杂情况下可读性差" class="headerlink" title="5.复杂情况下可读性差"></a>5.复杂情况下可读性差</h6><p>请问这段代码的调用顺序 ？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doA( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    doB();</span><br><span class="line">    doC( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      doD();</span><br><span class="line">          &#125; )</span><br><span class="line">    doE();</span><br><span class="line">&#125; );</span><br><span class="line">doF();</span><br></pre></td></tr></table></figure>

<p>让人一脸蒙逼的回调函数地狱</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> catList = name + <span class="string">','</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    catList += name + <span class="string">','</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      catList += name + <span class="string">','</span>;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        catList += name + <span class="string">','</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">          catList += name;</span><br><span class="line">          <span class="built_in">console</span>.log(catList);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="string">'Lion'</span>);</span><br><span class="line">      &#125;, <span class="number">1</span>, <span class="string">'Snow Leopard'</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="string">'Lynx'</span>);</span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="string">'Jaguar'</span>);&#125;, <span class="number">1</span>, <span class="string">'Panther'</span>);</span><br></pre></td></tr></table></figure>

<h6 id="6-门"><a href="#6-门" class="headerlink" title="6.门"></a>6.门</h6><p>什么叫“门”？， 你可以大概理解成： 现在有一群人准备进屋，但只有他们所有人都到齐了，才能“进门” ，也就是： 只有所有的异步操作都完成了， 我们才认为它整体完成了，才能进行下一步操作</p>
<p>下面这个例子里， 我们试图通过两个异步请求操作，希望当a和b的取值都到达的时候才输出！！</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   a = x * <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">        baz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    b = y * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">           baz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log( a + b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中的某个Ajax函数</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>

<p>这段代码比前面那段“链式”里的回调地狱好懂多了，但是却依然存在这一些问题：我们使用了两个 if (a &amp;&amp; b) { } 去分别保证baz是在a和b都到达后才执行的，试着思考一下：两个 if (a &amp;&amp; b) { } 的判断条件是否可以合并到一起呢，因为这两个判断条件都试图表达同一种语意： a 和 b都到达， 能合并成一条语句的话岂不是更加简洁优雅 ？ （一切都在为Promise做铺垫哦<del>~</del>啦啦啦）</p>
<h6 id="7-竞态"><a href="#7-竞态" class="headerlink" title="7.竞态"></a>7.竞态</h6><p>一组异步操作，其中一个完成了， 这组异步操作便算是整体完成了。在下面，我们希望通过异步请求的方式，取得x的值，然后执行foo或者bar，但希望只把foo或者bar其中一个函数执行一次</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        baz(x);</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">         x = x*<span class="number">2</span></span><br><span class="line">         baz(x);</span><br><span class="line">         flag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"> x </span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( x );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中的某个Ajax函数</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>

<p>在这里，我们设置了一个flag， 设它的初始值为true, 这时候foo或者bar在第一次执行的时候， 是可以进入if内部的代码块并且执行baz函数的， 但在if内部的代码块结束的时候， 我们把flag的值置为false,这个时候下一个函数就无法进入代码块执行了， 这就是回调对于竞态的处理。</p>
<h3 id="2-6-3-Promise"><a href="#2-6-3-Promise" class="headerlink" title="2.6.3 Promise"></a>2.6.3 Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">Stream 模式</a>是比部署Promise更好的选择。</p>
<h5 id="Promise是怎么解决问题的"><a href="#Promise是怎么解决问题的" class="headerlink" title="Promise是怎么解决问题的"></a>Promise是怎么解决问题的</h5><p>1.回调过早调用<br> 让我们回到那个回调的痛点：我们有可能会写出一个既可能同步执行， 又可能异步执行的“zalgo”函数。但Promise可以自动帮我们避免这个问题：如果对一个 Promise 调用 then(..) 的时候，即使这个 Promise是立即resolve的函数（即Promise内部没有ajax等异步操作，只有同步操作）， 提供给then(..) 的回调也是会被异步调用的，这帮助我们省了不少心</p>
<ol>
<li>回调调用次数过多<br> Promise 的内部机制决定了调用单个Promise的then方法， 回调只会被执行一次，因为Promise的状态变化是单向不可逆的，当这个Promise第一次调用resolve方法， 使得它的状态从pending（正在进行）变成fullfilled（已成功）或者rejected（被拒绝）后， 它的状态就再也不能变化了。所以你完全不必担心Promise.then( function ) 中的function会被调用多次的情况</li>
<li>回调中的报错被吞掉<br> 要说明一点的是Promise中的then方法中的error回调被调用的时机有两种情况：</li>
</ol>
<ul>
<li>a. Promise中主动调用了reject (有意识地使得Promise的状态被拒绝)， 这时error回调能够接收到reject方法传来的参数（reject(error)）</li>
<li>b. 在定义的Promise中， 运行时候报错（未预料到的错误）， 也会使得Promise的状态被拒绝，从而使得error回调能够接收到捕捉到的错误</li>
</ul>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      foo.bar(); <span class="comment">// foo未定义，所以会出错！</span></span><br><span class="line">      resolve( <span class="number">42</span> ); <span class="comment">// 永远不会到达这里 :( </span></span><br><span class="line"> &#125; );</span><br><span class="line">p.then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 永远不会到达这里 :(    </span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="comment">// err将会是一个TypeError异常对象来自foo.bar()这一行      </span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>还有一种情况是回调根本就没有被调用，这是可以用Promise的race方法解决（下文将介绍）</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于超时一个Promise的工具 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject( <span class="string">"Timeout!"</span> );</span><br><span class="line">          &#125;, delay );</span><br><span class="line">      &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置foo()超时 </span></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">   foo(), <span class="comment">// 试着开始foo()</span></span><br><span class="line">   timeoutPromise( <span class="number">3000</span> ) <span class="comment">// 给它3秒钟</span></span><br><span class="line">] ).then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">// foo(..)及时完成！ </span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     <span class="comment">// 或者foo()被拒绝，或者只是没能按时完成</span></span><br><span class="line">     <span class="comment">// 查看err来了解是哪种情况 </span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5.链式<br> 我们上面说了， 纯回调的一大痛点就是“金字塔回调地狱”， 这种“嵌套风格”的代码丑陋难懂，但Promise就可以把这种“嵌套”风格的代码改装成我们喜闻乐见的“链式”风格。因为then函数是可以链式调用的， 你的代码可以变成这样</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.then(</span><br><span class="line">  <span class="comment">// 第一个异步操作 </span></span><br><span class="line">).then(</span><br><span class="line">  <span class="comment">// 第二个异步操作 </span></span><br><span class="line">).then(</span><br><span class="line">  <span class="comment">// 第三个异步操作</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>6.门Promise.all，竞态Promise.race见后文</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。下面代码创造了一个Promise实例。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</strong></p>
<p>下面是一个Promise对象的简单例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p>
<p>下面是一个用Promise对象实现的 Ajax 操作的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，<strong>resolve函数和reject函数调用时，都带有参数。</strong></p>
<h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h5><p>前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;&#x2F;post&#x2F;1.json&quot;).then(</span><br><span class="line">  post &#x3D;&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments &#x3D;&gt; console.log(&quot;resolved: &quot;, comments),</span><br><span class="line">  err &#x3D;&gt; console.log(&quot;rejected: &quot;, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h5><p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名</strong>，用于指定发生错误时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))</span><br><span class="line">  .catch((err) &#x3D;&gt; console.log(&#39;rejected&#39;, err));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">p.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))</span><br><span class="line">  .then(null, (err) &#x3D;&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>

<p>下面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">finally</span>(server.stop);</span><br></pre></td></tr></table></figure>

<p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。</p>
<h3 id="2-6-4-生成器generator"><a href="#2-6-4-生成器generator" class="headerlink" title="2.6.4 生成器generator"></a>2.6.4 生成器generator</h3><p>生成器是一种能够暂停函数执行的函数， 使用<code>function *</code>定义, <code>yield</code>指定执行时候的暂停位置，<code>yield</code>会产出一个值作为<code>it.next()</code>的结果， <code>yield</code>能够接收参数并作为<code>yield</code>暂停处的替代值</p>
<p>比如下述代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = x * (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="keyword">var</span> res = it.next(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.value);</span><br></pre></td></tr></table></figure>

<p>第一个next(..)总是启动一个生成器，并运行到第一个yield处。不过，是第二个next(..)调用完成第一个被暂停的yield表达式，第三个next(..)调用完成第二个yield，以此类推。</p>
<p>通过多个生成器在共享的相同变量上的迭代交替执行，会使得程序可能产生多种不同的结果</p>
<p>比如以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  b = b * a;</span><br><span class="line">  a = (<span class="keyword">yield</span> b) + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b--;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  a = (<span class="keyword">yield</span> <span class="number">8</span>) + b;</span><br><span class="line">  b = a * (<span class="keyword">yield</span> <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以为两个生成器共享变量a和b，如果使用next()函数对两个生成器的实例进行迭代的时候的执行顺序不同会导致a和b最终的值不同,这在传统的函数中是不可能的，传统的函数是一个函数的执行必须等待上一个函数执行完毕,比如:</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  b = b * a;</span><br><span class="line">  a = b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b--;</span><br><span class="line">  a = <span class="number">8</span> + b;</span><br><span class="line">  b = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要么foo()先执行，要么bar()先执行，不可能交替执行</span></span><br></pre></td></tr></table></figure>

<p><strong>异步迭代生成器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">  ajax(<span class="string">"http://some.url"</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">11</span>, <span class="number">31</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用生成器来表达同样的任务流程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  ajax(<span class="string">"http://some.url"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">// 向*main()抛出一个错误</span></span><br><span class="line">       it.throw(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用收到的data回复*main()的执行</span></span><br><span class="line">      it.next(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">vat it = main();</span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// 生成器使用yield进行流程控制，实现了暂停/阻塞</span></span><br></pre></td></tr></table></figure>

<p><strong>同步错误处理</strong></p>
<p>生成器yield暂停的特性意味着我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误！在异步代码中实现看似同步的错误处理（通过try..catch）在可读性和合理性方面都是一个巨大的进步。</p>
<p><strong>生成器+Promise</strong></p>
<p>看似同步的异步代码（生成器）+ 可信任(Promise)是完美的搭配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把支持Promise的foo和生成器main放在一起</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"><span class="keyword">var</span> p = it.next().value;</span><br><span class="line"><span class="comment">// 监测promise状态，在promise决议后恢复生成器执行</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  it.next(text);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  it.throw(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>封装Generator Runner</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), it;</span><br><span class="line">  <span class="comment">// 在当前上下文中初始化生成器</span></span><br><span class="line">  it = gen.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个promise用于生成器完成</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  				.then(<span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    			  <span class="comment">// 对下一个yield出的值运行</span></span><br><span class="line">     				<span class="keyword">var</span> next = it.next(value);</span><br><span class="line">    			  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">              <span class="comment">// 判断生成器是否运行完成</span></span><br><span class="line">              <span class="keyword">if</span>(next.done)&#123;</span><br><span class="line">                 <span class="keyword">return</span> next.value;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 生成器还没有运行完成，继续运行，将promise的决议值发回生成器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">                    .then(handleNext, <span class="function"><span class="keyword">function</span> <span class="title">handleErr</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                 				<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(it.throw(err)).</span><br><span class="line">                        				then(handleResult);</span><br><span class="line">                		&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)(next);</span><br><span class="line">  				&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成器中的Promise并发</strong></p>
<p>想像这样一个场景：你需要从不同的来源数据获取数据，然后把响应结合在一起以形成第三个请求，最终把最后一条响应打印出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    request(<span class="string">"http://some.url1"</span>),</span><br><span class="line">    request(<span class="string">"http://some.url2"</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">var</span> [a,b]=result;</span><br><span class="line">  <span class="keyword">var</span> r=<span class="keyword">yield</span> request(<span class="string">"http://some.url30"</span>+a+<span class="string">","</span>+b);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;</span><br><span class="line">run(foo);</span><br></pre></td></tr></table></figure>

<ol>
<li>使用了Promise.all()来实现了两个请求的并发。</li>
<li>[a,b]是ES6的解析赋值，把var a=…var b=…赋值语句简化为var [a,b[=result。</li>
<li>最后使用了上面定义的run()来执行生成器。</li>
</ol>
<p><strong>生成器委托</strong></p>
<p>我们可能会从一个生成器中调用另一个生成器</p>
<p>我们可以使用之前封装的自动运行生成器函数来实现生成器内调用其他生成器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     resolve(<span class="string">`<span class="subst">$&#123;url&#125;</span> request success!`</span>);</span><br><span class="line">   &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.2"</span>);</span><br><span class="line">  <span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.3"</span>);</span><br><span class="line">  <span class="keyword">return</span> [r2, r3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.1"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1);</span><br><span class="line">  <span class="keyword">let</span> [r2,r3] = <span class="keyword">yield</span> run(foo);</span><br><span class="line">  <span class="built_in">console</span>.log(r2);</span><br><span class="line">  <span class="built_in">console</span>.log(r3);</span><br><span class="line">&#125;</span><br><span class="line">run(bar);</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>yield *</code>来实现生成器委托<code>yield *foo()</code></p>
<p>yield ＊暂停了迭代控制，而不是生成器控制。当你调用＊foo()生成器时，现在yield委托到了它的迭代器。但实际上，你可以yield委托到任意<strong>iterable</strong>, yield ＊[1,2,3]会消耗数组值[1,2,3]的默认迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">num</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = num();</span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>生成器委托可以进行双向消息传递(利用<code>next()</code>和<code>yield</code>)</p>
</li>
<li><p>异常也会被委托</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error caught inside *foo():"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"D"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> *foo();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error caught insdie *bar():"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"E"</span>;</span><br><span class="line">    <span class="keyword">yield</span> *baz();</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"G"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next().value); <span class="comment">// outside: A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next(<span class="number">1</span>).value); <span class="comment">// outside: B</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.throw(<span class="number">2</span>).value); <span class="comment">// error caught inside *foo():2 \n outside: C</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next(<span class="number">3</span>).value);  <span class="comment">// error caught inside *bar(): D \n outside: E</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cconsole.log(<span class="string">"outside:"</span>, it.next(<span class="number">4</span>).value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error caught outside"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error caught outside: F</span></span><br></pre></td></tr></table></figure>

<p>(1) 调用it.throw(2)时，它会发送错误消息2到＊bar()，它又将其委托给＊foo()，后者捕获并处理它。然后，yield “C”把”C”发送回去作为it.throw(2)调用返回的value。</p>
<p>(2) 接下来从＊foo()内throw出来的值”D”传播到＊bar()，这个函数捕获并处理它。然后yield”E”把”E”发送回去作为it.next(3)调用返回的value。</p>
<p>(3) 然后，从＊baz() throw出来的异常并没有在＊bar()内被捕获——所以＊baz()和＊bar()都被设置为完成状态。这段代码之后，就再也无法通过任何后续的next(..)调用得到值”G”, next(..)调用只会给value返回undefined</p>
</li>
<li><p>并发委托</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;url&#125;</span> request success!!`</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runAllGen = (...genArr) = &#123;</span><br><span class="line">  <span class="keyword">const</span> itArr = [],</span><br><span class="line">        pArr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> gen <span class="keyword">of</span> genArr)&#123;</span><br><span class="line">    <span class="keyword">const</span> it = gen();</span><br><span class="line">    itArr.push(it);</span><br><span class="line">    <span class="keyword">const</span> p = it.next().value;</span><br><span class="line">    pArr.push(p);</span><br><span class="line">    p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      it.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Promise</span>.all([...pArr])</span><br><span class="line">		.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> it <span class="keyword">of</span> itArr)&#123;</span><br><span class="line">      it.next();</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">runAllgen(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.1"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.2"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.3"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-6-5-性能测试与调优"><a href="#2-6-5-性能测试与调优" class="headerlink" title="2.6.5 性能测试与调优"></a>2.6.5 性能测试与调优</h3><p>使用Benchmark.js和jsPerf分析代码性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> benchmark = <span class="built_in">require</span>(<span class="string">"benchmark"</span>);</span><br><span class="line"><span class="keyword">var</span> suite = <span class="keyword">new</span> benchmark.Suite;</span><br><span class="line"></span><br><span class="line">suite.add(<span class="string">'RegExp'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    /o/.test(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">'indexOf'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="string">'Hello World'</span>.indexOf(<span class="string">'o'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the fasted method is'</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.run(&#123;<span class="string">'async'</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RegExp x 33,125,825 ops/sec ±4.06% (77 runs sampled)</span></span><br><span class="line"><span class="comment">indexOf x 797,631,820 ops/sec ±1.69% (87 runs sampled)</span></span><br><span class="line"><span class="comment">the fasted method isindexOf</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>是函数式编程一个概念，是指某个函数最后一步是调用另一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</span></span><br></pre></td></tr></table></figure>

<p>以下两种情况都不属于尾调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数调用会在内存生成一个”调用记录“，又称为”调用帧(call frame)“，保存调用位置和内部变量等信息，如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="http://zh.wikipedia.org/wiki/调用栈" target="_blank" rel="noopener">“调用栈”</a>（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>尾递归</strong></p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<blockquote>
<ul>
<li><code>arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
</blockquote>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<p><strong>递归函数的改写</strong></p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">柯里化</a>（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>
<p>第二种方法就简单多了，就是采用ES6的函数默认值。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持”尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>

      
    </div>
    
    
    
    <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
    
  </div>

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wodegongzhonghao.jpg" alt="davidLee wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的公众号</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/weixinpay.jpeg" alt="davidLee 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpeg" alt="davidLee 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/04/2020-2020-06-04-%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/" rel="next" title="前端资源整理">
                <i class="fa fa-chevron-left"></i> 前端资源整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/22/2020-2020-06-22-ES6%E6%95%99%E7%A8%8B/" rel="prev" title="ECMAScript6教程">
                ECMAScript6教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="davidLee" />
            
              <p class="site-author-name" itemprop="name">davidLee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/davidLee6688" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liweidobest@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-基础知识"><span class="nav-text">一. 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-JavaScript之HelloWorld"><span class="nav-text">1.1 JavaScript之HelloWorld</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-运算符"><span class="nav-text">1.2 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-switch语句"><span class="nav-text">1.3 switch语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-值的比较"><span class="nav-text">1.4 值的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-函数Function"><span class="nav-text">1.5 函数Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-现代模式”use-strict”"><span class="nav-text">1.6 现代模式”use strict”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一：简单介绍"><span class="nav-text">一：简单介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二：使用方法"><span class="nav-text">二：使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1：为某个脚本使用严格模式"><span class="nav-text">1：为某个脚本使用严格模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2：单函数使用严格模式"><span class="nav-text">2：单函数使用严格模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三：严格模式带来的具体差异"><span class="nav-text">三：严格模式带来的具体差异</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1：消除了静默错误，改为抛出错误"><span class="nav-text">1：消除了静默错误，改为抛出错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2：修复了JS的随意性，提升了优化能力"><span class="nav-text">2：修复了JS的随意性，提升了优化能力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3：让eval和arguments变的更加简单"><span class="nav-text">3：让eval和arguments变的更加简单</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4：更加安全的JS"><span class="nav-text">4：更加安全的JS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5：对未来的兼容"><span class="nav-text">5：对未来的兼容</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-变量"><span class="nav-text">1.7 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-条件运算符和"><span class="nav-text">1.8 条件运算符和?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-交互：alert、prompt-和-confirm"><span class="nav-text">1.9 交互：alert、prompt 和 confirm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-数据类型"><span class="nav-text">1.10 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-0-1-值"><span class="nav-text">2.0.1 值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-0-2-原生函数"><span class="nav-text">2.0.2 原生函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-0-3-强制类型转换"><span class="nav-text">2.0.3 强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-循环"><span class="nav-text">1.11 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for"><span class="nav-text">for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach"><span class="nav-text">forEach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do…while"><span class="nav-text">do…while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while"><span class="nav-text">while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…in"><span class="nav-text">for…in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…of"><span class="nav-text">for…of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for…in-VS-FOR…OF"><span class="nav-text">for…in VS FOR…OF</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-深入学习"><span class="nav-text">二. 深入学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-作用域和闭包"><span class="nav-text">2.1 作用域和闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-编译原理"><span class="nav-text">2.1.2 编译原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-理解作用域"><span class="nav-text">2.1.3 理解作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4作用域嵌套"><span class="nav-text">2.1.4作用域嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-词法作用域"><span class="nav-text">2.1.5 词法作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-6-函数作用域"><span class="nav-text">2.1.6 函数作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-7-函数声明，函数表达式，匿名函数"><span class="nav-text">2.1.7 函数声明，函数表达式，匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-8-立即执行函数-IIFE-Immediately-invoked-Function-Expression"><span class="nav-text">2.1.8 立即执行函数(IIFE, Immediately invoked Function Expression)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-9-块作用域"><span class="nav-text">2.1.9 块作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-10-提升"><span class="nav-text">2.1.10 提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-11-作用域和闭包"><span class="nav-text">2.1.11 作用域和闭包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-this"><span class="nav-text">2.2 this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-this的绑定规则"><span class="nav-text">2.2.1 this的绑定规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-this绑定规则的优先级"><span class="nav-text">2.2.2 this绑定规则的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-箭头函数的this绑定规则"><span class="nav-text">2.2.3 箭头函数的this绑定规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-对象"><span class="nav-text">2.3 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-类型"><span class="nav-text">2.3.1 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-对象属性"><span class="nav-text">2.3.2 对象属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-对象复制"><span class="nav-text">2.3.3 对象复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-属性描述符"><span class="nav-text">2.3.4 属性描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-setter和getter"><span class="nav-text">2.3.5 setter和getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6-使用in-或者-hasOwnProperty判断属性存在性"><span class="nav-text">2.3.6 使用in 或者 hasOwnProperty判断属性存在性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-7-对象的遍历"><span class="nav-text">2.3.7 对象的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-类-继承-混入"><span class="nav-text">2.4 类, 继承, 混入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-类的机制"><span class="nav-text">2.4.1 类的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-类的继承"><span class="nav-text">2.4.2 类的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-原型和原型链"><span class="nav-text">2.5 原型和原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、prototype"><span class="nav-text">一、prototype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、proto"><span class="nav-text">二、proto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、constructor"><span class="nav-text">三、constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、实例与原型"><span class="nav-text">四、实例与原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、原型的原型"><span class="nav-text">五、原型的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、原型链"><span class="nav-text">六、原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-属性的设置和屏蔽"><span class="nav-text">七. 属性的设置和屏蔽</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-行为委托"><span class="nav-text">2.6 行为委托</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-异步和性能"><span class="nav-text">2.6 异步和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-事件循环"><span class="nav-text">2.6.1 事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）JS为何设计为单线程"><span class="nav-text">（1）JS为何设计为单线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#js设计为单线程还是跟他的用途有关"><span class="nav-text">js设计为单线程还是跟他的用途有关</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）JS事件的循环"><span class="nav-text">（2）JS事件的循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-归类"><span class="nav-text">1.归类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-有微则微，无微则宏"><span class="nav-text">2.有微则微，无微则宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-总结-实战"><span class="nav-text">3.总结 + 实战</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-回调"><span class="nav-text">2.6.2 回调</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异步回调的问题"><span class="nav-text">异步回调的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-调用函数过早"><span class="nav-text">1.调用函数过早</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-调用次数过多"><span class="nav-text">2.调用次数过多</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-太晚调用或根本没有调用"><span class="nav-text">3.太晚调用或根本没有调用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-吞掉报错"><span class="nav-text">4.吞掉报错</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-复杂情况下可读性差"><span class="nav-text">5.复杂情况下可读性差</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-门"><span class="nav-text">6.门</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-竞态"><span class="nav-text">7.竞态</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-Promise"><span class="nav-text">2.6.3 Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise是怎么解决问题的"><span class="nav-text">Promise是怎么解决问题的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基本用法"><span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-prototype-then"><span class="nav-text">Promise.prototype.then()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-prototype-catch"><span class="nav-text">Promise.prototype.catch()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-prototype-finally"><span class="nav-text">Promise.prototype.finally()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-all"><span class="nav-text">Promise.all()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-race"><span class="nav-text">Promise.race()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-4-生成器generator"><span class="nav-text">2.6.4 生成器generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-5-性能测试与调优"><span class="nav-text">2.6.5 性能测试与调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尾调用优化"><span class="nav-text">尾调用优化</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
	<span title="Site words total count">
     字 </span>
    <!--<span title="symbols_count_time.count_total">558k</span>-->
  
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lCk9ARlsA5kpg8AAioyPXYCB-gzGzoHsz',
        appKey: 'iS4AXSvlD0t0ESeSalr6dOIm',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
