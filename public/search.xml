<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML标签整理</title>
    <url>/2020/05/12/2020-2020-05-12-HTML%E6%A0%87%E7%AD%BE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><img src="/img/HTML%E6%A0%87%E7%AD%BE%E6%95%B4%E7%90%86.png" alt="HTML标签整理.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5知识点总结</title>
    <url>/2020/05/12/2020-2020-05-12-HTML5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/img/HTML5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.png" alt="HTML5知识点总结.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Cytoscape.js教程</title>
    <url>/2020/05/16/2020-2020-05-16-cytoscape-js%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-Cytoscape-js简介与安装"><a href="#一-Cytoscape-js简介与安装" class="headerlink" title="一. Cytoscape.js简介与安装"></a>一. Cytoscape.js简介与安装</h1><h2 id="1-1-Cytoscape-js是什么？"><a href="#1-1-Cytoscape-js是什么？" class="headerlink" title="1.1 Cytoscape.js是什么？"></a>1.1 Cytoscape.js是什么？</h2><p>cytoscape.js是一个做网页可视化的常用工具 。cytoscape.js包含图论模型和可选的渲染器，用于显示交互式图形。该库旨在使程序员和科学家尽可能轻松地在他们的应用程序中使用图形理论，无论是用于Node.js应用程序中的服务器端分析还是用于丰富的用户界面。 </p>
<h2 id="1-2-Cytoscape-js安装及HelloWorld"><a href="#1-2-Cytoscape-js安装及HelloWorld" class="headerlink" title="1.2 Cytoscape.js安装及HelloWorld"></a>1.2 Cytoscape.js安装及HelloWorld</h2><h3 id="1-2-1-使用包管理工具进行安装"><a href="#1-2-1-使用包管理工具进行安装" class="headerlink" title="1.2.1 使用包管理工具进行安装"></a>1.2.1 使用包管理工具进行安装</h3><ul>
<li>npm : <code>npm install cytoscape</code></li>
<li>bower : <code>bower install cytoscape</code></li>
<li>jspm : <code>jspm install npm:cytoscape</code></li>
</ul>
<h3 id="1-2-2-使用Script标签直接引入"><a href="#1-2-2-使用Script标签直接引入" class="headerlink" title="1.2.2 使用Script标签直接引入"></a>1.2.2 使用Script标签直接引入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;cytoscape.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-HelloWorld"><a href="#1-2-3-HelloWorld" class="headerlink" title="1.2.3 HelloWorld"></a>1.2.3 HelloWorld</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cy = cytoscape(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.getElementById(<span class="string">'cy'</span>) <span class="comment">// container to render in</span></span><br><span class="line">&#125;);</span><br><span class="line">也可以给container传递jQuery实例</span><br><span class="line"><span class="keyword">var</span> cy = cytoscape(&#123;</span><br><span class="line">  container: $(<span class="string">'#cy'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-常用参数"><a href="#1-2-4-常用参数" class="headerlink" title="1.2.4 常用参数"></a>1.2.4 常用参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// very commonly used options</span></span><br><span class="line">  container: <span class="literal">undefined</span>,</span><br><span class="line">  elements: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  style: [ <span class="comment">/* ... */</span> ],</span><br><span class="line">  layout: &#123; <span class="attr">name</span>: <span class="string">'grid'</span> <span class="comment">/* , ... */</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initial viewport state:</span></span><br><span class="line">  zoom: <span class="number">1</span>,</span><br><span class="line">  pan: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// interaction options:</span></span><br><span class="line">  minZoom: <span class="number">1e-50</span>,</span><br><span class="line">  maxZoom: <span class="number">1e50</span>,</span><br><span class="line">  zoomingEnabled: <span class="literal">true</span>,</span><br><span class="line">  userZoomingEnabled: <span class="literal">true</span>,</span><br><span class="line">  panningEnabled: <span class="literal">true</span>,</span><br><span class="line">  userPanningEnabled: <span class="literal">true</span>,</span><br><span class="line">  boxSelectionEnabled: <span class="literal">true</span>,</span><br><span class="line">  selectionType: <span class="string">'single'</span>,</span><br><span class="line">  touchTapThreshold: <span class="number">8</span>,</span><br><span class="line">  desktopTapThreshold: <span class="number">4</span>,</span><br><span class="line">  autolock: <span class="literal">false</span>,</span><br><span class="line">  autoungrabify: <span class="literal">false</span>,</span><br><span class="line">  autounselectify: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rendering options:</span></span><br><span class="line">  headless: <span class="literal">false</span>,</span><br><span class="line">  styleEnabled: <span class="literal">true</span>,</span><br><span class="line">  hideEdgesOnViewport: <span class="literal">false</span>,</span><br><span class="line">  textureOnViewport: <span class="literal">false</span>,</span><br><span class="line">  motionBlur: <span class="literal">false</span>,</span><br><span class="line">  motionBlurOpacity: <span class="number">0.2</span>,</span><br><span class="line">  wheelSensitivity: <span class="number">1</span>,</span><br><span class="line">  pixelRatio: <span class="string">'auto'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-图形操作"><a href="#二-图形操作" class="headerlink" title="二. 图形操作"></a>二. 图形操作</h1><h2 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1. 添加元素"></a>1. 添加元素</h2><p><code>cy.add()</code></p>
<h3 id="1-1-添加单个节点"><a href="#1-1-添加单个节点" class="headerlink" title="1.1 添加单个节点"></a>1.1 添加单个节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.add(&#123;</span><br><span class="line">    group: <span class="string">'nodes'</span>,</span><br><span class="line">    data: &#123; <span class="attr">weight</span>: <span class="number">75</span> &#125;,</span><br><span class="line">    position: &#123; <span class="attr">x</span>: <span class="number">200</span>, <span class="attr">y</span>: <span class="number">200</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-添加节点和边"><a href="#1-2-添加节点和边" class="headerlink" title="1.2 添加节点和边"></a>1.2 添加节点和边</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eles = cy.add([</span><br><span class="line">  &#123; <span class="attr">group</span>: <span class="string">'nodes'</span>, <span class="attr">data</span>: &#123; <span class="attr">id</span>: <span class="string">'n0'</span> &#125;, <span class="attr">position</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">group</span>: <span class="string">'nodes'</span>, <span class="attr">data</span>: &#123; <span class="attr">id</span>: <span class="string">'n1'</span> &#125;, <span class="attr">position</span>: &#123; <span class="attr">x</span>: <span class="number">200</span>, <span class="attr">y</span>: <span class="number">200</span> &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">group</span>: <span class="string">'edges'</span>, <span class="attr">data</span>: &#123; <span class="attr">id</span>: <span class="string">'e0'</span>, <span class="attr">source</span>: <span class="string">'n0'</span>, <span class="attr">target</span>: <span class="string">'n1'</span> &#125; &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h2><p><code>cy.remove()</code></p>
<h3 id="2-1-移除单个元素"><a href="#2-1-移除单个元素" class="headerlink" title="2.1 移除单个元素"></a>2.1 移除单个元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = cy.$(<span class="string">'#j'</span>);</span><br><span class="line">cy.remove( j );</span><br></pre></td></tr></table></figure>

<h3 id="2-2-移除集合中的元素"><a href="#2-2-移除集合中的元素" class="headerlink" title="2.2 移除集合中的元素"></a>2.2 移除集合中的元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = cy.elements(<span class="string">'node[weight &gt; 50]'</span>);</span><br><span class="line">cy.remove( collection );</span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用选择器来进行元素删除"><a href="#2-3-使用选择器来进行元素删除" class="headerlink" title="2.3 使用选择器来进行元素删除"></a>2.3 使用选择器来进行元素删除</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = cy.elements(<span class="string">'node[weight &gt; 50]'</span>);</span><br><span class="line">cy.remove( collection );</span><br></pre></td></tr></table></figure>

<h2 id="3-使用集合"><a href="#3-使用集合" class="headerlink" title="3. 使用集合"></a>3. 使用集合</h2><p><code>cy.collection()</code> — 获取一个空集合</p>
<p>例如使用集合保存被点击过的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = cy.collection();</span><br><span class="line">cy.nodes().on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clickedNode = e.target;</span><br><span class="line"></span><br><span class="line">  collection = collection.union(clickedNode);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-使用getElementById-来根据id获取指定元素"><a href="#4-使用getElementById-来根据id获取指定元素" class="headerlink" title="4. 使用getElementById()来根据id获取指定元素"></a>4. 使用getElementById()来根据id获取指定元素</h2><p><code>cy.getElementById( id )</code>  参数为元素的id值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.getElementById(<span class="string">'j'</span>);</span><br><span class="line">或者使用下列方式</span><br><span class="line">cy.getElementById(<span class="string">'j'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-元素匹配"><a href="#5-元素匹配" class="headerlink" title="5. 元素匹配"></a>5. 元素匹配</h2><h3 id="5-1-cy-selector"><a href="#5-1-cy-selector" class="headerlink" title="5.1 cy.$( selector )"></a>5.1 cy.$( selector )</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.$(<span class="string">"#a"</span>)  <span class="comment">// 获取id值为a的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-cy-elements-selector"><a href="#5-2-cy-elements-selector" class="headerlink" title="5.2 cy.elements( selector )"></a>5.2 cy.elements( selector )</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.elements(<span class="string">'[weight &gt; 50]'</span>);  <span class="comment">// 获取权重大于50的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-cy-nodes-selector"><a href="#5-3-cy-nodes-selector" class="headerlink" title="5.3 cy.nodes( selector )"></a>5.3 cy.nodes( selector )</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.nodes(<span class="string">'[weight &gt; 50]'</span>);   <span class="comment">// 获取权重大于50的节点</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-cy-edges-selector"><a href="#5-4-cy-edges-selector" class="headerlink" title="5.4 cy.edges( selector )"></a>5.4 cy.edges( selector )</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cy.edges(<span class="string">'[source = "j"]'</span>); <span class="comment">// 获取源点为id为j的节点的边</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-cy-filter-selector"><a href="#5-5-cy-filter-selector" class="headerlink" title="5.5 cy.filter( selector )"></a>5.5 cy.filter( selector )</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cy.filter(<span class="string">'[weight &gt; 50]'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-6-cy-filter-ele-i-eles-gt"><a href="#5-6-cy-filter-ele-i-eles-gt" class="headerlink" title="5.6 cy.filter( ( ele, i, eles ) =&gt; {} )"></a>5.6 cy.filter( ( ele, i, eles ) =&gt; {} )</h3><p>使用回调函数的方式实现上面用选择器匹配的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cy.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element, i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element.isNode() &amp;&amp; element.data(<span class="string">'weight'</span>) &gt; <span class="number">50</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-批量操作"><a href="#6-批量操作" class="headerlink" title="6. 批量操作"></a>6. 批量操作</h2><p>这允许在不触发多个样式计算或多个元素重绘的情况下操作元素。此函数对于同时对元素进行许多更改非常有用。当指定的回调函数完成时，只有需要它的元素才会更新它们的样式，而呈现器最多只会重新绘制一次。</p>
<p>包含下列三个API:</p>
<ul>
<li>cy.batch(() =&gt; { // do something })</li>
<li>cy.startBatch()  — 手动开始批量操作,主要用于异步操作</li>
<li>cy.endBatch() – 手动结束批量操作，主要用于异步操作</li>
</ul>
<h2 id="6-1-不使用批处理涉及到对元素的多个样式更新"><a href="#6-1-不使用批处理涉及到对元素的多个样式更新" class="headerlink" title="6.1 不使用批处理涉及到对元素的多个样式更新"></a>6.1 不使用批处理涉及到对元素的多个样式更新</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.$(<span class="string">'#j'</span>)</span><br><span class="line">  .data(<span class="string">'weight'</span>, <span class="string">'70'</span>)   <span class="comment">// 样式更新</span></span><br><span class="line">  .addClass(<span class="string">'funny'</span>)      <span class="comment">// 样式更新</span></span><br><span class="line">  .removeClass(<span class="string">'serious'</span>) <span class="comment">// 样式更新</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 至少一次，至多3次重绘，这取决于上述操作执行的速度</span></span><br></pre></td></tr></table></figure>

<p>这对于少数元素的样式更新没有问题，但是如果对于大批量的元素进行上述操作，会造成很多冗余的重绘，导致性能问题，下面用批处理来解决上述问题</p>
<h2 id="6-2-批处理中对元素的多样式更新"><a href="#6-2-批处理中对元素的多样式更新" class="headerlink" title="6.2 批处理中对元素的多样式更新"></a>6.2 批处理中对元素的多样式更新</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.batch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  cy.$(<span class="string">'#j'</span>)</span><br><span class="line">    .data(<span class="string">'weight'</span>, <span class="string">'70'</span>)</span><br><span class="line">    .addClass(<span class="string">'funny'</span>)</span><br><span class="line">    .removeClass(<span class="string">'serious'</span>)</span><br><span class="line">  ;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-2-如果采取手动控制批处理的开始与结束"><a href="#6-2-如果采取手动控制批处理的开始与结束" class="headerlink" title="6.2 如果采取手动控制批处理的开始与结束"></a>6.2 如果采取手动控制批处理的开始与结束</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cy.startBatch();</span><br><span class="line"></span><br><span class="line">cy.$(<span class="string">'#j'</span>)</span><br><span class="line">  .data(<span class="string">'weight'</span>, <span class="string">'70'</span>)</span><br><span class="line">  .addClass(<span class="string">'funny'</span>)</span><br><span class="line">  .removeClass(<span class="string">'serious'</span>)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">cy.endBatch();</span><br></pre></td></tr></table></figure>

<h2 id="7-元素的挂载与卸载"><a href="#7-元素的挂载与卸载" class="headerlink" title="7. 元素的挂载与卸载"></a>7. 元素的挂载与卸载</h2><p><code>cy.mount( container )</code> container参数为挂载的dom元素</p>
<p><code>cy.mount( container )</code> 移除container dom元素上挂载的cytoscape实例</p>
<h2 id="8-元素的销毁"><a href="#8-元素的销毁" class="headerlink" title="8. 元素的销毁"></a>8. 元素的销毁</h2><p>销毁<strong>cytoscape</strong>实例</p>
<p><code>cy.destroy()</code></p>
<p>可以使用cy.cy.destroy()来判断<strong>cytoscape</strong>实例是否已经被销毁</p>
<h1 id="三-数据绑定"><a href="#三-数据绑定" class="headerlink" title="三. 数据绑定"></a>三. 数据绑定</h1><h2 id="3-1-图数据绑定及获取"><a href="#3-1-图数据绑定及获取" class="headerlink" title="3.1 图数据绑定及获取"></a>3.1 图数据绑定及获取</h2><ul>
<li><p>cy.data() — 获取整个图的数据对象</p>
</li>
<li><p>cy.data( name ) — 获取指定字段名的数据</p>
</li>
<li><p>cy.data( name, value )   — 绑定键为name,值为value的数据</p>
</li>
<li><p>cy.data( obj ) — 通过对象更新途中的多个字段值数据</p>
</li>
</ul>
<h2 id="3-2-图数据删除"><a href="#3-2-图数据删除" class="headerlink" title="3.2 图数据删除"></a>3.2 图数据删除</h2><ul>
<li>cy.removeData() — 删除图的所有可变数据</li>
<li>cy.removeData(names) — 删除指定字段名的数据, names参数为要删除的字段的空格分隔列表</li>
</ul>
<h2 id="3-3-图数据暂存"><a href="#3-3-图数据暂存" class="headerlink" title="3.3 图数据暂存"></a>3.3 图数据暂存</h2><h3 id="3-3-1-cy-scratch"><a href="#3-3-1-cy-scratch" class="headerlink" title="3.3.1 cy.scratch()"></a>3.3.1 <code>cy.scratch()</code></h3><p>设置或获取暂存数据，其中可以存储临时数据或非json数据。应用程序级别的暂存数据应该使用带下划线前缀的名称空间，如’_foo’</p>
<ul>
<li><p>cy.scratch()  — 获取图所有名称空间下的暂存数据</p>
</li>
<li><p>cy.scratch( namespace ) — 获取指定名称空间下的暂存数据</p>
</li>
<li><p>cy.scratch( namespace, value )  — 添加名称空间namespace，并设置暂存值为value</p>
<h3 id="3-3-2-cy-removeScratch"><a href="#3-3-2-cy-removeScratch" class="headerlink" title="3.3.2 cy.removeScratch()"></a>3.3.2 cy.removeScratch()</h3></li>
</ul>
<p>移除图的暂存数据</p>
<p><code>cy.removeScratch( namespace )</code> 移除指定命名空间下的暂存数据, 不添加命名空间参数则会清空所有图相关的暂存数据</p>
<h1 id="四-事件监听"><a href="#四-事件监听" class="headerlink" title="四. 事件监听"></a>四. 事件监听</h1><h2 id="4-1-事件普通绑定方式cy-on"><a href="#4-1-事件普通绑定方式cy-on" class="headerlink" title="4.1 事件普通绑定方式cy.on()"></a>4.1 事件普通绑定方式cy.on()</h2><p>别名： cy.bind()<code>,</code>cy.listen()<code>,</code>cy.addListener()</p>
<p>事件的绑定方式如下:</p>
<p>cy.on( events [, selector], function(event) )</p>
<ul>
<li><p><a href="https://js.cytoscape.org/#events" target="_blank" rel="noopener">events</a></p>
<p><strong>空格分隔的时间名列表</strong></p>
</li>
<li><p><a href="https://js.cytoscape.org/#selectors" target="_blank" rel="noopener">selector</a></p>
<p>可选参数, 如果不传递，事件将被绑定在整个图实例上</p>
<p><strong>选择器，匹配到的元素将被绑定事件</strong></p>
</li>
<li><p>function(event)</p>
<p><strong>事件监听的回调函数</strong></p>
<ul>
<li><p><a href="https://js.cytoscape.org/#events" target="_blank" rel="noopener">event</a></p>
<p><strong>监听到的事件对象</strong></p>
</li>
</ul>
</li>
</ul>
<p>一个实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.on(<span class="string">'tap'</span>, <span class="string">'node'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = evt.target;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'tapped '</span> + node.id() );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下列代码没有指定选择器，则事件被绑定到了整个图实例上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// target holds a reference to the originator</span></span><br><span class="line">  <span class="comment">// of the event (core or element)</span></span><br><span class="line">  <span class="keyword">var</span> evtTarget = event.target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( evtTarget === cy )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tap on background'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tap on some element'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-可以获取Promise对象的事件绑定方式cy-promiseOn"><a href="#4-2-可以获取Promise对象的事件绑定方式cy-promiseOn" class="headerlink" title="4.2 可以获取Promise对象的事件绑定方式cy.promiseOn()"></a>4.2 可以获取Promise对象的事件绑定方式cy.promiseOn()</h2><p>别名: pon</p>
<p>事件触发后将获取到一个成功态的的Promise对象<br><code>cy.promiseOn( events [, selector] )</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.pon(<span class="string">'tap'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"> event </span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tap promise fulfilled'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-只生效一次的事件监听cy-one"><a href="#4-3-只生效一次的事件监听cy-one" class="headerlink" title="4.3 只生效一次的事件监听cy.one()"></a>4.3 只生效一次的事件监听cy.one()</h3><p>绑定的事件只响应一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.one(<span class="string">'tap'</span>, <span class="string">'node'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tap!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cy.$(<span class="string">'node'</span>).eq(<span class="number">0</span>).trigger(<span class="string">'tap'</span>); <span class="comment">// 触发事件，事件不再响应</span></span><br><span class="line">cy.$(<span class="string">'node'</span>).eq(<span class="number">1</span>).trigger(<span class="string">'tap'</span>); <span class="comment">// 事件不再响应</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-事件监听的移除"><a href="#4-4-事件监听的移除" class="headerlink" title="4.4 事件监听的移除"></a>4.4 事件监听的移除</h2><h3 id="4-4-1-cy-removeListener"><a href="#4-4-1-cy-removeListener" class="headerlink" title="4.4.1 cy.removeListener()"></a>4.4.1 cy.removeListener()</h3><p>cy.removeListener( events [, selector] [, handler] )</p>
<ul>
<li><p><a href="https://js.cytoscape.org/#events" target="_blank" rel="noopener">events</a></p>
<p>空格分隔的事件名列表</p>
</li>
<li><p><a href="https://js.cytoscape.org/#selectors" target="_blank" rel="noopener">selector</a></p>
<p> 选择器，匹配到的元素将进行事件移除，可选参数，如果不指定，则移除对象为图实例 </p>
</li>
<li><p>handler<br>可选参数，可指定移除指定的处理器函数对象关联的事件，不指定则移除所有指定类型的事件处理器监听 </p>
</li>
</ul>
<p>如下：<br>实例1: 不指定具体的事件处理器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove all tap listener handlers, including the one above</span></span><br><span class="line">cy.removeListener(<span class="string">'tap'</span>);</span><br></pre></td></tr></table></figure>

<p>实例2: 针对具体的事件处理器进行事件绑定和解绑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'called handler'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">cy.on(<span class="string">'tap'</span>, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'called other handler'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">cy.on(<span class="string">'tap'</span>, otherHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// just remove handler</span></span><br><span class="line">cy.removeListener(<span class="string">'tap'</span>, handler);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-移除图实例所有事件监听"><a href="#4-4-2-移除图实例所有事件监听" class="headerlink" title="4.4.2 移除图实例所有事件监听"></a>4.4.2 移除图实例所有事件监听</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.removeAllListeners()</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-事件的主动触发"><a href="#4-4-3-事件的主动触发" class="headerlink" title="4.4.3 事件的主动触发"></a>4.4.3 事件的主动触发</h3><p>cy.emit()， 别名cy.trigger()</p>
<p><code>cy.emit( events [, extraParams] )</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt, f, b</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tap'</span>, f, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cy.emit(<span class="string">'tap'</span>, [<span class="string">'foo'</span>, <span class="string">'bar'</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4-图准备就绪事件的监听"><a href="#4-4-4-图准备就绪事件的监听" class="headerlink" title="4.4.4 图准备就绪事件的监听"></a>4.4.4 图准备就绪事件的监听</h3><p><code>cy.ready()</code></p>
<p>一旦图形准备好(即初始数据加载和初始布局完成)，就运行一个回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.ready(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-视口操作"><a href="#五-视口操作" class="headerlink" title="五. 视口操作"></a>五. 视口操作</h1><h2 id="5-1-使用cy-container-获取图实例的dom容器"><a href="#5-1-使用cy-container-获取图实例的dom容器" class="headerlink" title="5.1 使用cy.container()获取图实例的dom容器"></a>5.1 使用cy.container()获取图实例的dom容器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.container()</span><br></pre></td></tr></table></figure>



<h2 id="5-2-居中操作cy-center"><a href="#5-2-居中操作cy-center" class="headerlink" title="5.2 居中操作cy.center()"></a>5.2 居中操作cy.center()</h2><ul>
<li>cy.center() — 以图中所有元素为中心进行居中。</li>
<li>cy.center( eles ) — 以指定元素为中心进行居中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = cy.$(<span class="string">'#j'</span>);</span><br><span class="line">cy.center( j );</span><br></pre></td></tr></table></figure>

<p>5.3 自适应</p>
<p>cy.fit() — 自动调整图的平移距离和缩放级别以达到正好容纳元素的效果</p>
<ul>
<li>cy.fit() — 调整视口以容纳图中的所有元素</li>
<li>cy.fit( [eles], [ padding]) — 调整视口以容纳指定元素，并可以指定padding</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.fit( cy.$(<span class="string">'#j, #e'</span>) );</span><br></pre></td></tr></table></figure>

<h2 id="5-3-重置图的默认缩放级别和平移位置"><a href="#5-3-重置图的默认缩放级别和平移位置" class="headerlink" title="5.3 重置图的默认缩放级别和平移位置"></a>5.3 重置图的默认缩放级别和平移位置</h2><p>cy.reset() </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  cy.pan(&#123; <span class="attr">x</span>: <span class="number">50</span>, <span class="attr">y</span>: <span class="number">-100</span> &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  cy.zoom( <span class="number">2</span> );</span><br><span class="line">&#125;, <span class="number">2000</span> );</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  cy.reset();</span><br><span class="line">&#125;, <span class="number">3000</span> );</span><br></pre></td></tr></table></figure>

<h2 id="5-4-获取或设置图形的平移位置。"><a href="#5-4-获取或设置图形的平移位置。" class="headerlink" title="5.4 获取或设置图形的平移位置。"></a>5.4 获取或设置图形的平移位置。</h2><ul>
<li>cy.pan() — 获取当前平移位置</li>
<li>cy.pan( renderedPosition )  — eg: { x: 100, y: 200 }</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.pan(&#123;</span><br><span class="line">  x: <span class="number">100</span>,</span><br><span class="line">  y: <span class="number">100</span> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( cy.pan() );</span><br></pre></td></tr></table></figure>

<h2 id="5-5-对于当前位置相对地平移图形"><a href="#5-5-对于当前位置相对地平移图形" class="headerlink" title="5.5 对于当前位置相对地平移图形"></a>5.5 对于当前位置相对地平移图形</h2><p><code>cy.panBy( renderedPosition )</code></p>
<p>如将图形向右平移100像素:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.panBy(&#123;</span><br><span class="line">  x: <span class="number">100</span>,</span><br><span class="line">  y: <span class="number">0</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-6-设置是否可以支持平移操作"><a href="#5-6-设置是否可以支持平移操作" class="headerlink" title="5.6 设置是否可以支持平移操作"></a>5.6 设置是否可以支持平移操作</h2><ul>
<li>cy.panningEnabled()  — 获取是否当前图实例支持进行平移操作</li>
<li>cy.panningEnabled( bool ) — 设置当前图实例是否支持进行平移操作</li>
<li>cy.userPanningEnabled()  —  获取是否启用了用户平移(用户的拖拽操作)。</li>
<li>cy.userPanningEnabled( bool ) — 设置是否启用用户平移</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.panningEnabled( bool )</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.userPanningEnabled( <span class="literal">true</span> );</span><br></pre></td></tr></table></figure>

<h2 id="5-7-指定缩放级别"><a href="#5-7-指定缩放级别" class="headerlink" title="5.7 指定缩放级别"></a>5.7 指定缩放级别</h2><h3 id="5-7-1-cy-zoom"><a href="#5-7-1-cy-zoom" class="headerlink" title="5.7.1 cy.zoom()"></a>5.7.1 cy.zoom()</h3><ul>
<li><p>cy.zoom() 获取缩放级别</p>
</li>
<li><p>cy.zoom( level )  设置缩放级别</p>
</li>
<li><p>cy.zoom( options )  <strong>options</strong> The options for zooming.</p>
<ul>
<li><p>level</p>
<p>缩放级别</p>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">position</a></p>
<p>要缩放的位置</p>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">renderedPosition</a></p>
<p>缩放到的位置</p>
<p>position和renderedPosition不要同时指定</p>
</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.zoom(&#123;</span><br><span class="line">  level: <span class="number">1.5</span>,</span><br><span class="line">  position: cy.getElementById(<span class="string">'a'</span>).position()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>cy.minZoom() —  获取最小缩放级别</p>
</li>
<li><p>cy.maxZoom() –  设置最小缩放级别</p>
</li>
<li><p>cy.viewport( zoom, pan ) — 通过一个函数来设置缩放级别和平移位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.viewport(&#123;</span><br><span class="line">  zoom: <span class="number">2</span>,</span><br><span class="line">  pan: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5-7-2-cy-zoomingEnabled"><a href="#5-7-2-cy-zoomingEnabled" class="headerlink" title="5.7.2 cy.zoomingEnabled()"></a>5.7.2 cy.zoomingEnabled()</h3><ul>
<li><p>cy.zoomingEnabled() — 获取是否支持缩放</p>
</li>
<li><p>cy.zoomingEnabled(bool)  — 设置是否支持缩放</p>
</li>
<li><p>userZoomingEnabled() — 获取是否支持用户使用鼠标等交互方式进行缩放</p>
</li>
<li><p>userZoomingEnabled( bool ) — 设置是否支持用户使用鼠标等交互方式进行缩放</p>
</li>
</ul>
<h2 id="5-8-boxSelectionEnabled"><a href="#5-8-boxSelectionEnabled" class="headerlink" title="5.8 boxSelectionEnabled"></a>5.8 boxSelectionEnabled</h2><p>获取或设置是否启用了框选择。如果同时启用平移，用户必须按住shift、control、alt或command中的一个来启动框选择</p>
<ul>
<li>cy.boxSelectionEnabled() — 获取是否支持扩选</li>
<li>cy.boxSelectionEnabled( bool ) — 设置是否支持扩选</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.boxSelectionEnabled( <span class="literal">true</span> );</span><br></pre></td></tr></table></figure>

<h2 id="5-9-cy-selectionType"><a href="#5-9-cy-selectionType" class="headerlink" title="5.9 cy.selectionType()"></a>5.9 cy.selectionType()</h2><p>设置或设置选择类型。“single”选择类型是默认的，点击一个元素将选择该元素并取消选择前面的元素。</p>
<p>还可以指定为追加类型”additive”, 可逐次选中多个元素</p>
<ul>
<li>cy.selectionType()</li>
<li>cy.selectionType( type ) “single”(default)或者”additive”</li>
</ul>
<h2 id="5-10-获取视口宽度和高度"><a href="#5-10-获取视口宽度和高度" class="headerlink" title="5.10 获取视口宽度和高度"></a>5.10 获取视口宽度和高度</h2><ul>
<li>cy.width()</li>
<li>cy.height()</li>
<li>cy.extend()<br>获取viewport的范围，模型坐标中的一个边界框让您知道在viewport中哪些模型位置是可见的。</li>
</ul>
<p>![image-20200418201051078](/Users/liwei/Library/Application Support/typora-user-images/image-20200418201051078.png)</p>
<h1 id="5-11-cy-autolock"><a href="#5-11-cy-autolock" class="headerlink" title="5.11 cy.autolock()"></a>5.11 cy.autolock()</h1><p>获取或设置节点是否被自动锁定(即，如果为真，则无论节点的状态如何都被锁定)</p>
<ul>
<li>cy.autolock() — 获取图节点是否自动锁定</li>
<li>cy.autolock( bool ) — 设置图节点是否自动锁定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.autolock( bool )</span><br></pre></td></tr></table></figure>

<h2 id="5-12-设置节点是否自动取消抓取autoungrabify"><a href="#5-12-设置节点是否自动取消抓取autoungrabify" class="headerlink" title="5.12 设置节点是否自动取消抓取autoungrabify"></a>5.12 设置节点是否自动取消抓取autoungrabify</h2><ul>
<li>cy.autoungrabify()  — 获取是否自动取消抓取被启用</li>
<li>cy.autoungrabify( bool ) —  设置是否启动自动取消抓取</li>
</ul>
<h2 id="5-13-获取或设置节点是否自动取消选择"><a href="#5-13-获取或设置节点是否自动取消选择" class="headerlink" title="5.13 获取或设置节点是否自动取消选择"></a>5.13 获取或设置节点是否自动取消选择</h2><ul>
<li>cy.autounselectify()</li>
<li>cy.autounselectify( bool )</li>
</ul>
<h2 id="5-14-强制渲染器重新计算视口边界"><a href="#5-14-强制渲染器重新计算视口边界" class="headerlink" title="5.14 强制渲染器重新计算视口边界"></a>5.14 强制渲染器重新计算视口边界</h2><p><code>cy.resize()</code></p>
<p>别名: <code>cy.invalidateDimensions()</code></p>
<h1 id="六-动画Animation"><a href="#六-动画Animation" class="headerlink" title="六. 动画Animation"></a>六. 动画Animation</h1><h2 id="6-1-动画执行cy-animate"><a href="#6-1-动画执行cy-animate" class="headerlink" title="6.1 动画执行cy.animate()"></a>6.1 动画执行cy.animate()</h2><ul>
<li><p>cy.animated()  判断是否有动画在进行</p>
</li>
<li><p>cy.animate( options ) 操纵视口执行动画<strong>options</strong> An object containing the details of the animation.</p>
<ul>
<li><p>zoom</p>
<p>一个缩放级别(数字)或一个缩放配置对象。</p>
</li>
<li><ul>
<li><p>level </p>
<p>要使用的缩放级别。</p>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">position</a> </p>
<p>缩放发生的位置。这将自动修改pan，使指定的模型位置在缩放期间保持在viewport区段中的相同位置。</p>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">renderedPosition</a></p>
<p>关于缩放发生的渲染位置，作为使用模型位置的替代。这将自动修改pan，使模型位置(与动画开始时呈现的位置相对应)在缩放期间保持在viewport区段中的相同位置。</p>
</li>
</ul>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">pan</a></p>
<p>图形将被移动到的平移位置。</p>
</li>
<li><p><a href="https://js.cytoscape.org/#notation/position" target="_blank" rel="noopener">panBy</a></p>
<p>图形将被移动到的相对平移位置。</p>
</li>
<li><p>fit<br>  一个包含图自动调整以适应对应元素的参数对象</p>
</li>
<li><ul>
<li><p><a href="https://js.cytoscape.org/#collection" target="_blank" rel="noopener">eles</a></p>
<p>视口将进行调整以容纳对应元素</p>
</li>
<li><p>padding</p>
<p>Padding to use with the fitting (default <code>0</code>).</p>
</li>
</ul>
</li>
<li><p>center</p>
<p>一个对象，该对象包含将从其中对图形进行动画处理的居中选项。</p>
</li>
<li><ul>
<li><p><a href="https://js.cytoscape.org/#collection" target="_blank" rel="noopener">eles</a></p>
<p>将视口置于中心的elements或选择器</p>
</li>
</ul>
</li>
<li><p>duration</p>
<p>动画执行时间</p>
</li>
<li><p>queue</p>
<p>一个布尔值，指示是否对动画进行排队(默认为“true”)。核心上排队的动画按顺序运行，直到队列为空。</p>
</li>
<li><p><a href="https://js.cytoscape.org/#style/transition-animation" target="_blank" rel="noopener">easing</a></p>
<p>指定<a href="https://js.cytoscape.org/#style/transition-animation" target="_blank" rel="noopener"> transition- time- function </a>类型，以形成动画的进度曲线。</p>
</li>
<li><p>complete<br>动画执行完成时候执行的回调函数</p>
</li>
<li><p>step</p>
<p>动画步骤调用回调。</p>
</li>
</ul>
<p>eg:</p>
<ol>
<li>操纵pan和zoom</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.animate(&#123;</span><br><span class="line">  pan: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;,</span><br><span class="line">  zoom: <span class="number">2</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  duration: <span class="number">1000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>视口自适应容纳元素</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.animate(&#123;</span><br><span class="line">  fit: &#123;</span><br><span class="line">    eles: j,</span><br><span class="line">    padding: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  duration: <span class="number">1000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="6-2-动画获取cy-animation"><a href="#6-2-动画获取cy-animation" class="headerlink" title="6.2 动画获取cy.animation()"></a>6.2 动画获取cy.animation()</h2><p>获取视口的动画。</p>
<p><code>cy.animation( options )</code></p>
<p>options参数同上, 该函数用来获取指定配置信息的动画</p>
<h2 id="6-3-为动画添加延迟cy-delay"><a href="#6-3-为动画添加延迟cy-delay" class="headerlink" title="6.3 为动画添加延迟cy.delay()"></a>6.3 为动画添加延迟cy.delay()</h2><p><code>cy.delay( duration, complete )</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy</span><br><span class="line">  .animate(&#123;</span><br><span class="line">    fit: &#123; <span class="attr">eles</span>: <span class="string">'#j'</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  .delay(<span class="number">1000</span>)   <span class="comment">// 1s</span></span><br><span class="line"></span><br><span class="line">  .animate(&#123;</span><br><span class="line">    fit: &#123; <span class="attr">eles</span>: <span class="string">'#e'</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-获取视口的延迟动画cy-delayAnimation"><a href="#6-4-获取视口的延迟动画cy-delayAnimation" class="headerlink" title="6.4 获取视口的延迟动画cy.delayAnimation()"></a>6.4 获取视口的延迟动画cy.delayAnimation()</h2><p><code>cy.delayAnimation( duration )</code> — duration为延迟时间</p>
<h2 id="6-5-停止动画"><a href="#6-5-停止动画" class="headerlink" title="6.5 停止动画"></a>6.5 停止动画</h2><p><code>stop(clearQueue, jumpToEnd)</code><br>clearQueue是一个布尔值(默认为false)，表示动画队列是否应该被清空。<br>jumpToEnd一个布尔值(默认为false)，指示当前运行的动画是否应该跳转到它们的末端，而不是中途停止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.animate(&#123;</span><br><span class="line">  fit: &#123; <span class="attr">eles</span>: <span class="string">'#j'</span> &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">duration</span>: <span class="number">2000</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop in the middle</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  cy.stop();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="6-6-清空动画队列cy-clearQueue"><a href="#6-6-清空动画队列cy-clearQueue" class="headerlink" title="6.6 清空动画队列cy.clearQueue()"></a>6.6 清空动画队列cy.clearQueue()</h2><p>删除viewport中所有排队的动画。</p>
<h1 id="七-布局-Layout"><a href="#七-布局-Layout" class="headerlink" title="七.布局 Layout"></a>七.布局 Layout</h1><p><code>cy.layout()</code></p>
<p>别名: <code>cy.createLayout()</code>, <code>cy.makeLayout()</code></p>
<p>获取一个新的布局，它可以用于用算法在图中定位节点。</p>
<p>cy.layout( options )</p>
<ul>
<li>options  布局参数, options.name必须指定</li>
</ul>
<p>cy.layout()会返回一个布局实例，可以基于这个实例进行其他操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> layout = cy.layout(&#123;</span><br><span class="line">  name: <span class="string">'random'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">layout.run();</span><br></pre></td></tr></table></figure>

<h1 id="八-样式Style"><a href="#八-样式Style" class="headerlink" title="八. 样式Style"></a>八. 样式Style</h1><p><code>cy.style()</code></p>
<ul>
<li>cy.style() — 获取当前图的样式对象</li>
<li>cy.style( stylesheet ) — 为图指定新的样式对象<br><strong><a href="https://js.cytoscape.org/#style" target="_blank" rel="noopener">stylesheet</a></strong> 参数可以是一个 <code>cytoscape.stylesheet()</code> 对象, 一个样式对象的字符串, 也可以指定为JSON格式的字符串(格式参考[options.style`](<a href="https://js.cytoscape.org/#style" target="_blank" rel="noopener">https://js.cytoscape.org/#style</a>))</li>
</ul>
<h2 id="8-1-样式字符串"><a href="#8-1-样式字符串" class="headerlink" title="8.1 样式字符串"></a>8.1 样式字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cytoscape(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.getElementById(<span class="string">'cy'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  style: <span class="string">'node &#123; background-color: green; &#125;'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// , ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-2-普通JSON格式"><a href="#8-2-普通JSON格式" class="headerlink" title="8.2 普通JSON格式"></a>8.2 普通JSON格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cytoscape(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.getElementById(<span class="string">'cy'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  style: [</span><br><span class="line">    &#123;</span><br><span class="line">      selector: <span class="string">'node'</span>,</span><br><span class="line">      style: &#123;</span><br><span class="line">        <span class="string">'background-color'</span>: <span class="string">'red'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// , ...</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// , ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-3-cytoscape-stylesheet-用法"><a href="#8-3-cytoscape-stylesheet-用法" class="headerlink" title="8.3 cytoscape.stylesheet()`用法"></a>8.3 cytoscape.stylesheet()`用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cytoscape(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.getElementById(<span class="string">'cy'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  style: cytoscape.stylesheet()</span><br><span class="line">    .selector(<span class="string">'node'</span>)</span><br><span class="line">      .style(&#123;</span><br><span class="line">        <span class="string">'background-color'</span>: <span class="string">'blue'</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// , ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-4-根据元素data进行样式绘制"><a href="#8-4-根据元素data进行样式绘制" class="headerlink" title="8.4 根据元素data进行样式绘制"></a>8.4 根据元素data进行样式绘制</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cytoscape(&#123;</span><br><span class="line">  container: <span class="built_in">document</span>.getElementById(<span class="string">'cy'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  style: cytoscape.stylesheet()</span><br><span class="line">    .selector(<span class="string">'node'</span>)</span><br><span class="line">      .style(&#123;</span><br><span class="line">        <span class="string">'background-color'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> ele </span>)</span>&#123; <span class="keyword">return</span> ele.data(<span class="string">'bg'</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// which works the same as</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 'background-color': 'data(bg)'</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// , ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-5-设置一个全新的样式"><a href="#8-5-设置一个全新的样式" class="headerlink" title="8.5 设置一个全新的样式"></a>8.5 设置一个全新的样式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.style()</span><br><span class="line">  .clear() <span class="comment">//清除默认样式而应用一个全新的样式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义节点样式</span></span><br><span class="line">  .selector(<span class="string">'node'</span>)</span><br><span class="line">    .style(<span class="string">'background-color'</span>, <span class="string">'magenta'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义边样式</span></span><br><span class="line">  .selector(<span class="string">'edge'</span>)</span><br><span class="line">      .style(&#123;</span><br><span class="line">      <span class="string">'width'</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">'line-color'</span>: <span class="string">'yellow'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  .update() <span class="comment">// 显示声明样式更新代码的结束，通知cytoscape更新元素样式</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="8-6-从样式字符串创建style"><a href="#8-6-从样式字符串创建style" class="headerlink" title="8.6 从样式字符串创建style"></a>8.6 从样式字符串创建style</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.style()</span><br><span class="line">  .fromString(<span class="string">'node &#123; background-color: blue; &#125;'</span>)</span><br><span class="line"></span><br><span class="line">  .update() <span class="comment">// update the elements in the graph with the new style</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="8-7-获取当前样式的JSON对象"><a href="#8-7-获取当前样式的JSON对象" class="headerlink" title="8.7 获取当前样式的JSON对象"></a>8.7 获取当前样式的JSON对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> styleJson = cy.style().json();</span><br><span class="line"><span class="keyword">var</span> serializedJson = <span class="built_in">JSON</span>.stringify( styleJson );</span><br></pre></td></tr></table></figure>

<h1 id="九-图的导出"><a href="#九-图的导出" class="headerlink" title="九. 图的导出"></a>九. 图的导出</h1><h2 id="9-1-将当前图形视图导出为PNG图像"><a href="#9-1-将当前图形视图导出为PNG图像" class="headerlink" title="9.1 将当前图形视图导出为PNG图像"></a>9.1 将当前图形视图导出为PNG图像</h2><p>cy.png( options )</p>
<ul>
<li><p>options</p>
<p>导出参数设置</p>
<ul>
<li><p>output</p>
<p>输出应该是“base64uri”(默认)、“base64”、“blob”还是“blob-promise”(返回解析为blob的Promise)。</p>
</li>
<li><p>bg</p>
<p>图像的背景颜色(默认为白色)。</p>
</li>
<li><p>full</p>
<p>是导出当前的viewport视图(“false”，默认)还是导出整个图(“true”)。</p>
</li>
<li><p>scale </p>
<p>此值指定一个正数，该正数缩放生成的图像的大小。</p>
</li>
<li><p>maxWidth</p>
<p> 指定与“maxHeight”组合的自动比例，以便生成的图像宽度不超过“maxWidth”。</p>
</li>
<li><p>maxHeight</p>
<p> 指定与“maxWidth”组合的自动比例，以便生成的图像不高于“maxHeight”。</p>
</li>
</ul>
</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> png64 = cy.png();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put the png data in an img tag</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#png-eg'</span>).setAttribute(<span class="string">'src'</span>, png64);</span><br></pre></td></tr></table></figure>

<h2 id="9-2-导出图为jpg"><a href="#9-2-导出图为jpg" class="headerlink" title="9.2 导出图为jpg"></a>9.2 导出图为jpg</h2><p><code>cy.jpg()</code></p>
<p>cy.jpg( options )</p>
<ul>
<li><p>options</p>
<p>导出参数对象</p>
<ul>
<li><p>output</p>
<p>输出应该是“base64uri”(默认)、“base64”、“blob”还是“blob-promise”(返回解析为blob的Promise)。</p>
</li>
<li><p>bg</p>
<p>图像的背景颜色(默认为白色)。</p>
</li>
<li><p>full</p>
<p>是导出当前的viewport视图(“false”，默认)还是导出整个图(“true”)。</p>
</li>
<li><p>scale</p>
<p>此值指定一个正数，该正数缩放生成的图像的大小。</p>
</li>
<li><p>maxWidth</p>
<p>指定与“maxHeight”组合的自动比例，以便生成的图像宽度不超过“maxWidth”。</p>
</li>
<li><p>maxHeight</p>
<p>指定与“maxWidth”组合的自动比例，以便生成的图像不高于“maxHeight”。</p>
</li>
<li><p>quality</p>
<p>指定从’ 0 ‘(低质量，低文件大小)到’ 1 ‘(高质量，高文件大小)的图像质量。如果没有设置，则使用浏览器的默认质量值。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jpg64 = cy.jpg();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put the png data in an img tag</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#jpg-eg'</span>).setAttribute(<span class="string">'src'</span>, jpg64);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="9-3-导出JSON"><a href="#9-3-导出JSON" class="headerlink" title="9.3 导出JSON"></a>9.3 导出JSON</h2><p><code>cy.json()</code></p>
<p>以初始化时使用的相同JSON格式导入或导出图数据。</p>
<p>cy.json( flatEles )</p>
<ul>
<li><p>flatEles</p>
<p>resulant JSON是否应该将元素包含为平面数组(‘ true ‘)或两个按组键控的数组(‘ false ‘，默认)。</p>
</li>
</ul>
<p>cy.json( cyJson )</p>
<p>将图形作为JSON导入，只更新指定的字段。</p>
<ul>
<li><p><a href="https://js.cytoscape.org/#core/initialisation" target="_blank" rel="noopener">cyJson</a></p>
<p>具有与应该更改的状态对应的字段的对象。</p>
</li>
</ul>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cy.json(&#123;</span><br><span class="line">  zoom: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript教程</title>
    <url>/2020/05/16/2020-2020-05-16-Typescript%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-TypeScript的存在价值？"><a href="#一-TypeScript的存在价值？" class="headerlink" title="一.  TypeScript的存在价值？"></a>一.  TypeScript的存在价值？</h1><ol>
<li>为<strong>JavaScript</strong>提供类型系统，弥补其弱类型导致的问题</li>
<li><strong>TypeScript</strong>为<strong>JavaScript</strong>的超级，兼容所有<strong>JavaScript</strong>目前及未来所有的特性</li>
<li>编辑器基于类型系统可以给予开发者更多的智能提示</li>
<li>类型系统有利于提高代码的质量和可维护性,有利于代码重构</li>
<li>在编译期间捕获错误，避免很多以往在运行期才能发现的错误</li>
<li>可以在代码层面提供良好的文档</li>
<li>用<strong>TypeScript</strong>书写的代码最终会被编译成JavaScript代码</li>
<li>与<strong>Flow</strong>等类型检查系统相比，<strong>TypeScript</strong>的优势在于<strong>JavaScript</strong>即<strong>TypeScript</strong></li>
</ol>
<blockquote>
<p>TypeScript只是带有文档的JavaScript, TypeScript让JavaScript更美好, 学习JavaScript仍然是必要的</p>
</blockquote>
<h1 id="二-TypeScript支持的ES6语法"><a href="#二-TypeScript支持的ES6语法" class="headerlink" title="二.  TypeScript支持的ES6语法"></a>二.  TypeScript支持的ES6语法</h1><ol>
<li><strong>class</strong></li>
<li><strong>箭头函数</strong></li>
<li><strong>rest</strong>参数</li>
<li><strong>let</strong></li>
<li><strong>const</strong></li>
<li><strong>解构赋值</strong></li>
<li><strong>扩展运算符</strong></li>
<li><strong>for…of</strong></li>
<li>迭代<strong>iterator</strong></li>
<li>模板字符串<strong>``</strong></li>
<li><strong>Promise</strong></li>
<li><strong>generators</strong></li>
<li><strong>async/await</strong></li>
</ol>
<h1 id="三-TypeScript项目构成"><a href="#三-TypeScript项目构成" class="headerlink" title="三.  TypeScript项目构成"></a>三.  TypeScript项目构成</h1><h2 id="3-1-编译上下文"><a href="#3-1-编译上下文" class="headerlink" title="3.1 编译上下文"></a>3.1 编译上下文</h2><ul>
<li>通过tsc –init可以生成默认的配置文件</li>
<li>使用<strong>tsconfig.json</strong>里通过compilerOptions来指定<strong>TypeScript</strong>的编译选项</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// "incremental": true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                          <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                     <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                       /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                       /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */</span></span><br><span class="line">    <span class="comment">// "declaration": true,                   /* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                     /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="comment">// "outDir": "./",                        /* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// "rootDir": "./",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                        /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                 /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "strictNullChecks": true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="comment">// "strictPropertyInitialization": true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// "noImplicitThis": true,                /* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                  /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,                  <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// "allowUmdGlobalAccess": true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>  <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-声明空间"><a href="#3-2-声明空间" class="headerlink" title="3.2 声明空间"></a>3.2 声明空间</h2><h3 id="3-2-1-类型声明空间"><a href="#3-2-1-类型声明空间" class="headerlink" title="3.2.1 类型声明空间"></a>3.2.1 类型声明空间</h3><p>![image-20200414095213396](/Users/liwei/Library/Application Support/typora-user-images/image-20200414095213396.png)<br>我们不能把<strong>interface</strong>类型声明用作变量使用</p>
<h3 id="3-2-2-变量声明空间"><a href="#3-2-2-变量声明空间" class="headerlink" title="3.2.2 变量声明空间"></a>3.2.2 变量声明空间</h3><p>变量声明空间包含可以用作变量的内容，class Foo提供了一个类型Foo到类型声明空间，此外还提供了一个变量到Foo到变量声明空间，因此下列语句可以正常通过TypeScript类型检查</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Foo</span><br></pre></td></tr></table></figure>

<h2 id="3-3-模块"><a href="#3-3-模块" class="headerlink" title="3.3 模块"></a>3.3 模块</h2><h3 id="3-3-1-全局模块"><a href="#3-3-1-全局模块" class="headerlink" title="3.3.1 全局模块"></a>3.3.1 全局模块</h3><p>默认情况下的ts代码在全局命名空间中<br>![image-20200414100101482](/Users/liwei/Library/Application Support/typora-user-images/image-20200414100101482.png)</p>
<p>这样的做法是危险的</p>
<h3 id="3-3-2-文件模块"><a href="#3-3-2-文件模块" class="headerlink" title="3.3.2 文件模块"></a>3.3.2 文件模块</h3><p>如果再ts文件的根级别位置有import或者export则这个文件会创建一个本地作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-命名空间"><a href="#3-4-命名空间" class="headerlink" title="3.4 命名空间"></a>3.4 命名空间</h2><p>防止变量泄露到全局， TypeScript提供了namespace关键字来描述这种分组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> namespace Utils &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg: any</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Utils.log(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<p>namespace也是支持嵌套的</p>
<h1 id="四-类型系统"><a href="#四-类型系统" class="headerlink" title="四. 类型系统"></a>四. 类型系统</h1><h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><ol>
<li><p>基本注解</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了变量注解，函数参数注解和函数返回值注解</p>
</li>
<li><p>基本类型注解<br>JavaScript的基本数据类型适用于TypeScript的类型系统</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">const</span> boo: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> ss: Symbol = Symbol(<span class="string">'123'</span>)</span><br><span class="line"><span class="keyword">const</span> nn: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">const</span> nn1: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>数组注解<br>![image-20200414103730629](/Users/liwei/Library/Application Support/typora-user-images/image-20200414103730629.png)</p>
</li>
<li><p>接口注解<br>接口说明一种数据结构，是TypeScript的一个核心</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span>,</span><br><span class="line">    hobby?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p: People = &#123;</span><br><span class="line">    name: <span class="string">'david'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>内联类型注解</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p: &#123;</span><br><span class="line">    name: <span class="string">'david'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = &#123;</span><br><span class="line">    name: <span class="string">'david'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20200414104148235](/Users/liwei/Library/Application Support/typora-user-images/image-20200414104148235.png)</p>
</li>
<li><p>特殊类型注解(<strong>any</strong>, <strong>null</strong>, <strong>undefined</strong>, <strong>void</strong>)</p>
<ul>
<li><p><strong>any</strong><br>能够接收<strong>所有的类型</strong>（包括any类型），因此所有类型的数据都可以赋值给any类型的变量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aa: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">aa = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">aa = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line">aa =  <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>当使用any的使用意味着告诉编辑器不要做<strong>任何</strong>类型检查，要尽量减少any的使用w</p>
</li>
<li><p><strong>null</strong>和<strong>undefined</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="literal">null</span></span><br><span class="line">num = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>void</strong> </p>
<p>用来表示一个函数没有返回值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="7">
<li><p>泛型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse =  &lt;T&gt; (items: T[]): T[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> reverse = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = items.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">    reverse.push(items[index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> reverseArr = reverse(<span class="built_in">number</span>)</span><br><span class="line"><span class="built_in">console</span>.log(reverseArr)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>联合类型注解</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> format = (word: <span class="built_in">string</span>[] | <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> word === <span class="string">"string"</span>) &#123;</span><br><span class="line">    line = word;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = word.join(<span class="string">""</span>).trim();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> line;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(format([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]));</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="9">
<li><p>​    交叉类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> extend = &lt;T, U&gt;(first: T, second: U): T &amp; <span class="function"><span class="params">U</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = extend(&#123; a: <span class="string">"hello"</span> &#125;, &#123; b: <span class="string">"world"</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="10">
<li><p>元组类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">0</span>, <span class="string">''</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="11">
<li><p>类型别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> strOrNum = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; text: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Coordinates = [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Callback = <span class="function">(<span class="params">data: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-2-迁移JavaScript代码至TypeScript"><a href="#4-2-迁移JavaScript代码至TypeScript" class="headerlink" title="4.2. 迁移JavaScript代码至TypeScript"></a>4.2. 迁移JavaScript代码至TypeScript</h2><p>一般来说，将JavaScript代码迁移至TypeScript包括以下步骤:</p>
<ul>
<li><p>添加一个tsconfig.json文件。</p>
</li>
<li><p>把文件扩展名从.js改成.ts，开始使用any来减少错误。</p>
</li>
<li><p>开始在TypeScript中写代码，尽可能减少any的使用。</p>
</li>
<li><p>回到旧代码，开始添加类型注解，并修复已识别的错误。</p>
</li>
<li><p>为第三方JavaScript代码定义环境声明。(很多三方库的类型声明已经发布到了<a href="http://definitelytyped.org/" target="_blank" rel="noopener">DefinitelyTyped</a>中)</p>
</li>
<li><p>在TypeScript中可以允许导入任何文件，例如.css文件, 使用webpack的话只需要在globals.d.ts中添加如下代码 即可</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.css'</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  如果想使用HTML模板，如在Angular， 可以这样做</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.html'</span><br></pre></td></tr></table></figure>

<h2 id="4-3-types"><a href="#4-3-types" class="headerlink" title="4.3. @types"></a>4.3. @types</h2><p>毫无疑问，类型是TypeScript最大的优势之一，社区已经记录了将近90%的顶级JavaScript项目。这意味着，我们可以以交互式和探索性的方式来使用这些项目</p>
<h3 id="4-3-1-使用-types"><a href="#4-3-1-使用-types" class="headerlink" title="4.3.1  使用@types"></a>4.3.1  使用@types</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @types/jquery --save-dev</span><br></pre></td></tr></table></figure>

<p>@types支持全局和模块类型定义</p>
<h3 id="4-3-2-全局-types"><a href="#4-3-2-全局-types" class="headerlink" title="4.3.2  全局@types"></a>4.3.2  全局@types</h3><p>在默认情况下，TypeScript会自动包含支持全局使用的任何定义。例如，对于jQuery，你应该能够在项目中全局使用$。</p>
<h3 id="4-3-3-模块-types"><a href="#4-3-3-模块-types" class="headerlink" title="4.3.3 模块@types"></a>4.3.3 模块@types</h3><p>对于jQuery来说，通常建议使用模块。安装模块@types之后，不需要进行特别的配置，你就可以像使用模块一样使用它了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="comment">// 现在可以在次模块中任意使用$了</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-控制全局类型泄露"><a href="#4-3-4-控制全局类型泄露" class="headerlink" title="4.3.4 控制全局类型泄露"></a>4.3.4 控制全局类型泄露</h3><p>可以在tsconfig.json的compilerOptions.types选项，引入有意义的类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"types"</span>: [</span><br><span class="line">      <span class="string">"jquery"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，在配置compilerOptions.types：[“jquery”]之后，只允许使用jQuery的@types包。即使安装了另一个声明文件，如npm install@types/node，它的全局变量（如process）也不会泄漏到你的代码中，直到你将它们添加到tsconfig.json类型选项中。</p>
<h2 id="4-4-环境声明文件"><a href="#4-4-环境声明文件" class="headerlink" title="4.4. 环境声明文件"></a>4.4. 环境声明文件</h2><p>你可以选择把这些声明放入<strong>.ts</strong>或<strong>.d.ts</strong>里。在实际的项目中，强烈建议把声明放入独立的.d.ts里，你可以从一个命名为<strong>globals.d.ts</strong>或<strong>vendor.d.ts</strong>的文件开始。</p>
<p>如果一个文件有扩展名<strong>.d.ts</strong>，这意味着每个根级别的声明都必须以declare关键字作为前缀。这可以让开发者清楚地知道，在这里，TypeScript不会把它编译成任何代码，同时，开发者需要确保所声明的内容在编译时存在。</p>
<p><a href="https://www.w3cschool.cn/typescript/typescript-df-introduction.html" target="_blank" rel="noopener">声明文件编写参考</a></p>
<h2 id="4-5-接口"><a href="#4-5-接口" class="headerlink" title="4.5 接口"></a>4.5 接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declare const myPoint: &#123; x: number; y: number &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> myPoint: Point</span><br></pre></td></tr></table></figure>

<p>使用内联方式的类型定义和使用接口的方式定义是等效的，但是使用接口的方式便于其他使用者对其进行扩展</p>
<p>如在a.d.ts中有以下代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在b.d.ts中有如下代码对接口Point进行了扩展</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-1-类可以实现接口"><a href="#4-5-1-类可以实现接口" class="headerlink" title="4.5.1 类可以实现接口"></a>4.5.1 类可以实现接口</h3><p>如果你希望在类中使用必须要被遵循的接口（类）或别人定义的对象结构，可以使用implements关键字来确保其兼容性</p>
<p>基本上，在implements存在的情况下，外部Point接口的任何更改都将导致代码库中的编译错误，因此可以轻松地使其保持同步</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyPoint <span class="keyword">implements</span> Point &#123;</span><br><span class="line">    x!: <span class="built_in">number</span>;</span><br><span class="line">    y!: <span class="built_in">number</span>;</span><br><span class="line">    z!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果接口Point的结构发生了变化，自然MyPoint也需要相应作出改变，否则就会报错</p>
<h2 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h2><h3 id="4-6-1-数字枚举"><a href="#4-6-1-数字枚举" class="headerlink" title="4.6.1 数字枚举"></a>4.6.1 数字枚举</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED = <span class="number">100</span>,</span><br><span class="line">    GREEN = <span class="number">200</span>,</span><br><span class="line">    YELLOW = <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Color.RED)</span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">100</span>])</span><br></pre></td></tr></table></figure>

<p>上面代码console.log的结果是因为上面的ts代码被编译后生成的js代码是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Color;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Color</span>) </span>&#123;</span><br><span class="line">    Color[Color[<span class="string">"RED"</span>] = <span class="number">100</span>] = <span class="string">"RED"</span>;</span><br><span class="line">    Color[Color[<span class="string">"GREEN"</span>] = <span class="number">200</span>] = <span class="string">"GREEN"</span>;</span><br><span class="line">    Color[Color[<span class="string">"YELLOW"</span>] = <span class="number">300</span>] = <span class="string">"YELLOW"</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(Color.RED);</span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">100</span>]);</span><br></pre></td></tr></table></figure>

<p><code>Color[Color[&quot;RED&quot;] = 100] = &quot;RED&quot;;</code><br>这句代码会执行下述过程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Color[<span class="string">"RED"</span>] = <span class="number">100</span> 并返回 <span class="number">100</span> (在JavaScript中，赋值运算符返回的值是被赋予的值)</span><br><span class="line">Color[<span class="number">100</span>] = <span class="string">"RED"</span></span><br></pre></td></tr></table></figure>

<p>用数字枚举做标记的一个实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> AnimalFlags &#123;</span><br><span class="line">  None = <span class="number">0</span>,</span><br><span class="line">  HasClaws = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,	<span class="comment">// 0000 0000</span></span><br><span class="line">  CanFly = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,    <span class="comment">// 0000 0010</span></span><br><span class="line">  EatsFish = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 0000 0100</span></span><br><span class="line">  FlyingClawedFishEating = HasClaws | CanFly | EatsFish  <span class="comment">// 0000 0001 || 0000 0010 || 0000 0100 0000 0111 -&gt; 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  flags: AnimalFlags;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printAnimalAbilities = (animal: Animal): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> animalFlags = animal.flags;</span><br><span class="line">  <span class="keyword">if</span> (animalFlags &amp;&amp; animalFlags === AnimalFlags.HasClaws) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"有爪子的动物 "</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animalFlags &amp;&amp; animalFlags === AnimalFlags.CanFly) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"会飞的动物"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animalFlags &amp;&amp; animalFlags === AnimalFlags.EatsFish) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"吃鱼的动物"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    animalFlags &amp;&amp;</span><br><span class="line">    animalFlags === AnimalFlags.FlyingClawedFishEating</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"万能的动物"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animalFlags == AnimalFlags.None) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"什么也不会的动物"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal: Animal = &#123; flags: AnimalFlags.None &#125;;   <span class="comment">// 0000 0000</span></span><br><span class="line">animal.flags |= AnimalFlags.HasClaws    <span class="comment">//  0000 0000  || 0000 0001</span></span><br><span class="line">animal.flags &amp;= ~AnimalFlags.HasClaws   <span class="comment">// 0000 0001 &amp; 1111 1110  0000 0000</span></span><br><span class="line">animal.flags |= AnimalFlags.FlyingClawedFishEating      <span class="comment">// 0000 0000 || 0000 0111      </span></span><br><span class="line">printAnimalAbilities(animal);</span><br></pre></td></tr></table></figure>



<h3 id="4-6-2-字符串枚举"><a href="#4-6-2-字符串枚举" class="headerlink" title="4.6.2 字符串枚举"></a>4.6.2 字符串枚举</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> MessageType &#123;</span><br><span class="line">    SUCCESS = <span class="string">'success'</span>,</span><br><span class="line">    ERROR = <span class="string">'error'</span>,</span><br><span class="line">    WARN = <span class="string">'warning'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MessageType.SUCCESS)</span><br></pre></td></tr></table></figure>

<h3 id="4-6-3-常量枚举"><a href="#4-6-3-常量枚举" class="headerlink" title="4.6.3 常量枚举"></a>4.6.3 常量枚举</h3><p>有时定义枚举可能只是为了让程序可读性更好，而不需要编译后的代码，即不需要编译成对象。typescript中考虑到这种情况，所以加入了 const enum</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Tristate &#123;</span><br><span class="line">    False,</span><br><span class="line">    True,</span><br><span class="line">    Unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lie = Tristate.False;</span><br></pre></td></tr></table></figure>

<p>最终编译的js代码如下，并不会为枚举Tristate生成对应的Js代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> lie = <span class="number">0</span> <span class="comment">/* False */</span>;</span><br><span class="line"><span class="comment">//# sourceMappingURL=ConstEnum.js.map</span></span><br></pre></td></tr></table></figure>

<p>如果需要让常量枚举也能编译到最终生成的JS代码中，可以使用<strong>preserveConstEnums</strong>编译选项</p>
<h3 id="4-6-4-有静态方法的常量枚举"><a href="#4-6-4-有静态方法的常量枚举" class="headerlink" title="4.6.4 有静态方法的常量枚举"></a>4.6.4 有静态方法的常量枚举</h3><p>可以使用enum+namespace的声明方式向枚举类型添加静态方法。如下面的例子所示，我们将静态成员isBusinessDay添加到枚举上。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Weekday &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isBusinessDay</span>(<span class="params">day: Weekday</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> Weekday.Saturday:</span><br><span class="line">            <span class="keyword">case</span> Weekday.Sunday:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mon = Weekday.Monday;</span><br><span class="line"><span class="keyword">const</span> sun = Weekday.Sunday;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Weekday.isBusinessDay(mon))</span><br><span class="line"><span class="built_in">console</span>.log(Weekday.isBusinessDay(sun))</span><br></pre></td></tr></table></figure>

<h2 id="4-7-lib-d-ts"><a href="#4-7-lib-d-ts" class="headerlink" title="4.7 lib.d.ts"></a>4.7 lib.d.ts</h2><p>当你安装TypeScript时，会顺带安装一个lib.d.ts声明文件。这个文件包含JavaScript运行时及DOM（Document Object Model，文档对象模型）中存在的各种常见的JavaScript环境声明。</p>
<p>你可以通过指定<strong>–noLib</strong>的编译器命令行标记，或者在<strong>tsconfig.json</strong>中指定选项<strong>noLib：true</strong>，从上下文中排除此文件。</p>
<p><strong>lib.d.ts</strong>的内容主要是一些变量声明，如<strong>window</strong>、<strong>document</strong>、<strong>math</strong>等，以及一些类似的接口声明，如<strong>Window</strong>、<strong>Document</strong>、<strong>Math</strong>。阅读全局内容的文档和类型注解的最简单的方法是输入你知道有效的代码，如<strong>Math.floor</strong>，然后在IDE上按F12键，跳转到定义上。</p>
<h3 id="4-7-1-–lib选项"><a href="#4-7-1-–lib选项" class="headerlink" title="4.7.1 –lib选项"></a>4.7.1 –lib选项</h3><p>有时，你想要解耦编译目标（即生成的JavaScript版本）和环境库支持之间的关系。例如，对于Promise，你的编译目标是–target es5，但是你仍然想使用Promise，这时，你可以使用–lib选项来显示地控制lib。</p>
<p>注意：使用–lib选项可以将任何lib与–target解耦。</p>
<p>命令行</p>
<p><code>tsc --target es5  --lib dom,es6</code></p>
<p>tsconfig.json:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">  <span class="string">"lib"</span>: [<span class="string">"dom"</span>, <span class="string">"es6"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-2-lib的分类"><a href="#4-7-2-lib的分类" class="headerlink" title="4.7.2 lib的分类"></a>4.7.2 lib的分类</h3><p>● JavaScript功能</p>
<ol>
<li><p>es5</p>
</li>
<li><p>es6</p>
</li>
<li><p>es2015</p>
</li>
<li><p>es7</p>
</li>
<li><p>es2016</p>
</li>
<li><p>es2017</p>
</li>
<li><p>esnext</p>
</li>
</ol>
<ul>
<li><p>运行环境</p>
<ol>
<li>dom</li>
<li>dom.iterable</li>
<li>webworker</li>
<li>scripthost</li>
</ol>
</li>
<li><p>ESNext功能选项</p>
<ol>
<li>es2015.core</li>
<li>es2015.collection</li>
<li>es2015.generator</li>
<li>es2015.iterable</li>
<li>es2015.promise</li>
<li>es2015.proxy</li>
<li>es2015.reflect</li>
<li>es2015.symbol</li>
<li>es2015.symbol.wellknown</li>
<li>es2016.array.include</li>
<li>es2017.object</li>
<li>es2017.sharedmemory</li>
<li>esnext.asynciterable</li>
</ol>
</li>
</ul>
<p>–lib选项提供了非常高效的控制，因此你最有可能从运行环境与JavaScript功能类别中分别选择一项。如果没有指定–lib，则会导入默认库。</p>
<ul>
<li>当–target选项为es5时，会导入es5、dom、scripthost。</li>
<li>当–target选项为es6时，会导入es6、dom、dom.iterable、scripthost</li>
</ul>
<h2 id="4-8-函数"><a href="#4-8-函数" class="headerlink" title="4.8 函数"></a>4.8 函数</h2><p>函数类型在TypeScript类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块。</p>
<h3 id="4-8-1-参数注解"><a href="#4-8-1-参数注解" class="headerlink" title="4.8.1 参数注解"></a>4.8.1 参数注解</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg: <span class="built_in">string</span>| <span class="built_in">string</span>[] | <span class="literal">undefined</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-2-函数返回值注解"><a href="#4-8-2-函数返回值注解" class="headerlink" title="4.8.2 函数返回值注解"></a>4.8.2 函数返回值注解</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg: <span class="built_in">string</span>| <span class="built_in">string</span>[] | <span class="literal">undefined</span> | <span class="literal">null</span></span>): <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data: [],</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'success'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Result &#123;</span><br><span class="line">    data: <span class="built_in">any</span>,</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-3-可选参数-参数默认值"><a href="#4-8-3-可选参数-参数默认值" class="headerlink" title="4.8.3 可选参数, 参数默认值"></a>4.8.3 可选参数, 参数默认值</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg: <span class="built_in">string</span>| <span class="built_in">string</span>[] | <span class="literal">undefined</span> | <span class="literal">null</span>, canBeNull?: <span class="built_in">number</span> = 1</span>): <span class="title">Result</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-8-4-函数重载"><a href="#4-8-4-函数重载" class="headerlink" title="4.8.4 函数重载"></a>4.8.4 函数重载</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">a: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c:<span class="built_in">number</span></span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">a?: <span class="built_in">number</span>, b?:<span class="built_in">number</span>, c?: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a &amp;&amp; !b &amp;&amp; !c ) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span>(a &amp;&amp; !b &amp;&amp; !c) <span class="built_in">console</span>.log(<span class="string">'a is: '</span> + a)</span><br><span class="line">    <span class="keyword">if</span>(a &amp;&amp; b &amp;&amp; !c) <span class="built_in">console</span>.log(<span class="string">'a+b is: '</span> + (a+b))</span><br><span class="line">    <span class="keyword">if</span>(a &amp;&amp; b &amp;&amp; c) <span class="built_in">console</span>.log(<span class="string">'a+b+c is: '</span> + (a+b+c))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span>)</span><br><span class="line">print(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-8-5-可调用和可实例化"><a href="#4-8-5-可调用和可实例化" class="headerlink" title="4.8.5 可调用和可实例化"></a>4.8.5 可调用和可实例化</h3><ol>
<li>可调用</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可调用</span></span><br><span class="line"><span class="keyword">interface</span> ReturnString &#123;</span><br><span class="line">    (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 它表示一个返回值为string的函数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> foo: ReturnString</span><br><span class="line"><span class="keyword">const</span> bar = foo()</span><br></pre></td></tr></table></figure>

<p>一个实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Complex &#123;</span><br><span class="line">    (foo: <span class="built_in">string</span>, bar?: <span class="built_in">number</span>, ...others: <span class="built_in">boolean</span>[]): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Overloaded &#123;</span><br><span class="line">    (foo: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    (foo: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> foo === <span class="string">'number'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> foo * foo;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">'string'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;foo&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> overloaded: Overloaded  = stringOrNumber</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = overloaded(<span class="string">''</span>)   <span class="comment">// str被推断为string类型</span></span><br><span class="line"><span class="keyword">const</span> num = overloaded(<span class="number">123</span>) <span class="comment">// num 被推断为number类型</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>可实例化</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123;<span class="keyword">new</span>(): T; &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">    nametag: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animal</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;  <span class="comment">// typechecks!</span></span><br><span class="line">createInstance(Bee).keeper.hasMask;   <span class="comment">// typechecks!</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-9-类型断言"><a href="#4-9-类型断言" class="headerlink" title="4.9 类型断言"></a>4.9 类型断言</h2><p>TypeScript允许你以任何方式去重写其推断和分析的类型。这是通过一种被称为“类型断言”的机制来实现的。TypeScript类型断言纯粹是用来告诉编译器，你比它更了解这个类型，并且它不应该再发出错误提示。</p>
<p>类型断言的一个常见示例是将代码从JavaScript迁移到TypeScript。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;</span><br><span class="line">foo.bar = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>这里的代码发出了错误警告，因为foo的类型推断为{}，即具有零属性的对象。因此，你不能在它的属性上添加bar或bas，你可以通过类型断言来避免此问题。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125; <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">foo.bar = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br></pre></td></tr></table></figure>

<p>也可以这样进行类型断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &lt;<span class="built_in">any</span>&gt;&#123;&#125;</span><br><span class="line">foo.bar = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br></pre></td></tr></table></figure>

<p>但是因为<strong>JSX</strong>中JS和XML混写，因此推荐使用<strong>as</strong>来进行类型断言</p>
<p>类型断言之所以不被称为“类型转换”，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也为编译器提供了分析代码的方法。</p>
<p>我们可以也可以利用类型断言来提供代码提示</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    hobby: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &lt;People&gt;&#123;</span><br><span class="line">    name: <span class="string">'david'</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    hobby: <span class="string">'programming'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure>

<p>这也会存在一个同样的问题，如果你忘了某个属性，编译器同样也不会发出错误警告。那么，像这样可能会更好一些。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person1: People = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们已经证明了类型断言并不那么安全，但它也有用武之地。下面就是一个非常实用的例子，当使用者了解传入参数更具体的类型时，类型断言就能按预期工作。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">event: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mouseEvent = event <span class="keyword">as</span> MouseEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-10-Freshness"><a href="#4-10-Freshness" class="headerlink" title="4.10 Freshness"></a>4.10 Freshness</h2><p>对于对象字面量的类型，TypeScript 有一个被称之为 「<a href="https://link.zhihu.com/?target=https%3A//github.com/Microsoft/TypeScript/pull/3823">Freshness</a> 」的概念，它也被称为更严格的对象字面量检查</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logName</span>(<span class="params">something: &#123;name?: <span class="built_in">string</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;name: <span class="string">'david'</span>, job: <span class="string">'programming'</span>&#125;</span><br><span class="line"><span class="comment">// 结构类型很方便，但是， 如果它允许传入并没有用到的属性</span></span><br><span class="line">logName(p1)</span><br><span class="line"><span class="comment">// 对于对象字面量会进行Fressness检查（更为严格的对象字面量检查）</span></span><br><span class="line">logName(&#123;name: <span class="string">'jack'</span>, job: <span class="string">'backendprogrammer'</span>&#125;)</span><br><span class="line"><span class="comment">// 可以通过添加索引签名来允许字面量对象传递没有显示声明的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logName1</span> (<span class="params">something: &#123;name?: <span class="built_in">string</span>, [x:<span class="built_in">string</span>]: <span class="built_in">any</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something.name)</span><br><span class="line">&#125;</span><br><span class="line">logName1(&#123;name: <span class="string">'jack'</span>, job: <span class="string">'backendprogrammer'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-11-类型保护"><a href="#4-11-类型保护" class="headerlink" title="4.11 类型保护"></a>4.11 类型保护</h2><h3 id="4-11-1-使用typeof"><a href="#4-11-1-使用typeof" class="headerlink" title="4.11.1 使用typeof"></a>4.11.1 使用typeof</h3><p>![image-20200427172819778](/Users/liwei/Library/Application Support/typora-user-images/image-20200427172819778.png)</p>
<h3 id="4-11-2-使用instanceof"><a href="#4-11-2-使用instanceof" class="headerlink" title="4.11.2 使用instanceof"></a>4.11.2 使用instanceof</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    foo = <span class="number">123</span>;</span><br><span class="line">    common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar &#123;</span><br><span class="line">    bar = <span class="number">123</span>;</span><br><span class="line">    common = <span class="string">'123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo | Bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Foo)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.common)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Bar) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.common)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typescript能够推断出else中的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">    foo = <span class="number">123</span>;</span><br><span class="line">    common = <span class="string">'123'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar &#123;</span><br><span class="line">    bar = <span class="number">123</span>;</span><br><span class="line">    common = <span class="string">'123'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo | Bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Foo)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)</span><br><span class="line">        <span class="built_in">console</span>.log(arg.common)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-3-使用in关键字"><a href="#4-11-3-使用in关键字" class="headerlink" title="4.11.3 使用in关键字"></a>4.11.3 使用in关键字</h3><p>![image-20200427173353893](/Users/liwei/Library/Application Support/typora-user-images/image-20200427173353893.png)</p>
<h3 id="4-11-4-字面量类型保护"><a href="#4-11-4-字面量类型保护" class="headerlink" title="4.11.4 字面量类型保护"></a>4.11.4 字面量类型保护</h3><p>你可以使用===、==、！==、！=来区分字面量类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">    kind: <span class="string">'foo'</span>;</span><br><span class="line">    foo: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123;</span><br><span class="line">    kind: <span class="string">'bar'</span>;</span><br><span class="line">    bar: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo|Bar</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg.kind === <span class="string">'foo'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-5-strictNullChecks编译属性下的null和undefined"><a href="#4-11-5-strictNullChecks编译属性下的null和undefined" class="headerlink" title="4.11.5 strictNullChecks编译属性下的null和undefined"></a>4.11.5 strictNullChecks编译属性下的null和undefined</h3><p>TypeScript可以使用==null和!==null来区分null和undefined</p>
<p>![image-20200427174255480](/Users/liwei/Library/Application Support/typora-user-images/image-20200427174255480.png)</p>
<h3 id="4-11-6-自定义类型保护"><a href="#4-11-6-自定义类型保护" class="headerlink" title="4.11.6 自定义类型保护"></a>4.11.6 自定义类型保护</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    foo: <span class="built_in">number</span>;</span><br><span class="line">    common: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">    bar: <span class="built_in">number</span>;</span><br><span class="line">    common: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFoo</span>(<span class="params">arg: Foo|Bar</span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arg <span class="keyword">as</span> Foo).foo !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFoo(arg))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)  <span class="comment">// 正确</span></span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)  <span class="comment">// 错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg.bar)  <span class="comment">// 正确</span></span><br><span class="line">        <span class="built_in">console</span>.log(arg.foo)  <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-11-7-类型保护和函数回调"><a href="#4-11-7-类型保护和函数回调" class="headerlink" title="4.11.7 类型保护和函数回调"></a>4.11.7 类型保护和函数回调</h3><p>TypeScript不能确定类型保护在回调中一直有效，比如下述代码中变量foo的属性bar可能为为undefined，因此typescript会报错</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo:&#123;bar?: &#123;baz: <span class="built_in">string</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doCalback</span>(<span class="params">callback: () =&gt; <span class="built_in">void</span></span>)</span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(foo.bar)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.bar.baz)</span><br><span class="line">    doCalback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo.bar.baz)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20200427175325417](/Users/liwei/Library/Application Support/typora-user-images/image-20200427175325417.png)</p>
<p>解决方式为把推断的安全值存放在本地的局部变量中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo:&#123;bar?: &#123;baz: <span class="built_in">string</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doCalback</span>(<span class="params">callback: () =&gt; <span class="built_in">void</span></span>)</span>&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(foo.bar)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.bar.baz)</span><br><span class="line">    <span class="keyword">const</span> bar = foo.bar</span><br><span class="line">    doCalback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.baz)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-12-字面量类型"><a href="#4-12-字面量类型" class="headerlink" title="4.12 字面量类型"></a>4.12 字面量类型</h2><h3 id="4-12-1-字符串字面量"><a href="#4-12-1-字符串字面量" class="headerlink" title="4.12.1 字符串字面量"></a>4.12.1 字符串字面量</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction = <span class="string">'North'</span> | <span class="string">'East'</span> | <span class="string">'South'</span> | <span class="string">'West'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">distance: <span class="built_in">number</span>, direction: Direction</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;direction&#125;</span>: <span class="subst">$&#123;distance&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">move(<span class="number">1</span>, <span class="string">'North'</span>)</span><br><span class="line">move(<span class="number">2</span>, <span class="string">"West"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-12-3-boolean和number字面量"><a href="#4-12-3-boolean和number字面量" class="headerlink" title="4.12.3 boolean和number字面量"></a>4.12.3 boolean和number字面量</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> oneToFive = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span></span><br><span class="line"><span class="keyword">type</span> Bools = <span class="literal">true</span> | <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trueOrFalse</span>(<span class="params">arg: Bools</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNumber</span>(<span class="params">num: oneToFive</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">trueOrFalse(<span class="literal">false</span>)</span><br><span class="line">logNumber(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-12-4-基于字符串的枚举"><a href="#4-12-4-基于字符串的枚举" class="headerlink" title="4.12.4 基于字符串的枚举"></a>4.12.4 基于字符串的枚举</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据传入的数组生成key-value结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strEnum</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">string</span>&gt;(<span class="params">o: <span class="built_in">Array</span>&lt;T&gt;</span>): </span>&#123;[K <span class="keyword">in</span> T]: K&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> o.reduce(<span class="function">(<span class="params">res, key</span>) =&gt;</span> &#123;</span><br><span class="line">        res[key] = key;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, <span class="built_in">Object</span>.create(<span class="literal">null</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后可以使用keyof, typeof来生成字符串的联合类型</span></span><br><span class="line"><span class="keyword">const</span> Direction = strEnum([<span class="string">'North'</span>, <span class="string">'South'</span>, <span class="string">'East'</span>, <span class="string">'West'</span>])</span><br><span class="line"><span class="keyword">type</span> Direction = keyof <span class="keyword">typeof</span> Direction</span><br><span class="line"><span class="keyword">let</span> sample: Direction</span><br><span class="line"></span><br><span class="line">sample = Direction.North</span><br><span class="line">sample = <span class="string">'North'</span></span><br><span class="line">sample = <span class="string">'AnythingElse'</span> <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="4-13-readonly"><a href="#4-13-readonly" class="headerlink" title="4.13 readonly"></a>4.13 readonly</h2><p>使用readonly关键字来标记属性可以保证数据不可变</p>
<p>![image-20200428091821889](/Users/liwei/Library/Application Support/typora-user-images/image-20200428091821889.png)</p>
<p>![image-20200428091943080](/Users/liwei/Library/Application Support/typora-user-images/image-20200428091943080.png)</p>
<p>我们也可以指定一个类的属性为readonly,然后在声明或在构造函数中初始化它们,如下所示</p>
<p>![image-20200428092157934](/Users/liwei/Library/Application Support/typora-user-images/image-20200428092157934.png)</p>
<h3 id="4-13-1-使用readonly的实例"><a href="#4-13-1-使用readonly的实例" class="headerlink" title="4.13.1 使用readonly的实例"></a>4.13.1 使用readonly的实例</h3><ol>
<li>一个把类型中所有属性转化为只读属性的映射类型</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是一个readonly映射类型，接收一个泛型T，用来把它所有属性都标记为readonly</span></span><br><span class="line"><span class="keyword">type</span> Foo =  &#123;</span><br><span class="line">    bar: <span class="built_in">number</span>;</span><br><span class="line">    bas: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadonlyFoo = MyReadonly&lt;Foo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo1: Foo = &#123;bar: <span class="number">123</span>, bas: <span class="number">456</span>&#125;</span><br><span class="line"><span class="keyword">const</span> fooReadonly: ReadonlyFoo = &#123;bar: <span class="number">123</span>, bas: <span class="number">456</span>&#125;</span><br><span class="line">foo.bar = <span class="number">456</span></span><br><span class="line">fooReadonly.bar = <span class="number">789</span>   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>React.js中state和props的使用</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Layout, Menu &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'dva'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Urls &#125; <span class="keyword">from</span> <span class="string">'@/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Content &#125; = Layout</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    readonly [index: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">    menus: <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">        readonly key: <span class="built_in">string</span></span><br><span class="line">        readonly label: <span class="built_in">string</span></span><br><span class="line">        readonly to: <span class="built_in">string</span></span><br><span class="line">    &#125;&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> App <span class="keyword">extends</span> PureComponent&lt;Props, State&gt; &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        menus: [</span><br><span class="line">            &#123;</span><br><span class="line">                key: <span class="string">'main'</span>,</span><br><span class="line">                label: <span class="string">'首页'</span>,</span><br><span class="line">                to: Urls.MAIN</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                key: <span class="string">'form'</span>,</span><br><span class="line">                label: <span class="string">'表单设计'</span>,</span><br><span class="line">                to: Urls.FORM</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                key: <span class="string">'code'</span>,</span><br><span class="line">                label: <span class="string">'代码生成'</span>,</span><br><span class="line">                to: Urls.CODE</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                key: <span class="string">'chart'</span>,</span><br><span class="line">                label: <span class="string">'图表设计'</span>,</span><br><span class="line">                to: Urls.CHART</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderMenu(): JSX.Element &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; menus &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Menu theme=&#123;<span class="string">'dark'</span>&#125; mode=&#123;<span class="string">'horizontal'</span>&#125;&gt;</span><br><span class="line">                &#123;menus.map(<span class="function">(<span class="params">menu</span>) =&gt;</span> (</span><br><span class="line">                    &lt;Menu.Item key=&#123;menu.key&#125;&gt;</span><br><span class="line">                        &lt;Link to=&#123;menu.to&#125;&gt;&#123;menu.label&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;/</span>Menu.Item&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">            &lt;<span class="regexp">/Menu&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render(): JSX.Element &#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;Layout className=&#123;'height100'&#125;&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Header&gt;&#123;this.renderMenu()&#125;&lt;/</span>Header&gt;</span><br><span class="line">                &lt;Content&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;<span class="regexp">/Content&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Layout&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">&#123; app &#125;</span>) =&gt;</span> (&#123; ...app.toJS() &#125;))(App)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>绝对不可变</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    readonly [x: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo1: Foo = &#123; <span class="number">0</span>: <span class="number">123</span>, <span class="number">2</span>: <span class="number">345</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo1[<span class="number">0</span>])</span><br><span class="line">foo1[<span class="number">0</span>] = <span class="number">456</span>   <span class="comment">// 报错，只读不可修改</span></span><br><span class="line"><span class="comment">// 以不变的方式使用原生数组,可以使用TypeScript提供的ReadonlyArray&lt;T&gt;接口</span></span><br><span class="line"><span class="keyword">let</span> foo2: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(foo2[<span class="number">0</span>])</span><br><span class="line">foo2.push(<span class="number">4</span>)  <span class="comment">// 报错，只读数组不可添加元素</span></span><br><span class="line">foo2 = foo2.concat(<span class="number">4</span>)  <span class="comment">// 这样是允许的，因为通过concat创建了一个副本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>readonly的自动推断<br>例如在一个class中，如果有一个只有getter、没有setter的属性，它就能被推断为是只读的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animals &#123;</span><br><span class="line">    name: <span class="built_in">string</span> = <span class="string">'dog'</span>;</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> info() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">''</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal1 = <span class="keyword">new</span> Animals()</span><br><span class="line"><span class="built_in">console</span>.log(animal1.info)</span><br><span class="line">animal1.info = <span class="string">'cat2'</span>   <span class="comment">// 报错，只读属性不可重新赋值</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>readonly和const<br>readonly用于属性， const用于变量声明<br>readonly能确保属性不能直接被使用者修改，但是当你把这个属性交给其他并没有做出这种保证的使用者（出于类型兼容的原因而被允许）时，他们可以修改它</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo1: &#123;</span><br><span class="line">    readonly bar: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    bar: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo1.bar = <span class="number">456</span>   <span class="comment">// 报错，只读属性不能被修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iMutateFoo</span>(<span class="params">foo: &#123; bar: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处于类型兼容考虑readonly的属性被修改了</span></span><br><span class="line">    foo.bar = <span class="number">456</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iMutateFoo(foo1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    readonly bar: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iMutateFoo1</span>(<span class="params">foo: Foo</span>) </span>&#123;</span><br><span class="line">    foo.bar = <span class="number">456</span>  <span class="comment">// 因为明确了参数的类型，则此处只读属性bar不可被修改了</span></span><br><span class="line">&#125;</span><br><span class="line">iMutateFoo1(foo1)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="4-14-泛型"><a href="#4-14-泛型" class="headerlink" title="4.14 泛型"></a>4.14 泛型</h2><p>设计泛型的关键动机是在成员之间提供有意义的类型约束，这些成员可以是类的实例成员、类的方法、函数的参数、函数返回值。</p>
<h3 id="4-14-1-使用泛型的实例"><a href="#4-14-1-使用泛型的实例" class="headerlink" title="4.14.1 使用泛型的实例"></a>4.14.1 使用泛型的实例</h3><ol>
<li>一个队列的例子</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> data:T[] = [];</span><br><span class="line">    push = <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="keyword">this</span>.data.push(item);</span><br><span class="line">    pop = (): T | <span class="function"><span class="params">undefined</span>  =&gt;</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="string">'1'</span>)  <span class="comment">// 报错，指定泛型类型为number类型，不能再添加其他类型的元素了</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>reverse函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> &lt;<span class="title">T</span>&gt; (<span class="params">arr: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res: T[] = []</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )&#123;</span><br><span class="line">        res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>

<p>建议：你可以随意调用泛型的参数，当你使用简单的泛型时，泛型常用T、U、V表示。如果在你的参数里，拥有不止一个泛型，你应该使用一个更语义化的名称，如TKey和TValue。依照惯例，以T作为泛型的前缀</p>
</li>
<li><p>一个用于加载JSON文件的返回值函数， 它会返回任何你传入的类型的Promise</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = &lt;T&gt;(config: &#123;url: <span class="built_in">string</span>; headers?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">string</span>&#125;&#125;): <span class="built_in">Promise</span>&lt;T&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchConfig = &#123;</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        Accept: <span class="string">'application/json'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        ...(config.headers || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetch(config.url, fetchConfig).then&lt;T&gt;(<span class="function"><span class="params">response</span> =&gt;</span> response.json());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LoadUserResponse = &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        emial: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadUsers</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON&lt;LoadUserResponse&gt;(&#123; url: <span class="string">'http://example.com/users'</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadUsers().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.user.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>泛型被用于函数参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animals =  &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Website = &#123;</span><br><span class="line">    url: <span class="built_in">string</span>;</span><br><span class="line">    count: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log&lt;Animals&gt;(&#123;</span><br><span class="line">    name: <span class="string">'dog'</span>,</span><br><span class="line">    age: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">log&lt;Website&gt;(&#123;</span><br><span class="line">    url: <span class="string">'http://baidu.com'</span>,</span><br><span class="line">    count: <span class="number">10000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="4-15-类型推断"><a href="#4-15-类型推断" class="headerlink" title="4.15 类型推断"></a>4.15 类型推断</h2><p>TypeScript可以根据一些简单的规则来推断（然后检查）变量的类型</p>
<ul>
<li><p>定义变量<br>变量的类型根据定义来推断</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>  <span class="comment">// 推断为number</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'hello'</span> <span class="comment">// 推断为string</span></span><br><span class="line">b = <span class="number">123</span>      <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值<br>根据return语句来判断</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断返回类型为number</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Adder = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> foo1: Adder = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b   <span class="comment">// a,b被推断为number类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line">obj.a = <span class="string">'2'</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; a &#125; = obj</span><br><span class="line">a = <span class="string">'2'</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-15-1-noImplicitAny"><a href="#4-15-1-noImplicitAny" class="headerlink" title="4.15.1 noImplicitAny"></a>4.15.1 noImplicitAny</h3><p>标记noImplicitAny用来指示编译器，在无法推断一个变量的类型时，发出一个错误（或者只将其作为一个隐式的any）。此时，你可以做如下处理。</p>
<ul>
<li>通过显式添加：any的类型注解，来让它成为一个any类型。</li>
<li>通过一些更准确的类型注解来帮助TypeScript推断类型。</li>
</ul>
<h2 id="4-16-类型的兼容性"><a href="#4-16-类型的兼容性" class="headerlink" title="4.16 类型的兼容性"></a>4.16 类型的兼容性</h2><p>类型兼容性用于确定一个类型能否赋值给其他类型。如string类型与number类型不兼容，因此不能相互赋值。</p>
<h3 id="4-16-1-稳定性"><a href="#4-16-1-稳定性" class="headerlink" title="4.16.1 稳定性"></a>4.16.1 稳定性</h3><p>TypeScript类型系统设计得很方便，它允许你有一些不正确的行为。例如，任何类型都能被赋值给any，这意味着编译器允许你做任何想做的事情。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo1: <span class="built_in">any</span> = <span class="number">123</span></span><br><span class="line">foo1 = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-16-2-结构化类型的兼容性"><a href="#4-16-2-结构化类型的兼容性" class="headerlink" title="4.16.2 结构化类型的兼容性"></a>4.16.2 结构化类型的兼容性</h3><p>TypeScript对象是一种结构化的类型，这意味着只要结构匹配，名称也就无关紧要了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Point2D &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> x: <span class="built_in">number</span>, <span class="keyword">public</span> y: <span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Point;</span><br><span class="line">p = <span class="keyword">new</span> Point2D(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-16-3-函数的兼容性"><a href="#4-16-3-函数的兼容性" class="headerlink" title="4.16.3 函数的兼容性"></a>4.16.3 函数的兼容性</h3><p>当你比较两个函数类型是否兼容时，下面是一些需要考虑的事情</p>
<ol>
<li>返回类型<br>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</li>
</ol>
<p>![image-20200428105250170](/Users/liwei/Library/Application Support/typora-user-images/image-20200428105250170.png)</p>
<ol start="2">
<li><p>参数数量<br>要查看 x 是否能赋值给 y，首先看它们的参数列表，x 的每个参数必须能在 y 里找到对应类型的参数，注意的是参数的名字相同与否无所谓，只看它们的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选参数和rest参数<br>为了方便起见，可选参数（预先确定的）和rest参数（任何数量的参数）是兼容的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aoo = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="function">(<span class="params">x?: <span class="built_in">number</span>, y?:<span class="built_in">number</span></span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bas = <span class="function">(<span class="params">...args: <span class="built_in">number</span>[]</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">aoo = bar</span><br><span class="line">bas = bar</span><br><span class="line">bas = aoo</span><br><span class="line"><span class="comment">// 可选的参数（如上面例子中的bar）与不可选的参数（如上面例子中的foo），只有在strictNullChecks为false时兼容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数类型兼容性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Event &#123;</span><br><span class="line">    timestamp: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event&#123;</span><br><span class="line">    keyCode: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> EventType &#123;</span><br><span class="line">    Mouse,</span><br><span class="line">    KeyBoard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params">eventType: EventType, handler: (n: Event) =&gt; <span class="built_in">void</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不安全，但是常用</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">(<span class="params">e: MouseEvent</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e.x+ ',' + e.y</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="params">addEventListener</span>(<span class="params">EventType.Mouse, handler</span>) // 报错</span></span><br><span class="line"><span class="function">// 解决方案</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">handler1</span> = &lt;(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;<span class="function">(<span class="params">(<span class="params">e: MouseEvent</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e.x+ ',' + e.y</span>)</span>)</span></span><br><span class="line"><span class="function"><span class="params">addEventListener</span>(<span class="params">EventType.Mouse, handler1</span>) // 报错</span></span><br><span class="line"><span class="function">// 或者</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">handler2</span> = (<span class="params">(<span class="params">e: Event</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">(<span class="params">&lt;MouseEvent&gt;e</span>).x+ ',' + (<span class="params">&lt;MouseEvent&gt;e</span>).y</span>)</span>)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-16-4-枚举类型的兼容性"><a href="#4-16-4-枚举类型的兼容性" class="headerlink" title="4.16.4 枚举类型的兼容性"></a>4.16.4 枚举类型的兼容性</h3><ol>
<li><p>枚举与数字类型是兼容的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;</span><br><span class="line">    Ready,</span><br><span class="line">    Waiting</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> status1 = Status.Ready</span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span></span><br><span class="line">status1 = num</span><br></pre></td></tr></table></figure>
</li>
<li><p>来自不同枚举的枚举变量，被认为是不兼容的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;</span><br><span class="line">    Ready,</span><br><span class="line">    Waiting</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> status1 = Status.Ready</span><br><span class="line"><span class="keyword">let</span> color1 = Color.Blue</span><br><span class="line">status1 = color1  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-16-5-类的类型兼容"><a href="#4-16-5-类的类型兼容" class="headerlink" title="4.16.5 类的类型兼容"></a>4.16.5 类的类型兼容</h3><p>只比较实例成员和方法，构造函数和静态成员不起作用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal1 &#123;</span><br><span class="line">    <span class="keyword">static</span> feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">    <span class="keyword">static</span> feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">meters: <span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal1</span><br><span class="line"><span class="keyword">let</span> s: Size = <span class="keyword">new</span> Size(<span class="number">1</span>)</span><br><span class="line">a = s  <span class="comment">// 可以赋值</span></span><br><span class="line">s = a  <span class="comment">// 可以赋值</span></span><br></pre></td></tr></table></figure>

<p>私有的和受保护的成员必须来自相同的类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal1 &#123;</span><br><span class="line">    <span class="keyword">protected</span> feet: <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal1&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal1: Animal1;</span><br><span class="line"><span class="keyword">let</span> cat1: Cat = <span class="keyword">new</span> Cat();</span><br><span class="line">animal1 = cat1  <span class="comment">// 可以赋值</span></span><br><span class="line">cat1 = animal1 <span class="comment">// 可以赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  Size &#123;</span><br><span class="line">    <span class="keyword">protected</span> feet: <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> size: Size;</span><br><span class="line">animal1 = size <span class="comment">// 错误, 不能赋值</span></span><br><span class="line">size = animal1  <span class="comment">// 错误，不能赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="4-16-6-泛型类型兼容"><a href="#4-16-6-泛型类型兼容" class="headerlink" title="4.16.6 泛型类型兼容"></a>4.16.6 泛型类型兼容</h3><p>TypeScript 类型系统基于变量的结构，仅当类型参数在被一个成员使用时，才会影响兼容性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line">x = y</span><br><span class="line"><span class="comment">// 泛型T因为没有被任何接口的任何成员使用，因此并不会影响到兼容性</span></span><br></pre></td></tr></table></figure>

<p>如果尚未实例化泛型参数，则在检查兼容性之前将其替换为 any：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="keyword">let</span> identity = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; (<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span>&lt;<span class="title">U</span>&gt; (<span class="params">y: U</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity = reverse <span class="comment">// (x: any) =&gt; any 类型与(y: any) =&gt; any匹配</span></span><br></pre></td></tr></table></figure>

<p>当泛型被成员使用时，它将在实例化泛型后影响兼容性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y <span class="comment">// 错误,不能赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="4-17-never"><a href="#4-17-never" class="headerlink" title="4.17 never"></a>4.17 never</h2><p>Never类型是任何类型的子类型，也可以赋值给任何类型， 然而，没有类型是never的子类型或可以赋值给never类型（除了never类型本身之外），即使any也不可以赋值给never类型，通常表现为抛出异常或者无法执行到终止点（例如无限循环）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: never;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = <span class="function">(<span class="params">(<span class="params"></span>)=&gt;&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">'exception'</span>)&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 运行正确，<span class="params">never</span> 类型可以赋值给 数字类型</span></span><br><span class="line"><span class="function"><span class="params">y</span> = (<span class="params">(<span class="params"></span>)=&gt;&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">'exception'</span>)&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回值为 <span class="params">never</span> 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="params">never</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">throw</span> <span class="params">new</span> <span class="params">Error</span>(<span class="params">message</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回值为 <span class="params">never</span> 的函数可以是无限循环这种无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">loop</span><span class="params">()</span>: <span class="params">never</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">while</span> (<span class="params"><span class="literal">true</span></span>) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-18-辨析联合类型"><a href="#4-18-辨析联合类型" class="headerlink" title="4.18 辨析联合类型"></a>4.18 辨析联合类型</h2><p>当类中含有字面量成员时，我们可以用该类的属性来辨析联合类型</p>
<p>如果你使用类型保护风格的检查（即==、===、！=、！==），或者使用具有判断性的属性（在这里是kind），TypeScript将会认为你所使用的对象类型必须要具有特定的字面量，并且为你进行类型缩小。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">'square'</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">'rectangle'</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">'circle'</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.kind === <span class="string">'square'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.size  * s.size</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.kind === <span class="string">'rectangle'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.width * s.height</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.kind === <span class="string">'circle'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> _exhaustiveCheck: never = s</span><br><span class="line">        <span class="keyword">return</span> _exhaustiveCheck</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areaBySwitch</span>(<span class="params">s: Shape</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">            <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">            <span class="keyword">return</span> s.width * s.height;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">const</span> _exhaustiveCheck: never = s</span><br><span class="line">            <span class="keyword">return</span> _exhaustiveCheck</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-18-1-版本控制"><a href="#4-18-1-版本控制" class="headerlink" title="4.18.1 版本控制"></a>4.18.1 版本控制</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DTO = | &#123;</span><br><span class="line">    version: <span class="literal">undefined</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125; | &#123;</span><br><span class="line">    version: <span class="number">1</span>;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125; | &#123;</span><br><span class="line">    version: <span class="number">2</span>;</span><br><span class="line">    firstName: <span class="built_in">string</span>;</span><br><span class="line">    lastName: <span class="built_in">string</span>;</span><br><span class="line">    middleName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printDTO</span>(<span class="params">dto: DTO</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dto.version == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(dto.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dto.version === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(dto.firstName, dto.lastName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dto.version === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(dto.firstName, dto.middleName, dto.lastName);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'===================================='</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> _exhaustiveCheck: never = dto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-18-2-redux中定义ActionTypes的应用"><a href="#4-18-2-redux中定义ActionTypes的应用" class="headerlink" title="4.18.2 redux中定义ActionTypes的应用"></a>4.18.2 redux中定义ActionTypes的应用</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore  &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">type</span> ActionTypes = <span class="string">'INCREMENT'</span> | <span class="string">'DECREMENT'</span></span><br><span class="line"><span class="keyword">type</span> Action = &#123;</span><br><span class="line">    <span class="keyword">type</span>: ActionTypes</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">state = 0, action: Action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter);</span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;)</span><br><span class="line">store.dispatch(&#123; <span class="keyword">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="keyword">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="keyword">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-19-索引签名"><a href="#4-19-索引签名" class="headerlink" title="4.19 索引签名"></a>4.19 索引签名</h2><h3 id="4-19-1-JavaScript中时候用对象作为key进行签名默认调用toString"><a href="#4-19-1-JavaScript中时候用对象作为key进行签名默认调用toString" class="headerlink" title="4.19.1 JavaScript中时候用对象作为key进行签名默认调用toString()"></a>4.19.1 JavaScript中时候用对象作为key进行签名默认调用toString()</h3><p>可以用字符串访问JavaScript中的对象（在TypeScript中也一样），并保存对其他对象的引用除字符串外，它也可以保存任意的JavaScript对象，例如一个类的实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'to string is called'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">foo[obj] = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<p>当你向索引签名传入一个其他对象时，JavaScript会在得到结果之前先调用toString方法。</p>
<p>只要索引位置使用了obj，toString方法都将被调用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'to string is called'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">foo[obj] = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[obj])</span><br></pre></td></tr></table></figure>

<p>![image-20200502141249208](/Users/liwei/Library/Application Support/typora-user-images/image-20200502141249208.png)</p>
<h3 id="4-19-2-TypeScript索引签名"><a href="#4-19-2-TypeScript索引签名" class="headerlink" title="4.19.2 TypeScript索引签名"></a>4.19.2 TypeScript索引签名</h3><p>首先，因为JavaScript在任何一个对象索引签名上都会隐式调用toString方法，而在TypeScript中它将会抛出一个错误提示</p>
<p>![image-20200502141542000](/Users/liwei/Library/Application Support/typora-user-images/image-20200502141542000.png)</p>
<p>我们必须这么做才能解决报错</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo1: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">foo[obj.toString()] = <span class="string">'World'</span></span><br></pre></td></tr></table></figure>

<h3 id="1-声明索引签名"><a href="#1-声明索引签名" class="headerlink" title="1. 声明索引签名"></a>1. 声明索引签名</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mailBox: &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: &#123;</span><br><span class="line">    content: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">mailBox[<span class="string">'a'</span>] = &#123;</span><br><span class="line">    content: <span class="string">'a'</span></span><br><span class="line">&#125;</span><br><span class="line">mailBox[<span class="string">'b'</span>] = &#123;</span><br><span class="line">    content: <span class="string">'b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引签名的名称，如{[index：string]：{message：string}}里的index，除提高了可读性外，并没有任何意义。例如，如果有一个用户名，你可以使用{username：string}：{message：string}，这有助于下一个开发者理解你的代码。</p>
<h3 id="2-所有成员必须符合字符串索引签名"><a href="#2-所有成员必须符合字符串索引签名" class="headerlink" title="2. 所有成员必须符合字符串索引签名"></a>2. 所有成员必须符合字符串索引签名</h3><p>![image-20200502142423346](/Users/liwei/Library/Application Support/typora-user-images/image-20200502142423346.png)</p>
<h3 id="3-使用一组有限的字符串字面量"><a href="#3-使用一组有限的字符串字面量" class="headerlink" title="3. 使用一组有限的字符串字面量"></a>3. 使用一组有限的字符串字面量</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> keys = <span class="string">'name'</span> | <span class="string">'age'</span> | <span class="string">'job'</span></span><br><span class="line"><span class="keyword">type</span> Index = &#123; [k <span class="keyword">in</span> keys]?: <span class="built_in">number</span> | <span class="built_in">string</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj: Index = &#123;</span><br><span class="line">    name: <span class="string">'david'</span>,</span><br><span class="line">    age: <span class="number">26</span>,</span><br><span class="line">    job: <span class="string">'frontender'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-同时拥有string和number类型的索引签名"><a href="#4-同时拥有string和number类型的索引签名" class="headerlink" title="4. 同时拥有string和number类型的索引签名"></a>4. 同时拥有string和number类型的索引签名</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: Obj = &#123;&#125;</span><br><span class="line">obj[<span class="string">'a'</span>] = <span class="number">3</span></span><br><span class="line">obj[<span class="number">1</span>] = <span class="string">'1'</span></span><br></pre></td></tr></table></figure>

<h3 id="5-索引签名的嵌套"><a href="#5-索引签名的嵌套" class="headerlink" title="5. 索引签名的嵌套"></a>5. 索引签名的嵌套</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NestedCSS &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;  <span class="comment">// 在strictNullChecks = false时，索引签名可以为undefined</span></span><br><span class="line">    [selector: <span class="built_in">string</span>]: <span class="built_in">string</span> | NestedCSS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> example: NestedCSS = &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'.subclass'</span>: &#123;</span><br><span class="line">        color: <span class="string">'blue'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽量不要用这种方式把字符串索引签名与有效变量混合使用。否则，如果属性名称中有拼写错误，这个错误将不会被捕获。</p>
<p>![image-20200502143859937](/Users/liwei/Library/Application Support/typora-user-images/image-20200502143859937.png)</p>
<p>相反，我们要把索引签名分离到自己的属性里，如命名为nest，或children、subnodes等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NestedCSS &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;  <span class="comment">// 在strictNullChecks = false时，索引签名可以为undefined</span></span><br><span class="line">    nest?: &#123;</span><br><span class="line">        [selector: <span class="built_in">string</span>]: NestedCSS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> example: NestedCSS = &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    nest: &#123;</span><br><span class="line">        <span class="string">'.subclass'</span>: &#123;</span><br><span class="line">            color: <span class="string">'blue'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'.subclass1'</span>: &#123;</span><br><span class="line">            color: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候如果属性名出现拼写错误就能正常进行错误提示了</p>
<p>![image-20200502144259093](/Users/liwei/Library/Application Support/typora-user-images/image-20200502144259093.png)</p>
<h3 id="6-从索引签名中排除某些属性"><a href="#6-从索引签名中排除某些属性" class="headerlink" title="6. 从索引签名中排除某些属性"></a>6. 从索引签名中排除某些属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FieldState = &#123;</span><br><span class="line">    value: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FormState = &#123; isValid: <span class="built_in">boolean</span> &#125; &amp; &#123; [fieldName: <span class="built_in">string</span>]: FieldState&#125;</span><br><span class="line"><span class="comment">// 尽管可以这么来排除属性声明一种TypeScript类型， 但是不能使用该类型进行对象创建</span></span><br><span class="line"><span class="keyword">const</span> form: FormState = &#123;</span><br><span class="line">    isValid: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20200502145046101](/Users/liwei/Library/Application Support/typora-user-images/image-20200502145046101.png)</p>
<h2 id="4-20-错误处理"><a href="#4-20-错误处理" class="headerlink" title="4.20 错误处理"></a>4.20 错误处理</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  value: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123;</span><br><span class="line">  error?: <span class="built_in">string</span>;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; <span class="number">0</span> || value &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; error: <span class="string">"Invalid Value"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-21-混合"><a href="#4-21-混合" class="headerlink" title="4.21 混合"></a>4.21 混合</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数类型</span></span><br><span class="line"><span class="keyword">type</span> Constructor&lt;T = &#123;&#125;&gt; = <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性的混合实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimesTamped</span>&lt;<span class="title">TBase</span> <span class="title">extends</span> <span class="title">Constructor</span>&gt;(<span class="params">Base: TBase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> Base &#123;</span><br><span class="line">        timestamp = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性和方法的混合实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Activatable</span>&lt;<span class="title">TBase</span> <span class="title">extends</span> <span class="title">Constructor</span>&gt;(<span class="params">Base: TBase</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> Base &#123;</span><br><span class="line">        isActivated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        activated()&#123;</span><br><span class="line">            <span class="keyword">this</span>.isActivated = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deactivated()&#123;</span><br><span class="line">            <span class="keyword">this</span>.isActivated = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单类</span></span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name?: <span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过混合获得有时间戳的用户</span></span><br><span class="line"><span class="keyword">const</span> TimestampUser = TimesTamped(User);</span><br><span class="line"><span class="keyword">const</span> timestampUser = <span class="keyword">new</span> TimestampUser();</span><br><span class="line"><span class="built_in">console</span>.log(timestampUser.timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过混合获取有时间戳并可以激活禁用的用户</span></span><br><span class="line"><span class="keyword">const</span> TimestampActivatedUser = TimesTamped(Activatable(User));</span><br><span class="line"><span class="keyword">const</span> timestampActivatedUser = <span class="keyword">new</span> TimestampActivatedUser(<span class="string">'david'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(timestampActivatedUser.name, timestampActivatedUser.timestamp)</span><br></pre></td></tr></table></figure>

<h2 id="4-22-ThisType"><a href="#4-22-ThisType" class="headerlink" title="4.22 ThisType"></a>4.22 ThisType</h2><p>通过ThisType，我们可以在对象字面量中输入this，并提供通过上下文类型控制this类型的便捷方式，它只有在–noImplicitThis的选项下才有效。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ObjectDescriptor&lt;D, M&gt; = &#123;</span><br><span class="line">  data?: D;</span><br><span class="line">  methods: M &amp; ThisType&lt;D &amp; M&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeObject</span>&lt;<span class="title">D</span>, <span class="title">M</span>&gt;(<span class="params">desc: ObjectDescriptor&lt;D, M&gt;</span>): <span class="title">D</span> &amp; <span class="title">M</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data: object = desc.data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> methods: object = desc.methods;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...data, ...methods &#125; <span class="keyword">as</span> D &amp; M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = makeObject(&#123;</span><br><span class="line">  data: &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    moveBy(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x += dx;</span><br><span class="line">      <span class="keyword">this</span>.y += dy;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.x = <span class="number">10</span>;</span><br><span class="line">obj.y = <span class="number">20</span>;</span><br><span class="line">obj.moveBy(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.x, obj.y)</span><br></pre></td></tr></table></figure>

<h1 id="五-关于JSX"><a href="#五-关于JSX" class="headerlink" title="五.关于JSX"></a>五.关于JSX</h1><p>JSX允许用户在JavaScript中书写类似于HTML的视图代码，因此你可以这样做</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端资源整理</title>
    <url>/2020/06/04/2020-2020-06-04-%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a>JavaScript相关</h1><p><a href="https://caniuse.com/" target="_blank" rel="noopener">JavaScript语法兼容性查询网站</a></p>
<p><a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">ES语法兼容性查询网站</a></p>
<p><a href="https://zh.javascript.info/" target="_blank" rel="noopener">JavaScript现代教程</a> </p>
<p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6阮一峰教程</a>  </p>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">NodeJS入门</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/30333791" target="_blank" rel="noopener">JavaScript书籍推荐</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式教程</title>
    <url>/2020/06/23/2020-2020-06-22-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p>
<p>搜索模式可用于文本搜索和文本替换。</p>
<h1 id="1-什么是正则表达式？"><a href="#1-什么是正则表达式？" class="headerlink" title="1. 什么是正则表达式？"></a>1. 什么是正则表达式？</h1><p>正则表达式是由一个字符序列形成的搜索模式。</p>
<p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>
<p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<h1 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/正则表达式主体/修饰符(可选)</span><br></pre></td></tr></table></figure>

<p>其中修饰符是可选的。</p>
<p><strong>初探正则表达式的魅力</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello2200world6688"</span>;</span><br><span class="line"><span class="comment">// 我们要找到字符串str中的数字并拼接成新的字符串</span></span><br><span class="line"><span class="comment">// 不使用正则表达式的话</span></span><br><span class="line"><span class="built_in">console</span>.log([...str].filter(<span class="function"><span class="params">a</span> =&gt;</span> !<span class="built_in">Number</span>.isNaN(<span class="built_in">parseInt</span>(a))).join(<span class="string">""</span>));</span><br><span class="line"><span class="comment">// 如果使用正则表达式可以很轻松实现</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/\d/g</span>).join(<span class="string">""</span>));</span><br></pre></td></tr></table></figure>

<h1 id="3-正则表达式的创建"><a href="#3-正则表达式的创建" class="headerlink" title="3. 正则表达式的创建"></a>3. 正则表达式的创建</h1><ol>
<li><p>时候用字面量<br>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d/g</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\d, "</span>g<span class="string">");</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="4-选择符的使用"><a href="#4-选择符的使用" class="headerlink" title="4. 选择符的使用"></a>4. 选择符的使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/a|u/</span>);  <span class="comment">// 表示监测字符串中a或者u是否存在, 也可以写成这样console.log([au]);表示匹配中括号中其中一个字符</span></span><br><span class="line"><span class="keyword">let</span> tel = <span class="string">"010-9999999"</span>;</span><br><span class="line"><span class="comment">// 下面的检测放阿飞010也为true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/010|020\-\d&#123;7,8&#125;/</span>.test(tel));</span><br><span class="line"><span class="comment">//可以写成这样</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/010\-\d&#123;7,8&#125;|020\-\d&#123;7,8&#125;/</span>.test(tel));</span><br><span class="line"><span class="comment">// 更好的是使用原子组,用小括号包围的被视为一组，但是如果是abc010-9999999还是检测为true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(010|020)\-\d&#123;7,8&#125;/</span>.test(tel));</span><br><span class="line"><span class="comment">// 针对上述问题修改</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^(010|020)\-\d&#123;7,8&#125;$/</span>.test(<span class="string">"abc010-9999999"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="5-字符的转义"><a href="#5-字符的转义" class="headerlink" title="5. 字符的转义"></a>5. 字符的转义</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .表示除换行外任意字符 \.则表示普通的.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+\.\d+/</span>.test(<span class="number">23.34</span>));</span><br><span class="line"><span class="comment">// 如果用构造函数的话对\d也需要转义</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\d+\\.\\d+"</span>).test(<span class="number">23.34</span>));</span><br><span class="line"><span class="comment">// 如匹配一个网址, 左斜杠需要转义</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">"https://www.baidu.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/https?:\/\/\w+\.\w+\.\w+/</span>.test(url));</span><br></pre></td></tr></table></figure>

<h1 id="6-字符的边界约束"><a href="#6-字符的边界约束" class="headerlink" title="6. 字符的边界约束"></a>6. 字符的边界约束</h1><p>使用<code>^</code>表示起始， 使用<code>$</code>表示结束</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^\d+$/</span>.test(<span class="string">"1213"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^[a-z]&#123;3,6&#125;$/</span>.test(<span class="string">"abc"</span>));</span><br></pre></td></tr></table></figure>

<h1 id="7-数值与元字符"><a href="#7-数值与元字符" class="headerlink" title="7. 数值与元字符"></a>7. 数值与元字符</h1><p><code>\d</code>匹配数值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"helloworld 2020"</span>.match(<span class="regexp">/\d+/g</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"张三:010-9999999,李四:020-8888888"</span>.match(<span class="regexp">/\d&#123;3&#125;-\d&#123;7,8&#125;/g</span>));</span><br><span class="line"><span class="comment">// 排除,下面使用^排除掉原子组中的字符，进而取出中文字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"张三:010-9999999,李四:020-8888888"</span>.match(<span class="regexp">/[^-\d:,]+/g</span>));</span><br></pre></td></tr></table></figure>

<p><code>\D</code>表示非数值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"123hello"</span>.match(<span class="regexp">/\D+/g</span>));</span><br></pre></td></tr></table></figure>

<p><code>\s</code>表示空白（包括空格，换行，制表符等）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\s/</span>.test(<span class="string">" hello"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>\S</code>表示非空白符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\S/</span>);</span><br></pre></td></tr></table></figure>

<p><code>[\s\S]</code>表示任意字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[\s\S]+/</span>.test(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure>

<p><code>\w</code>表示字母，数字，下划线</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">"123456789@qq.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(email.match(<span class="regexp">/^\w+@\w+\.\w+$/</span>));</span><br></pre></td></tr></table></figure>

<p><code>\W</code>元字符用于查找非单词字符。</p>
<p>单词字符包括：a-z、A-Z、0-9，以及下划线。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"helloworld100%"</span>.match(<span class="regexp">/\W+/g</span>)); <span class="comment">// ['%!']</span></span><br></pre></td></tr></table></figure>

<p><code>.</code>点元字符表示除换行符外任意字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello123_\n===++"</span>.match(<span class="regexp">/.+/g</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用s单行模式进行匹配，下面使用模板字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  helloworld</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/.+/</span>s)[<span class="number">0</span>]);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> hello</span></span><br><span class="line"><span class="comment"> helloworld</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空格是普通字符，可以直接输入也可以使用\s进行匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"010 - 8888888"</span>).match(<span class="regexp">/\d+ - \d&#123;8&#125;/</span>);</span><br></pre></td></tr></table></figure>

<p><strong>匹配所有字符</strong></p>
<p>可以使用<code>[\s\S]</code>或者<code>[\d\D]</code></p>
<h1 id="8-模式修正符"><a href="#8-模式修正符" class="headerlink" title="8. 模式修正符"></a>8. 模式修正符</h1><p><code>i</code>不区分大小写</p>
<p><code>g</code>全局匹配(不使用则匹配到1项即停止)</p>
<p> <code>s</code>单行匹配</p>
<p><code>m</code>把多行文本的每一行单独处理, </p>
<p><code>u</code>模式用来处理宽字节字符（4字节）</p>
<p><code>y</code>模式连续满足条件的匹配(如<code>/\u/y</code>在执行匹配时候需要保证每一次继续匹配需要连续满足条件)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"helloHELLO"</span>.match(<span class="regexp">/he/ig</span><span class="regexp">/));</span></span><br></pre></td></tr></table></figure>

<p>下面是一个使用<code>m</code>模式的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string"> #1 js,200元 #</span></span><br><span class="line"><span class="string"> #2 php,300元 #</span></span><br><span class="line"><span class="string"> #9 baidu.com # 百度</span></span><br><span class="line"><span class="string"> # 3 node.js,180元 #</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.match(<span class="regexp">/^\s*#\d+\s+.+\s+#$/gm</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line">arr = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  v = v.replace(<span class="regexp">/\s*#\d+\s*/</span>).replace(<span class="regexp">/\s*#/</span>, <span class="string">""</span>);</span><br><span class="line">  <span class="keyword">let</span> [name, price] = v.split(<span class="string">","</span>);</span><br><span class="line">  <span class="keyword">return</span> [name, price];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(arr, <span class="literal">null</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h1 id="9-字符属性和中文的匹配"><a href="#9-字符属性和中文的匹配" class="headerlink" title="9.字符属性和中文的匹配"></a>9.字符属性和中文的匹配</h1><p><strong>字符属性</strong></p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\p{L}</td>
<td>所有字母</td>
</tr>
<tr>
<td>\p{N}</td>
<td>所有数字，类似于 \d</td>
</tr>
<tr>
<td>[\p{N}\p{L}]</td>
<td>所有数字和所有字母，类似于 \w</td>
</tr>
<tr>
<td>\P{L}</td>
<td>不是字母</td>
</tr>
<tr>
<td>\P{N}</td>
<td>不是数字</td>
</tr>
<tr>
<td>\p{P}</td>
<td>匹配标点符号</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello123"</span>.match(<span class="regexp">/\p&#123;L&#125;+/gu</span>)); <span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 匹配标点符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello,12!3?"</span>).match(<span class="regexp">/\p&#123;P&#125;+/gu</span>); <span class="comment">// [',','!', '?']</span></span><br></pre></td></tr></table></figure>

<p><strong>使用字符属性Script来根据语言系统查找对应字符</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\p&#123;sc=Han&#125;/gu</span>);  <span class="comment">// 中文</span></span><br></pre></td></tr></table></figure>

<h1 id="10-lastIndex属性的使用"><a href="#10-lastIndex属性的使用" class="headerlink" title="10. lastIndex属性的使用"></a>10. lastIndex属性的使用</h1><p>定义开始检索的位置, 需要使用<code>g</code>模式，否则lastIndex属性一直为0, 需要查看位置信息等属性时候需要使用<code>exec</code>来进行正则匹配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w/g</span>;</span><br><span class="line"><span class="keyword">while</span>((res = reg.exec(<span class="string">"hello world"</span>)))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.lastIndex);</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-使用y模式"><a href="#11-使用y模式" class="headerlink" title="11.使用y模式"></a>11.使用y模式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string"> QQ群:11111111, 22222222, 333333333</span></span><br><span class="line"><span class="string"> 欢迎入群， 欢迎入群</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d+),?/y</span>;</span><br><span class="line">reg.lastIndex = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">let</span> qq = [];</span><br><span class="line"><span class="keyword">while</span>((res = reg.exec(str))) qq.push(res[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(qq);</span><br></pre></td></tr></table></figure>

<h1 id="12-原子组的基本使用"><a href="#12-原子组的基本使用" class="headerlink" title="12.原子组的基本使用"></a>12.原子组的基本使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="string">'2020-02-23'</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d&#123;4&#125;[-\/]\d&#123;2&#125;[-\/]\d&#123;2&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(date););</span><br><span class="line"><span class="comment">// 可以使用原子组复用规则</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/^\d&#123;4&#125;([-\/]\d&#123;2&#125;\1\d&#123;2&#125;)/</span>;   <span class="comment">// \1 即复用[-\/]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(date));  <span class="comment">// 和上述写法等效</span></span><br></pre></td></tr></table></figure>

<p><strong>区间匹配</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]+/g</span>.test(<span class="string">"2020"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-z]+/g</span>.test(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>排除匹配</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"张三:010-88888888,李四:020-99999999"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[^\d:\-,]+/g</span>)); <span class="comment">// ['张三', '李四']</span></span><br></pre></td></tr></table></figure>

<p><strong>原子组字符不解析</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"(hello).+"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/[(.+)]/gi</span>)); <span class="comment">// ( ) . +均被视为普通字符处理</span></span><br></pre></td></tr></table></figure>

<p><strong>邮箱验证中原子组的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="string">"123456789@163.com.cn"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+(\.([a-zA-Z]&#123;2,4&#125;))+$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(email)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>使用原子组完成替换操作</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">	&lt;h1&gt;hello&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;span&gt;hello&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;hello&lt;/h2&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;([\s\S]*)&lt;\/\1&gt;/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">`&lt;p&gt;$2&lt;/p&gt;`</span>));</span><br><span class="line"><span class="comment">// 我们对于分组在replace第二参数使用函数时候也能够获取到分组内的匹配值</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, (p0,p1,p2) =&gt; <span class="string">`&lt;p&gt;<span class="subst">$&#123;p2&#125;</span>&lt;/p&gt;`</span>);</span><br></pre></td></tr></table></figure>

<p><strong>嵌套分组与不记录分组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string"> https://www.baidu.com</span></span><br><span class="line"><span class="string"> http://google.com</span></span><br><span class="line"><span class="string"> https://4399.com</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/https?:\/\/((?:\w+\.)?\w+\.(?:com|org|cn))/gi</span>;  <span class="comment">// 原子组内的?:表示该组不被记录分组，即不能通过$1,$2等方式获取到</span></span><br></pre></td></tr></table></figure>



<h1 id="13-使用正则操纵DOM元素"><a href="#13-使用正则操纵DOM元素" class="headerlink" title="13.使用正则操纵DOM元素"></a>13.使用正则操纵DOM元素</h1><p>如删除页面中所有的h1-h6标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let body = document.body;</span><br><span class="line">let reg = /&lt;(h[<span class="number">1</span>-<span class="number">6</span>])&gt;[\s\S]*&lt;\/\<span class="number">1</span>&gt;/;</span><br><span class="line">body.innerHTML = body.innerHTML.replace(reg, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p><strong>批量正则验证</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"password"</span> id=<span class="string">"password"</span>&gt;</span><br><span class="line">   &lt;span id=<span class="string">"result"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">   &lt;script&gt;</span></span><br><span class="line"><span class="regexp">       document.getElementById("password").addEventListener("keyup", function()&#123;</span></span><br><span class="line"><span class="regexp">           let reg = [/[\w\-]&#123;5,10&#125;/</span>, /[A-Z].&#123;<span class="number">4</span>,<span class="number">9</span>&#125;/];</span><br><span class="line">           <span class="keyword">if</span>(reg.every(<span class="function"><span class="params">e</span> =&gt;</span> e.test(<span class="keyword">this</span>.value)))&#123;  <span class="comment">// every所有元素回调均返回true,结果才为true</span></span><br><span class="line">               <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = <span class="string">"验证成功"</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = <span class="string">"验证失败"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="14-禁止贪婪"><a href="#14-禁止贪婪" class="headerlink" title="14. 禁止贪婪"></a>14. 禁止贪婪</h1><p>通过在<code>+</code>, <code>*</code>和<code>?</code>后添加<code>?</code>来达到禁止贪婪的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/str+?<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>str*?<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span>str??<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p><strong>标签替换中的禁止贪婪的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">      &lt;span&gt;hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;world&lt;/</span>span&gt;</span><br><span class="line">      &lt;span&gt;hahaha&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/m</span>ain&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      <span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>);</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/&lt;span&gt;([\s\S]*?)&lt;\/span&gt;/gi</span>; <span class="comment">// 在*后添加?禁止贪婪,要不然会匹配到main中所有内容</span></span><br><span class="line">      main.innerHTML = main.innerHTML.replace(reg, (v,p1) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">`&lt;h4 style="color: red;"&gt;<span class="subst">$&#123;p1&#125;</span>&lt;/h4&gt;`</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="15-matchAll"><a href="#15-matchAll" class="headerlink" title="15.matchAll"></a>15.matchAll</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Veniam dolorum minima ipsam at nemo, possimus accusantium consectetur error suscipit harum quidem consequatur repellendus reprehenderit quisquam architecto praesentium voluptate? Soluta, est?&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"> &lt;h1&gt;hello&lt;/</span>h1&gt;</span><br><span class="line"> &lt;h2&gt;world&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp"> &lt;h3&gt;&lt;/</span>h3&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">     <span class="keyword">let</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">     <span class="keyword">let</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;([\s\S]+?)&lt;\/\1&gt;/gi</span>;</span><br><span class="line">     <span class="keyword">let</span> it = body.innerHTML.matchAll(reg);</span><br><span class="line">     <span class="keyword">let</span> contents = [];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> it)&#123;</span><br><span class="line">         contents.push(item[<span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.table(contents);</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>为低端浏览器定义原型方法match</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.matchAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">this</span>.match(reg);</span><br><span class="line">  <span class="keyword">if</span>(res)&#123;</span><br><span class="line">     <span class="keyword">let</span> str = <span class="keyword">this</span>.replace(res[<span class="number">0</span>]).replace(res[<span class="number">0</span>], <span class="string">'^'</span>.repeat(res[<span class="number">0</span>].length));</span><br><span class="line">     <span class="keyword">let</span> match = str.match(reg) || [];</span><br><span class="line">     <span class="keyword">return</span> [res, match];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;p&gt;hello&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;h1&gt;world&lt;/h1&gt;</span></span><br><span class="line"><span class="string"> &lt;h2&gt;hahaha&lt;/h2&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;([\s\S]+?)&lt;\/\1&gt;/i</span>;</span><br><span class="line"><span class="keyword">let</span> it = str.matchAll(reg);</span><br><span class="line"><span class="keyword">let</span> contents = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> it)&#123;</span><br><span class="line">  contents.push(item[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(contents);</span><br></pre></td></tr></table></figure>

<h1 id="16-字符串正则方法"><a href="#16-字符串正则方法" class="headerlink" title="16. 字符串正则方法"></a>16. 字符串正则方法</h1><table>
<thead>
<tr>
<th>方法名</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>test</td>
<td>测试字符串是否满足正则规则，返回值为boolean</td>
</tr>
<tr>
<td>match</td>
<td>配合g模式符进行全局匹配不返回匹配细节，不加g模式客户返回第一个匹配位置的细节</td>
</tr>
<tr>
<td>matchALl</td>
<td>全局匹配，返回一个迭代器,使用for…of循环可以获取所有匹配项的细节</td>
</tr>
<tr>
<td>exec</td>
<td>需要配置g模式使用，否则会一直在同一位置进行匹配，使用while循环进行全局匹配时候如果忘记加g模式符会导致死循环, 每次执行exec, reg对象的lastIndex会进行更新</td>
</tr>
</tbody></table>
<h1 id="17-’-amp-在字符串替换中的使用（了解）"><a href="#17-’-amp-在字符串替换中的使用（了解）" class="headerlink" title="17. $`, $’, $&amp;在字符串替换中的使用（了解）"></a>17. $`, $’, $&amp;在字符串替换中的使用（了解）</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"=前端梦%"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/前端梦/</span>;</span><br><span class="line"><span class="comment">// $&amp;代表匹配到的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">"$&amp;"</span>)); <span class="comment">// =前端梦%</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">"$`"</span>)); <span class="comment">// ==%</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="string">"$'"</span>)); <span class="comment">// =%%</span></span><br></pre></td></tr></table></figure>

<p><strong>$&amp;</strong>的一个使用实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">  	前端梦，前端梦</span><br><span class="line">  &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">  	const main = document.querySelector("body main");</span></span><br><span class="line"><span class="regexp">    main.innerHTML = main.innerHTML.replace(/</span>前端梦/g, <span class="string">"&lt;a href='www.qianduanmeng.com'&gt;$&amp;&lt;/a&gt;"</span>);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<h1 id="18-原子组在替换中的小技巧"><a href="#18-原子组在替换中的小技巧" class="headerlink" title="18. 原子组在替换中的小技巧"></a>18. 原子组在替换中的小技巧</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;a href=<span class="string">"http://www.baidu.com"</span>&gt;百度&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;a href="http:/</span><span class="regexp">/frontender.com"&gt;前端人&lt;/</span>a&gt;</span><br><span class="line">        &lt;a href=<span class="string">"http://w3c.org"</span>&gt;w3c&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/m</span>ain&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 我们要给http后没有s的添加s，没有www的添加www</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>);</span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/(&lt;a.*href=['"])(http)(:\/\/)(www\.)?/gi</span>;</span><br><span class="line">        main.innerHTML = main.innerHTML.replace(reg, (...args) =&gt; &#123;</span><br><span class="line">            args[<span class="number">2</span>] += <span class="string">'s'</span>;</span><br><span class="line">            args[<span class="number">4</span>] = args[<span class="number">4</span>] || <span class="string">"www."</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(args);</span><br><span class="line">            <span class="keyword">return</span> args.slice(<span class="number">1</span>,<span class="number">5</span>).join(<span class="string">""</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="19-原子组的别名"><a href="#19-原子组的别名" class="headerlink" title="19. 原子组的别名"></a>19. 原子组的别名</h1><p>可以在原子组内使用<code>?&lt;别名&gt;</code>的方式来为每个原子组定义别名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;world&lt;/</span>h2&gt;</span><br><span class="line">    &lt;h3&gt;hahaha&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        let body = document.body;</span></span><br><span class="line"><span class="regexp">        const reg = /</span>&lt;(h[<span class="number">1</span><span class="number">-6</span>])&gt;(?<span class="xml"><span class="tag">&lt;<span class="name">con</span>&gt;</span>.*?)<span class="tag">&lt;<span class="name">\</span>/\<span class="attr">1</span>&gt;</span>/gi;</span></span><br><span class="line">        body.innerHTML = body.innerHTML.replace(reg, "&lt;h4&gt;$&lt;con&gt;&lt;/h4&gt;");</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用原子组别名来优化正则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;a href=<span class="string">"https://www.baidu.com"</span>&gt;百度&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;a href="https:/</span><span class="regexp">/www.sina.com"&gt;新浪&lt;/</span>a&gt;</span><br><span class="line">        &lt;a href=<span class="string">"http://frontender"</span>&gt;前端人&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/m</span>ain&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"body main"</span>);</span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/&lt;a.*?href=(['"])(?&lt;link&gt;.*?)\1&gt;(?&lt;title&gt;.*?)&lt;\/a&gt;/gi</span>;</span><br><span class="line">        <span class="keyword">const</span> links = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> it <span class="keyword">of</span> main.innerHTML.matchAll(reg))&#123;</span><br><span class="line">            links.push(it.groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(links);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<h1 id="20-先行断言匹配-可以理解为后面是什么的"><a href="#20-先行断言匹配-可以理解为后面是什么的" class="headerlink" title="20. ?=先行断言匹配(可以理解为后面是什么的)"></a>20. ?=先行断言匹配(可以理解为后面是什么的)</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        欢迎来到前端人，为大家分享web前端开发常用技术教程</span><br><span class="line">    &lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        let main = document.querySelector("main");</span></span><br><span class="line"><span class="regexp">        let reg = /</span>web前端(?=开发)/g;</span><br><span class="line">        main.innerHTML = main.innerHTML.replace(reg, <span class="string">`&lt;a href="www.baidu.com"&gt;$&amp;&lt;/a&gt;`</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p>上面的正则表示要匹配后面是开发的web前端字样，断言匹配可以理解为是正则表达式的条件判断</p>
<p><strong>使用先行断言匹配来规范价格</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lessons = <span class="string">`</span></span><br><span class="line"><span class="string">    js,200元,300次</span></span><br><span class="line"><span class="string">    php,300.00元,100次</span></span><br><span class="line"><span class="string">    node.js,180元,260次</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d+)(.00)?(?=元)/gi</span>;</span><br><span class="line">lessons = lessons.replace(reg, (v, ...args) =&gt; &#123;</span><br><span class="line">    args[<span class="number">1</span>] = args[<span class="number">1</span>] || <span class="string">'.00'</span>;</span><br><span class="line">    <span class="keyword">return</span> args.splice(<span class="number">0</span>,<span class="number">2</span>).join(<span class="string">""</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lessons);</span><br></pre></td></tr></table></figure>

<h1 id="21-lt-后行断言-可以理解成前面是什么的"><a href="#21-lt-后行断言-可以理解成前面是什么的" class="headerlink" title="21. ?&lt;=后行断言(可以理解成前面是什么的)"></a>21. ?&lt;=后行断言(可以理解成前面是什么的)</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello123world456"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;=hello)\d+/gi</span>; <span class="comment">// 匹配前面是hello的数字</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>

<p>结合使用前后行断言批量替换链接地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">"https://www.baidu.com"</span>&gt;百度&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="https:/</span><span class="regexp">/yahoo.com"&gt;雅虎&lt;/</span>a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/(?&lt;=href=(['"])).+(?=\1)/gi</span>;</span><br><span class="line">        body.innerHTML = body.innerHTML.replace(reg, <span class="string">"https://demo.com"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用断言模糊电话号码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = <span class="string">`</span></span><br><span class="line"><span class="string">    Tom: 1234567890</span></span><br><span class="line"><span class="string">    Jack: 9876543210</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;=\d&#123;6&#125;)\d&#123;4&#125;/gi</span>;</span><br><span class="line">users = users.replace(reg, v =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"*"</span>.repeat(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(users);</span><br></pre></td></tr></table></figure>

<h1 id="22-负向先行断言-后面不是什么的"><a href="#22-负向先行断言-后面不是什么的" class="headerlink" title="22. ?!负向先行断言(后面不是什么的)"></a>22. ?!负向先行断言(后面不是什么的)</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello123hdms"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[a-z]+(?!\d+)$/</span>;  <span class="comment">// 取得后面不是数字的字母</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>

<p><strong>使用断言限制用户名关键词</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> id=<span class="string">"username"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> username = <span class="built_in">document</span>.querySelector(<span class="string">"[name='username']"</span>);</span><br><span class="line">        username.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> reg = <span class="regexp">/^(?!.*lee.*)[a-z]&#123;5,6&#125;$/i</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(reg.test(<span class="keyword">this</span>.value));</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<h1 id="23-lt-负向后行断言-前面不是什么的"><a href="#23-lt-负向后行断言-前面不是什么的" class="headerlink" title="23. ?&lt;!负向后行断言(前面不是什么的)"></a>23. ?&lt;!负向后行断言(前面不是什么的)</h1><p>下面代码匹配前面不是hello的数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello123world456"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;!hello)\d+/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br></pre></td></tr></table></figure>

<h1 id="24-使用断言排除法统一数据"><a href="#24-使用断言排除法统一数据" class="headerlink" title="24. 使用断言排除法统一数据"></a>24. 使用断言排除法统一数据</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;main&gt;</span><br><span class="line">        &lt;a href=<span class="string">"https://www.baidu.com/1.jpg"</span>&gt;<span class="number">1.</span>jpg&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;a href="https:/</span><span class="regexp">/oss.hello.com/</span><span class="number">2.</span>jpg<span class="string">"&gt;2.jpg&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;a href="</span>https:<span class="comment">//cdn.world.com/3.jpg"&gt;3.jpg&lt;/a&gt;</span></span><br><span class="line">        &lt;a href=<span class="string">"https://haha.com/4.jpg"</span>&gt;<span class="number">4.</span>jpg&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/m</span>ain&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>);</span><br><span class="line">        <span class="keyword">const</span> reg = <span class="regexp">/https:\/\/([a-z]+)?(?&lt;!oss)\..+?(?=\/)/gi</span>; <span class="comment">// 排除掉开头是oss的地址，把不是oss开头的地址替换为https://oss.bestcdn.com</span></span><br><span class="line">        main.innerHTML = main.innerHTML.replace(reg, v =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'https://oss.bestcdn.com'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式设计及Bootstrap框架的使用</title>
    <url>/2020/06/03/2020-2020-06-03-%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一-响应式元素及媒介"><a href="#一-响应式元素及媒介" class="headerlink" title="一. 响应式元素及媒介"></a>一. 响应式元素及媒介</h1><h2 id="1-1-基于宽度百分比的图像缩放"><a href="#1-1-基于宽度百分比的图像缩放" class="headerlink" title="1.1 基于宽度百分比的图像缩放"></a>1.1 基于宽度百分比的图像缩放</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.text</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 60%;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.img-wrap</span> &#123;</span></span><br><span class="line">            float: right;</span><br><span class="line">            width: 40%;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">img</span><span class="selector-class">.responsive</span> &#123;</span></span><br><span class="line">            max-width: 100%;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Assumenda modi minima ullam quas eos natus placeat pariatur, deleniti, architecto, alias fugit. Totam illo voluptatum inventore odio, cupiditate enim veritatis praesentium.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/dragon.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"responsive"</span> <span class="attr">alt</span>=<span class="string">"dragon"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Molestiae eligendi sequi rem! Aliquam eaque repellendus necessitatibus? Explicabo consequatur iure, incidunt et laboriosam neque culpa placeat, dignissimos, voluptatibus ab numquam minima.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>原理:</p>
<p>设置在CSS中图像元素的responsive属性会强制该元素100%占据其父元素的空间。当父元素的宽度改变时，图像元素也会相应改变并填充对应的宽度。而属性height:auto的作用在于保证图像自身的高宽比例不会发生变化。</p>
<h2 id="1-2-使视频自适应于屏幕宽度"><a href="#1-2-使视频自适应于屏幕宽度" class="headerlink" title="1.2 使视频自适应于屏幕宽度"></a>1.2 使视频自适应于屏幕宽度</h2><p>如果我们自己自己管理视频源，我们可以通过以下代码来实现视频的自适应效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        video &#123;</span><br><span class="line">            max-width: 100%;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"1920"</span> <span class="attr">height</span>=<span class="string">"1080"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"./video/oceans.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">        Yout browser dost not support the video tag</span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是如果我们的视频托管在YouTube等平台上，我们需要在页面中通过嵌入的Iframe或者object代码片段来进行视频展示， 通过下述代码来进行实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        video &#123;</span><br><span class="line">            max-width: 100%;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.video-wrap</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            padding-bottom: 55%;</span><br><span class="line">            padding-top: 30px;  </span><br><span class="line">            height: 0;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.video-wrap</span> <span class="selector-tag">iframe</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.video-outer-wrap</span> &#123;</span></span><br><span class="line">            width: 640px;</span><br><span class="line">            max-width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"480"</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"./video/oceans.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">        Yout browser dost not support the video tag</span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video-outer-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video-wrap"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://media.w3.org/2010/05/sintel/trailer.mp4"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<p>该方法称为固有比率视频法（Intrinsic Ratiosfor Videos。在元素中所嵌入的视频具有固有的长宽比，并且被赋予了一个绝对位置。这就使得允许视频窗口大小改变的同时，锁定视频长宽比。</p>
<p>一些用来测试视频的地址</p>
<p>1、<a href="https://link.jianshu.com?t=https%3A%2F%2Fmedia.w3.org%2F2010%2F05%2Fsintel%2Ftrailer.mp4" target="_blank" rel="noopener">https://media.w3.org/2010/05/sintel/trailer.mp4</a><br> 2、<a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.w3school.com.cn%2Fexample%2Fhtml5%2Fmov_bbb.mp4" target="_blank" rel="noopener">http://www.w3school.com.cn/example/html5/mov_bbb.mp4</a><br> 3、<a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.w3schools.com%2Fhtml%2Fmovie.mp4" target="_blank" rel="noopener">https://www.w3schools.com/html/movie.mp4</a><br> 4、<a href="https://link.jianshu.com?t=http%3A%2F%2Fclips.vorwaerts-gmbh.de%2Fbig_buck_bunny.mp4" target="_blank" rel="noopener">http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4</a><br> 5、<a href="https://link.jianshu.com?t=https%3A%2F%2Fplayer.vimeo.com%2Fexternal%2F188350983.sd.mp4%3Fs%3D0bdf01fb5f5c66e43ddae76f573cef2a7786de64%26profile_id%3D164" target="_blank" rel="noopener">https://player.vimeo.com/external/188350983.sd.mp4?s=0bdf01fb5f5c66e43ddae76f573cef2a7786de64&amp;profile_id=164</a><br> 6、<a href="https://link.jianshu.com?t=https%3A%2F%2Fplayer.vimeo.com%2Fexternal%2F188355959.sd.mp4%3Fs%3De5eea0f749282013db81a7e5cd047c57e066e2b9%26profile_id%3D164" target="_blank" rel="noopener">https://player.vimeo.com/external/188355959.sd.mp4?s=e5eea0f749282013db81a7e5cd047c57e066e2b9&amp;profile_id=164</a><br> 7、<a href="https://link.jianshu.com?t=https%3A%2F%2Fplayer.vimeo.com%2Fexternal%2F188365455.sd.mp4%3Fs%3D7343acee6a02371b4ffeb25760bcbf4b627ccadd%26profile_id%3D164" target="_blank" rel="noopener">https://player.vimeo.com/external/188365455.sd.mp4?s=7343acee6a02371b4ffeb25760bcbf4b627ccadd&amp;profile_id=164</a><br> 8、<a href="https://link.jianshu.com?t=https%3A%2F%2Fplayer.vimeo.com%2Fexternal%2F188421287.sd.mp4%3Fs%3Dbdbf8a61c40502211971571fef384f52fe79dbbe%26profile_id%3D164" target="_blank" rel="noopener">https://player.vimeo.com/external/188421287.sd.mp4?s=bdbf8a61c40502211971571fef384f52fe79dbbe&amp;profile_id=164</a></p>
<h2 id="1-3-响应式导航"><a href="#1-3-响应式导航" class="headerlink" title="1.3 响应式导航"></a>1.3 响应式导航</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">800px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.small-menu</span> &#123;</span></span><br><span class="line">                display: inline;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.large-menu</span> &#123;</span></span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">801px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1024px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.small-menu</span> &#123;</span></span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.large-menu</span> &#123;</span></span><br><span class="line">                display: inline;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.large-menu</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">                list-style-type: none;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.large-menu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">                display: inline;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">                width: 100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1025px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.small-menu</span> &#123;</span></span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.large-menu</span> &#123;</span></span><br><span class="line">                display: inline;</span><br><span class="line">                float: left;</span><br><span class="line">                width: 20%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">                float: right;</span><br><span class="line">                width: 80%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small-menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"URL"</span> <span class="attr">onchange</span>=<span class="string">"window.location.href=this.form.URL.options[this.form.URL.selectedIndex].value"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"blog.html"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"home.html"</span>&gt;</span>home<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"tutorials.html"</span>&gt;</span>tutorials<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"large-menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"blog.html"</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home.html"</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tutorials.html"</span>&gt;</span>tutorials<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Harum eaque vitae repellat quidem deserunt rem necessitatibus aspernatur corrupti. Odio nesciunt molestias, reiciendis temporibus ipsa blanditiis voluptatem unde suscipit quae recusandae?</span><br><span class="line">            Non, facere quaerat dignissimos rem voluptatum provident tenetur eaque, incidunt magni rerum aliquam. Expedita pariatur, excepturi officiis, dolores voluptate iure suscipit, omnis facere minus sint modi sit distinctio quos temporibus?</span><br><span class="line">            Id, commodi! Harum dolorum itaque, id odio sunt quidem aliquid dignissimos accusantium dicta officia quasi facilis unde eaque nobis obcaecati debitis odit provident illum incidunt doloribus repellat cumque similique aliquam.</span><br><span class="line">            Culpa suscipit consequatur, voluptatem itaque ad cupiditate, non eos voluptatibus, earum nostrum beatae provident in dicta totam nisi autem eaque quos. Libero quas rem cumque commodi vel deleniti recusandae neque.</span><br><span class="line">            Recusandae facilis quis repellat magnam quas! Ipsa, illum! Repudiandae culpa doloribus, accusantium explicabo aliquid, quaerat placeat, error deleniti eos fugiat eaque nostrum laborum atque beatae quae quibusdam possimus aspernatur in.</span><br><span class="line">            Quis explicabo fuga eaque perspiciatis consequuntur rerum corporis incidunt cumque aut ratione labore, praesentium id sapiente maxime dicta facilis architecto fugit error soluta reprehenderit delectus illum animi esse. Error, totam.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-基于尺寸的响应式内边距"><a href="#1-4-基于尺寸的响应式内边距" class="headerlink" title="1.4 基于尺寸的响应式内边距"></a>1.4 基于尺寸的响应式内边距</h2><p>为了衬托一个响应式宽度的图像元素，需要添加相对的内边距。如果使用静态的宽度内边距，图像内边距在较小的浏览器窗口中可能会显得过大，从而与其他附近元素相互挤压，甚至可能将图像挤出屏幕</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.img-wrapper</span> &#123;</span></span><br><span class="line">            width: 25%;</span><br><span class="line">        &#125;</span><br><span class="line">        img &#123;</span><br><span class="line">            max-width: 100%;</span><br><span class="line">            height: auto;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#cccccc</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span>: 3<span class="selector-class">.3</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1732644520,3082118771&amp;fm=26&amp;gp=0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了找到内边距的百分比，使用内边距除以总宽度，即10/280(280为非响应式下图片的宽度)+20=0.033，舍入为3.3%</p>
<h1 id="二-响应式字体"><a href="#二-响应式字体" class="headerlink" title="二. 响应式字体"></a>二. 响应式字体</h1><h2 id="2-1-创建自适应的响应式字体"><a href="#2-1-创建自适应的响应式字体" class="headerlink" title="2.1 创建自适应的响应式字体"></a>2.1 创建自适应的响应式字体</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span><span class="selector-class">.a</span> &#123;</span></span><br><span class="line">                font-size: 3rem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">p</span><span class="selector-class">.a</span> &#123;</span></span><br><span class="line">                font-size: 1rem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Quos, debitis dolorem. Nisi dolores eligendi omnis, odit itaque distinctio reiciendis autem non veritatis ex, facere laborum atque fugiat repudiandae? Quia, eius.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Error et suscipit esse quibusdam minima sunt iure enim, consequatur dicta ab quod non numquam asperiores nobis a doloremque dignissimos harum quae.Aspernatur tempora soluta ab totam, perspiciatis praesentium animi adipisci unde, ad impedit maiores harum est. Nesciunt, nobis, hic architecto quos consequuntur a, ad vero aperiam autem asperiores dicta omnis corrupti?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-使用画布实现文本阴影"><a href="#2-2-使用画布实现文本阴影" class="headerlink" title="2.2 使用画布实现文本阴影"></a>2.2 使用画布实现文本阴影</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"drawCanvas()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">drawCanvas</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line">            ctx.shadowOffsetX = 2;</span><br><span class="line">            ctx.shadowOffsetY = 2;</span><br><span class="line">            ctx.shadowBlur = 2;</span><br><span class="line"><span class="actionscript">            ctx.shadowColor = <span class="string">"rgba(0,0,0,.5)"</span></span></span><br><span class="line"><span class="actionscript">            ctx.font = <span class="string">"20px Times New Roman"</span>;</span></span><br><span class="line"><span class="actionscript">            ctx.fillStyle = <span class="string">"Black"</span>;</span></span><br><span class="line"><span class="actionscript">            ctx.fillText(<span class="string">"This is the canvas"</span>, <span class="number">5</span>, <span class="number">30</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-使用画布实现内侧阴影和外侧阴影"><a href="#2-3-使用画布实现内侧阴影和外侧阴影" class="headerlink" title="2.3 使用画布实现内侧阴影和外侧阴影"></a>2.3 使用画布实现内侧阴影和外侧阴影</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span></span><br><span class="line">        ctx.shadowOffsetX = -1;</span><br><span class="line">        ctx.shadowOffsetY = -1;</span><br><span class="line">        ctx.shadowBlur = 2;</span><br><span class="line"><span class="actionscript">        ctx.shadowColor = <span class="string">"#888888"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.textAlign = <span class="string">"left"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.font = <span class="string">"33px Times New Roman"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.fillStyle = <span class="string">"#666"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.fillText(<span class="string">"This is the canvas"</span>, <span class="number">0</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="actionscript">        ctx.strokeStyle = <span class="string">"#555"</span>;</span></span><br><span class="line">        ctx.linewidth = 2</span><br><span class="line"><span class="actionscript">        ctx.strokeText(<span class="string">"This is the canvas"</span>, <span class="number">2</span>, <span class="number">50</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-使用画布旋转文本"><a href="#2-4-使用画布旋转文本" class="headerlink" title="2.4 使用画布旋转文本"></a>2.4 使用画布旋转文本</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line">        canvas.width = 250;</span><br><span class="line">        canvas.height = 250;</span><br><span class="line"><span class="javascript">        ctx.rotate(<span class="built_in">Math</span>.PI/<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>);</span></span><br><span class="line">        ctx.shadowOffsetX = -1;</span><br><span class="line">        ctx.shadowOffsetY = -1;</span><br><span class="line">        ctx.shadowBlur = 2;</span><br><span class="line"><span class="actionscript">        ctx.shadowColor = <span class="string">"#888888"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.textAlign = <span class="string">"left"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.font = <span class="string">"33px Times New Roman"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.fillStyle = <span class="string">"#666"</span>;</span></span><br><span class="line"><span class="actionscript">        ctx.fillText(<span class="string">"This is the canvas"</span>, <span class="number">0</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="actionscript">        ctx.strokeStyle = <span class="string">"#555"</span>;</span></span><br><span class="line">        ctx.linewidth = 2</span><br><span class="line"><span class="actionscript">        ctx.strokeText(<span class="string">"This is the canvas"</span>, <span class="number">2</span>, <span class="number">50</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-使用CSS3制作3D文本"><a href="#2-5-使用CSS3制作3D文本" class="headerlink" title="2.5  使用CSS3制作3D文本"></a>2.5  使用CSS3制作3D文本</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1 &#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">text-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> <span class="selector-id">#888</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-1px</span> <span class="selector-tag">-1px</span> 0<span class="selector-tag">px</span> <span class="selector-id">#777</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-2px</span> <span class="selector-tag">-2px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#666</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-3px</span> <span class="selector-tag">-3px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#555</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-4px</span> <span class="selector-tag">-4px</span> 2<span class="selector-tag">px</span> <span class="selector-id">#444</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-5px</span> <span class="selector-tag">-5px</span> 3<span class="selector-tag">px</span> <span class="selector-id">#333</span>,</span></span><br><span class="line"><span class="css">                        <span class="selector-tag">-6px</span> <span class="selector-tag">-6px</span> 4<span class="selector-tag">px</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello CSS3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-基于文本遮罩的文本纹理"><a href="#2-6-基于文本遮罩的文本纹理" class="headerlink" title="2.6 基于文本遮罩的文本纹理"></a>2.6 基于文本遮罩的文本纹理</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1 &#123;</span><br><span class="line">            font: 140px "Arail";</span><br><span class="line">            color: blue;</span><br><span class="line"><span class="css">            <span class="selector-tag">text-shadow</span>: 0<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> <span class="selector-id">#f0f0f0</span>;</span></span><br><span class="line">            width: 100%; </span><br><span class="line">            padding: 12% 0 12%;</span><br><span class="line">            margin: 0;</span><br><span class="line">            text-align: center;</span><br><span class="line">            -webkit-mask-image: url("./img/20190525170610357.png");</span><br><span class="line">            mask-image: url("./img/20190525170610357.png");</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        HELLO CSS3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-基于相对字体大小的按钮"><a href="#2-7-基于相对字体大小的按钮" class="headerlink" title="2.7 基于相对字体大小的按钮"></a>2.7 基于相对字体大小的按钮</h2><p>REM是CSS3引入的新字体尺寸单位。是Root EM的简写，意即相对于根元素的字体大小。而EM是相对于父元素的字体大小，因此二者是有区别的。一种使用场景是在某些元素中使用REM，让其获得相对于整个body基本字体大小的值。</p>
<p>原理</p>
<p>字体大小单位REM创建了一个字体大小，该字体大小是相对于在HTML或body元素中的已经声明的基本字体大小而言的，如果未声明基本字体大小，则是相对于内建字体大小的。而通过@media查询的方式则能在不同设备和不同方向下给出实现相对字体大小的解决方案。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        html &#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">font-size</span>: 62<span class="selector-class">.5</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1024px</span>) &#123;</span></span><br><span class="line">            input &#123;</span><br><span class="line">                font-size: 1rem;</span><br><span class="line">                width: 84px;</span><br><span class="line">                padding: 2%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1280px</span>) &#123;</span></span><br><span class="line">            input &#123;</span><br><span class="line">                font-size: 2rem;</span><br><span class="line">                width: 84px;</span><br><span class="line">                padding: 2%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width:</span> <span class="number">480px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;</span></span><br><span class="line">            input &#123;</span><br><span class="line">                font-size: 2rem;</span><br><span class="line">                width: 25%;</span><br><span class="line">                padding: 2%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width:</span> <span class="number">480px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> portrait) &#123;</span></span><br><span class="line">            input &#123;</span><br><span class="line"><span class="css">                <span class="selector-tag">font-size</span>: 2<span class="selector-class">.4rem</span>;</span></span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 2%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Iste at fugiat doloremque voluptates saepe quaerat nam tempora officiis quisquam laborum deserunt dolor, rem ipsa sint vel blanditiis perspiciatis ex rerum!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="三-响应式布局"><a href="#三-响应式布局" class="headerlink" title="三. 响应式布局"></a>三. 响应式布局</h1><h2 id="3-1-基于min-width和max-width属性的响应式布局"><a href="#3-1-基于min-width和max-width属性的响应式布局" class="headerlink" title="3.1 基于min-width和max-width属性的响应式布局"></a>3.1 基于min-width和max-width属性的响应式布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        article &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            max-width: 1280px;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#555</span>;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        h1 &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        img &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: auto;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">            min-width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.three</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.float</span> &#123;</span></span><br><span class="line">            max-width: 350px;</span><br><span class="line">            float: left;</span><br><span class="line">            text-align: justify;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>基于min-width和max-width的响应式实现<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one float"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img//1.png"</span> <span class="attr">alt</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two float"</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Vel esse mollitia soluta exercitationem possimus perspiciatis cum, aut laudantium totam, eveniet numquam, laborum tenetur. Quia nesciunt perspiciatis nostrum dicta aspernatur aut.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"three float"</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam maxime similique dolores commodi libero temporibus, eaque ad consequuntur deleniti sequi architecto totam esse magni consectetur nisi ratione magnam excepturi obcaecati.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-基于媒介查询创建响应式宽度布局"><a href="#3-2-基于媒介查询创建响应式宽度布局" class="headerlink" title="3.2 基于媒介查询创建响应式宽度布局"></a>3.2 基于媒介查询创建响应式宽度布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">960px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">                width: 90%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.comments</span> &#123;</span></span><br><span class="line">                width: 90%;</span><br><span class="line">                padding: 1% 5%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line">                padding: 1% 5%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">961px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1280px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.nav</span> &#123; <span class="attribute">padding</span>:  <span class="number">1%</span> <span class="number">5%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.content</span> &#123; <span class="attribute">width</span>:  <span class="number">60%</span>; &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.comments</span> &#123; <span class="attribute">width</span>:  <span class="number">20%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.content</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.comments</span> &#123;</span></span><br><span class="line">                padding: 1% 5%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1281px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.content</span> &#123; <span class="attribute">width</span>:  <span class="number">60%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.comments</span> &#123; <span class="attribute">width</span>: <span class="number">20%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.content</span>,</span></span><br><span class="line"><span class="css">            <span class="selector-class">.comments</span> &#123;</span></span><br><span class="line">                padding: 1% 1% 1% 0;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.nav</span> &#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                top: 20px;</span><br><span class="line">                left: 0px;</span><br><span class="line">                width: 144px;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nav ul &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">        &#125;</span><br><span class="line">        nav ul li &#123;</span><br><span class="line">            margin: 2px 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span>, <span class="selector-class">.comments</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            text-align: justify;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.comment</span> &#123;</span></span><br><span class="line">            padding-left: 8%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit, amet consectetur adipisicing elit. In omnis quae totam delectus praesentium sequi, corporis accusantium distinctio suscipit ipsa dicta perspiciatis laboriosam aliquid, ab voluptatibus? Provident, autem! Magnam, odit.</span><br><span class="line">        Voluptatibus officia a qui voluptates nulla inventore laudantium quaerat quibusdam earum quo tempore tenetur aliquid, sapiente est quasi praesentium neque velit at blanditiis deleniti? Eligendi id quasi ipsum facere provident.</span><br><span class="line">        Deleniti, aperiam dolores. Eum iusto blanditiis saepe incidunt tempora molestias optio. Unde suscipit quae expedita autem velit in, sequi officiis dolorum veritatis quis! Culpa ex in explicabo, a voluptate iusto.</span><br><span class="line">        Reprehenderit deleniti aliquam doloribus totam, iusto harum ex saepe nostrum, architecto expedita esse non fugiat laudantium soluta quam deserunt, odio voluptatum! Amet earum enim dolorum distinctio ea provident facere vitae.</span><br><span class="line">        Similique laudantium consequuntur nulla nesciunt placeat ex incidunt odio soluta adipisci amet unde voluptatem mollitia illo necessitatibus et earum dicta dolorum repellat accusantium, quae pariatur. Aliquid doloremque eum voluptate fugit!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"comments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Accusantium ipsum quaerat iure unde eum culpa reprehenderit et repellendus dolor. Vel dolorum corrupti sapiente voluptatum a, ipsa quisquam quidem mollitia animi.</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span></span><br><span class="line">                评论的评论</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-基于媒介查询改变图片大小"><a href="#3-3-基于媒介查询改变图片大小" class="headerlink" title="3.3  基于媒介查询改变图片大小"></a>3.3  基于媒介查询改变图片大小</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">960px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line">                padding: 0 5%;</span><br><span class="line">                width: 90%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line">                width: 90%;</span><br><span class="line">                height: auto;</span><br><span class="line">                padding: 5%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">                width: 90%;</span><br><span class="line">                padding: 5%;</span><br><span class="line">                text-align: justify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">961px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1280px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line">                padding: 0 5%;</span><br><span class="line">                width: 90%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line">                width: 50%;</span><br><span class="line">                height: auto;</span><br><span class="line">                max-width: 600px;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">                width: 50%;</span><br><span class="line">                text-align: justify;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1281px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line">                padding: 0 5%;</span><br><span class="line">                width: 90%;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line">                width: 40%;</span><br><span class="line">                height: auto;</span><br><span class="line">                max-width: 500px;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.wrap</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line">                width: 60%;</span><br><span class="line">                text-align: justify;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/dragon.jpg"</span> <span class="attr">alt</span>=<span class="string">"dragon"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Animi ipsum doloremque, laboriosam fugiat cum sunt quaerat fugit enim ipsa cumque exercitationem, similique rerum impedit perspiciatis dignissimos reiciendis officiis aliquid autem?</span><br><span class="line">            Numquam nulla iusto suscipit natus eligendi iure fugiat amet quasi sit. Aperiam tempore quos est et, quam, vero consequuntur eius consequatur, culpa unde ratione iste atque quisquam ex sit nulla?</span><br><span class="line">            Eos odit ducimus officiis iste architecto at corrupti pariatur facilis earum aperiam maiores in sequi perferendis, illo esse dolor quo hic doloremque! Magnam odio accusamus doloribus exercitationem repellendus enim corporis?</span><br><span class="line">            Labore quo necessitatibus qui placeat ad explicabo consectetur eos dolores. Voluptate, architecto libero quaerat laborum eum tempore! Adipisci, maxime explicabo corrupti molestias, harum, ea blanditiis asperiores sint eum accusamus recusandae!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器根据自身窗口大小应用对应的媒介查询中的相关设置，使元素能够呈现出不同的width和height属性。这样，在不同尺寸的设备窗口中都得到合适大小的图片。但是如果原始图片非常大，在服务器端改变图片尺寸会是一个好的备选方案。</p>
<h2 id="3-4-基于媒介查询隐藏元素"><a href="#3-4-基于媒介查询隐藏元素" class="headerlink" title="3.4 基于媒介查询隐藏元素"></a>3.4 基于媒介查询隐藏元素</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.foo</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.bar</span> &#123;</span></span><br><span class="line">            background-color: blue;</span><br><span class="line">            width: 600px;</span><br><span class="line">            color: white;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">960px</span>) &#123;</span></span><br><span class="line">            img &#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">                left: 5000px;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.bar</span> &#123;</span></span><br><span class="line">                display: none;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">961px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.foo</span> &#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: -5000px;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>基于媒体查询隐藏元素<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img//dragon.jpg"</span> <span class="attr">alt</span>=<span class="string">"dragon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Laborum earum voluptatibus fuga ullam, assumenda architecto cumque obcaecati asperiores explicabo, tempore harum modi error in veritatis, iusto natus vitae dignissimos reprehenderit.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet, consectetur adipisicing elit. Possimus, deleniti quisquam? Debitis vel ab, aperiam, soluta facere aut cumque perferendis rerum fuga corporis officia corrupti molestias at nemo velit in.Perferendis autem fuga dolorum, quos iste sint omnis quo, laborum deserunt nobis iure. Laborum accusamus velit libero. Ipsa maxime dolore, alias, totam hic nihil earum id sequi illo placeat vitae.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>无论是绝对定位还是浮动都没有高度属性，因此一旦应用于某个元素，均不会占用任何垂直的空间区域。利用这个有用的小窍门可以很好地在页面上移除相应元素。当然通过浮动元素来布局时也会导致一些小问题。这些问题可以为元素添加clear:both属性来解决。</p>
<h1 id="四-Bootstrap"><a href="#四-Bootstrap" class="headerlink" title="四. Bootstrap"></a>四. Bootstrap</h1><h2 id="4-1-什么是Bootstrap"><a href="#4-1-什么是Bootstrap" class="headerlink" title="4.1 什么是Bootstrap"></a>4.1 什么是Bootstrap</h2><p>Bootstrap 是最受欢迎的 HTML、CSS 和 JS(完全开源) 框架，用于开发响应式布局、移动设备优先的 WEB 项目</p>
<p>Bootstrap采用sass和less作为CSS预处理脚本开发，我们可以采用预编译的CSS文件快速开发，也可以从源码定制我们需要的样式。</p>
<p>我们通过使用Bootstrap框架可以通过一份代码，同时适配手机，平板，PC设备，这一切都是CSS媒体查询的功劳。</p>
<h2 id="4-2-Bootstrap3和Bootstrap4的区别"><a href="#4-2-Bootstrap3和Bootstrap4的区别" class="headerlink" title="4.2 Bootstrap3和Bootstrap4的区别"></a>4.2 Bootstrap3和Bootstrap4的区别</h2><table>
<thead>
<tr>
<th><strong>Bootstrap3</strong></th>
<th><strong>Bootstrap4</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Less</td>
<td>Sass语言编写</td>
</tr>
<tr>
<td>4种栅格类</td>
<td>5种栅格类</td>
</tr>
<tr>
<td>使用px为单位</td>
<td>使用rem和em为单位（除部分margin和padding使用px）</td>
</tr>
<tr>
<td>使用push和pull向左右移动</td>
<td>偏移列通过offset-类设置</td>
</tr>
<tr>
<td>使用float的布局方式</td>
<td>选择弹性盒模型（flexbox）</td>
</tr>
</tbody></table>
<p>Bootstrap4的5种栅格：</p>
<ul>
<li>特小（col-）(&lt;576px)</li>
<li>小（col-sm-）(≥576px)</li>
<li>中（col-md-）(≥768px)</li>
<li>大（col-lg-） (≥992px)</li>
<li>特大（col-xl-）（≥1200px）</li>
</ul>
<p>Bootstrap4特点</p>
<ul>
<li>新增网格层适配了移动端；</li>
<li>全面引入ES6新特性（重写所有JavaScript插件）；</li>
<li>css文件减少了至少40%；</li>
<li>所有文档都用Markdown编辑器重写；</li>
<li>boostrap4使用小图标需要自行引入</li>
<li>放弃对IE8的支持</li>
</ul>
<h2 id="4-3-Bootstrap3的基本使用"><a href="#4-3-Bootstrap3的基本使用" class="headerlink" title="4.3 Bootstrap3的基本使用"></a>4.3 Bootstrap3的基本使用</h2><p>目前3.x最新版本为v3.3.7</p>
<p>Bootstrap为我们提供了免费的CDN服务</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css"</span> <span class="attr">integrity</span>=<span class="string">"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"</span> <span class="attr">integrity</span>=<span class="string">"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们也能通过bower,npm,composer等模块管理工具来进行安装</p>
<p>下面是npm安装的方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install bootstrap@3</span></span><br></pre></td></tr></table></figure>

<p><code>require(&#39;bootstrap&#39;)</code> 代码的作用是加载 Bootstrap 的所有 jQuery 插件。其中，<code>bootstrap</code> 模块自身并不导出任何内容。你可以通过加载安装包顶级目录下的 <code>/js/*.js</code> 文件的方式手动加载单个的 Bootstrap 插件。</p>
<p>Bootstrap 的 <code>package.json</code> 文件包含了一些额外的元数据：</p>
<ul>
<li><code>less</code> - Bootstrap 源码的入口 <a href="http://lesscss.org/" target="_blank" rel="noopener">Less</a> 文件的路径</li>
<li><code>style</code> - Bootstrap 的未压缩 CSS 文件的路径</li>
</ul>
<h4 id="4-3-1-全局样式"><a href="#4-3-1-全局样式" class="headerlink" title="4.3.1 全局样式"></a>4.3.1 全局样式</h4><p>Bootstrap使用了normalize.css来进行CSS样式重置</p>
<ol>
<li>布局容器<br>.container和.container-fluid，前者作用于固定宽度并支持响应式布局的容器，后者占据全部视口</li>
<li>栅格系统</li>
</ol>
<ul>
<li><p>必须过布局容器.container或者.container-fluid进行包含</p>
</li>
<li><p>针对不同尺寸设备的栅格参数</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>手机(&lt;768px)</th>
<th>平板(768px&lt;= and &lt; 992px)</th>
<th>小型台式机(&gt;=992px)</th>
<th>大型台式机(&gt;=1200px)</th>
</tr>
</thead>
<tbody><tr>
<td>栅格排列方式</td>
<td>始终水平排列</td>
<td>开始是堆叠在一起的，当大于这阈值时将变为水平排列</td>
<td>开始是堆叠在一起的，当大于阈值时将变为水平排列</td>
<td>开始是堆叠在一起的，当大于这阈值时将变为水平排列</td>
</tr>
<tr>
<td>容器宽度</td>
<td>自动</td>
<td>750px</td>
<td>970px</td>
<td>1170px</td>
</tr>
<tr>
<td>类前缀</td>
<td>.col-xs-</td>
<td>.col-sm-</td>
<td>.col-md-</td>
<td>.col-lg-</td>
</tr>
<tr>
<td>列数</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>最大列宽</td>
<td>自动</td>
<td>约62px</td>
<td>约81px</td>
<td>约97px</td>
</tr>
<tr>
<td>槽宽（gutter）</td>
<td>30px(每列左右均有15px)</td>
<td>30px(每列左右均有15px)</td>
<td>30px(每列左右均有15px)</td>
<td>30px(每列左右均有15px)</td>
</tr>
<tr>
<td>可嵌套</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>列偏移</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>列排序</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>我们通过为元素添加不同的类，可以针对PC，平板和手机实现不同的布局，例如:</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-12 col-sm-6 col-md-8"</span>&gt;</span>.col-xs-12 .col-sm-6 .col-md-8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-md-4"</span>&gt;</span>.col-xs-6 .col-md-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-sm-4"</span>&gt;</span>.col-xs-6 .col-sm-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-sm-4"</span>&gt;</span>.col-xs-6 .col-sm-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Optional: clear the XS cols if their content doesn't match in height --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix visible-xs-block"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-sm-4"</span>&gt;</span>.col-xs-6 .col-sm-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可使用col-md-offset-3系列类名实现列的偏移，如</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span>.col-md-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4 col-md-offset-4"</span>&gt;</span>.col-md-4 .col-md-offset-4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-md-offset-3"</span>&gt;</span>.col-md-3 .col-md-offset-3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3 col-md-offset-3"</span>&gt;</span>.col-md-3 .col-md-offset-3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-md-offset-3"</span>&gt;</span>.col-md-6 .col-md-offset-3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>栅格系统的列可以支持嵌套，即在column中添加div.row&gt;.col-md-*</p>
</li>
<li><p>列可以支持排序, 我们通过使用.col-md-push-<em>和.col-md-pull-</em>类来改变列的顺序</p>
</li>
<li><p>如果我们使用less方式来引入bootstrap的话，我们可以使用less变量和mixin来生成布局</p>
<p>变量</p>
<p>通过变量来定义列数、槽（gutter）宽、媒体查询阈值（用于确定合适让列浮动）。我们使用这些变量生成预定义的栅格类，如上所示，还有如下所示的定制 mixin。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@grid-columns:              12;</span><br><span class="line">@grid-gutter-width:         30px;</span><br><span class="line">@grid-float-breakpoint:     768px;</span><br></pre></td></tr></table></figure>

<p>mixin</p>
<p>mixin 用来和栅格变量一同使用，为每个列（column）生成语义化的 CSS 代码。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates a wrapper for a series of columns</span></span><br><span class="line"><span class="selector-class">.make-row</span>(<span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="comment">// Then clear the floated columns</span></span><br><span class="line">  <span class="selector-class">.clearfix</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:  (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">margin-right</span>: (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Negative margin nested rows out to align the content of columns</span></span><br><span class="line">  <span class="selector-class">.row</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:  (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">margin-right</span>: (<span class="variable">@gutter</span> / -<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the extra small columns</span></span><br><span class="line"><span class="selector-class">.make-xs-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="comment">// Prevent columns from collapsing when empty</span></span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="comment">// Inner gutter via padding</span></span><br><span class="line">  <span class="attribute">padding-left</span>:  (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate width based on number of columns available</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@grid-float-breakpoint</span>) &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the small columns</span></span><br><span class="line"><span class="selector-class">.make-sm-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="comment">// Prevent columns from collapsing when empty</span></span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="comment">// Inner gutter via padding</span></span><br><span class="line">  <span class="attribute">padding-left</span>:  (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate width based on number of columns available</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the small column offsets</span></span><br><span class="line"><span class="selector-class">.make-sm-column-offset</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-sm-column-push</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-sm-column-pull</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-sm-min</span>) &#123;</span><br><span class="line">    <span class="attribute">right</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the medium columns</span></span><br><span class="line"><span class="selector-class">.make-md-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="comment">// Prevent columns from collapsing when empty</span></span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="comment">// Inner gutter via padding</span></span><br><span class="line">  <span class="attribute">padding-left</span>:  (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate width based on number of columns available</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-md-min</span>) &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the medium column offsets</span></span><br><span class="line"><span class="selector-class">.make-md-column-offset</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-md-min</span>) &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-md-column-push</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-md-min</span>) &#123;</span><br><span class="line">    <span class="attribute">left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-md-column-pull</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-md-min</span>) &#123;</span><br><span class="line">    <span class="attribute">right</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the large columns</span></span><br><span class="line"><span class="selector-class">.make-lg-column</span>(<span class="variable">@columns</span>; <span class="variable">@gutter</span>: <span class="variable">@grid-gutter-width</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="comment">// Prevent columns from collapsing when empty</span></span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="comment">// Inner gutter via padding</span></span><br><span class="line">  <span class="attribute">padding-left</span>:  (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: (<span class="variable">@gutter</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate width based on number of columns available</span></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-lg-min</span>) &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the large column offsets</span></span><br><span class="line"><span class="selector-class">.make-lg-column-offset</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-lg-min</span>) &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-lg-column-push</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-lg-min</span>) &#123;</span><br><span class="line">    <span class="attribute">left</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.make-lg-column-pull</span>(<span class="variable">@columns</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="variable">@screen-lg-min</span>) &#123;</span><br><span class="line">    <span class="attribute">right</span>: percentage((<span class="variable">@columns</span> / <span class="variable">@grid-columns</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例展示</p>
<p>你可以重新修改这些变量的值，或者用默认值调用这些 mixin。下面就是一个利用默认设置生成两列布局（列之间有间隔）的案例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  .make-row();</span><br><span class="line">&#125;</span><br><span class="line">.content-main &#123;</span><br><span class="line">  .make-lg-column(8);</span><br><span class="line">&#125;</span><br><span class="line">.content-secondary &#123;</span><br><span class="line">  .make-lg-column(3);</span><br><span class="line">  .make-lg-column-offset(1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-main"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-secondary"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li><p>排版</p>
<ul>
<li><p>标题<br>h1-h6元素均可使用（添加了一些样式）, 还可以使用.h1-.h6为内联元素添加标题的样式<br>在标题内还可以使用small标签或者.small来标记副标题</p>
</li>
<li><p>页面主体<br>Bootstrap 将全局 <code>font-size</code> 设置为 <strong>14px</strong>，<code>line-height</code> 设置为 <strong>1.428</strong>。这些属性直接赋予 <code>元素和所有段落元素。另外，</code> （段落）元素还被设置了等于 1/2 行高（即 10px）的底部外边距（margin）。</p>
</li>
<li><p>中心内容<br>.lead类可以让段落突出显示</p>
</li>
<li><p>使用less的话，可以通过修改@font-size-base和@line-height-base来修改bootstrap的默认样式</p>
</li>
<li><p>内联文本元素mark标签定义标记文本, del标签定义删除文本，s标签定义无用文本,ins定义插入文本,u定义下划线文本,small定义小号文本,strong 定义着重文本,em定义斜体文本</p>
</li>
<li><p>对齐: 使用.text-left, .text-center, .text-right, .text-justify,text-nowrap</p>
</li>
<li><p>改变大小写: 使用.text-lowercase,   .text-uppercase, .text-capitalize</p>
</li>
<li><p>缩略语:<br>① 基本缩略语</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"attribute"</span>&gt;</span>attr<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>② 首字母缩略语为缩略语添加 <code>.initialism</code> 类，可以让 font-size 变得稍微小些。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"HyperText Markup Language"</span> <span class="attr">class</span>=<span class="string">"initialism"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>地址</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Twitter, Inc.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  1355 Market Street, Suite 900<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  San Francisco, CA 94103<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"Phone"</span>&gt;</span>P:<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> (123) 456-7890</span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Full Name<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:#"</span>&gt;</span>first.last@example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用对于标准样式的 ``，可以通过几个简单的变体就能改变风格和内容。</p>
<p>命名来源</p>
<p>添加 <code>用于标明引用来源。来源的名称可以包裹进</code>标签中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>Someone famous in <span class="tag">&lt;<span class="name">cite</span> <span class="attr">title</span>=<span class="string">"Source Title"</span>&gt;</span>Source Title<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另一种展示风格</p>
<p>通过赋予 <code>.blockquote-reverse</code> 类可以让引用呈现内容右对齐的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-reverse"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>列表<br>①我们可以使用.list-unstyled类来实现无样式列表， .list-inline来实现内联列表<br>② 水平排列的描述列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">"dl-horizontal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码<br>通过 code标签包裹内联样式的代码片段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="symbol">&amp;lt;</span>section<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span> should be wrapped as inline.</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户输入<br>通过 kbd 标签标记用户通过键盘输入的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">To switch directories, type <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>cd<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> followed by the name of the directory.<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">To edit settings, press <span class="tag">&lt;<span class="name">kbd</span>&gt;</span><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>,<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码块</p>
<pre>&lt;p&gt;Sample text here...&lt;/p&gt;</pre>

<p>还可以使用 <code>.pre-scrollable</code> 类，其作用是设置 max-height 为 350px ，并在垂直方向展示滚动条。</p>
</li>
<li><p>变量</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">var</span>&gt;</span>y<span class="tag">&lt;/<span class="name">var</span>&gt;</span> = <span class="tag">&lt;<span class="name">var</span>&gt;</span>m<span class="tag">&lt;/<span class="name">var</span>&gt;</span><span class="tag">&lt;<span class="name">var</span>&gt;</span>x<span class="tag">&lt;/<span class="name">var</span>&gt;</span> + <span class="tag">&lt;<span class="name">var</span>&gt;</span>b<span class="tag">&lt;/<span class="name">var</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>程序输出</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">samp</span>&gt;</span>This text is meant to be treated as sample output from a computer program.<span class="tag">&lt;/<span class="name">samp</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-3-2-表格"><a href="#4-3-2-表格" class="headerlink" title="4.3.2 表格"></a>4.3.2 表格</h4><p>为table元素添加.table(基本表格样式), .table-striped(条纹表格), .table-bordered(带边框表格), .table-hover(鼠标地悬停效果), .table-condensed(紧缩表格)</p>
<p><strong>状态类</strong></p>
<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.active</code></td>
<td align="left">鼠标悬停在行或单元格上时所设置的颜色</td>
</tr>
<tr>
<td align="left"><code>.success</code></td>
<td align="left">标识成功或积极的动作</td>
</tr>
<tr>
<td align="left"><code>.info</code></td>
<td align="left">标识普通的提示信息或动作</td>
</tr>
<tr>
<td align="left"><code>.warning</code></td>
<td align="left">标识警告或需要用户注意</td>
</tr>
<tr>
<td align="left"><code>.danger</code></td>
<td align="left">标识危险或潜在的带来负面影响的动作</td>
</tr>
</tbody></table>
<p><strong>响应式表格</strong></p>
<p>将任何 <code>.table</code> 元素包裹在 <code>.table-responsive</code> 元素内，即可创建响应式表格，其会在小屏幕设备上（小于768px）水平滚动。当屏幕大于 768px 宽度时，水平滚动条消失。</p>
<p>垂直方向的内容截断</p>
<p>响应式表格使用了 <code>overflow-y: hidden</code> 属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件。</p>
<p><strong>Firefox 和 <code>fieldset</code> 元素</strong></p>
<p>Firefox 浏览器对 <code>fieldset</code> 元素设置了一些影响 <code>width</code> 属性的样式，导致响应式表格出现问题。可以使用下面提供的针对 Firefox 的 hack 代码解决，但是以下代码并未集成在 Bootstrap 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@-moz-document url-prefix() &#123;</span><br><span class="line">  fieldset &#123; display: table-cell; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-表单"><a href="#4-3-3-表单" class="headerlink" title="4.3.3 表单"></a>4.3.3 表单</h4><p>单独的表单控件会被自动赋予一些全局样式。所有设置了 <code>.form-control</code> 类的 input和 textarea和select元素都将被默认设置宽度属性为 <code>width: 100%;</code>。 将 <code>label</code> 元素和前面提到的控件包裹在 <code>.form-group</code> 中可以获得最好的排列。</p>
<p>为 form元素添加 <code>.form-inline</code> 类可使其内容左对齐并且表现为 <code>inline-block</code> 级别的控件。<strong>只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）。</strong></p>
<p>一定要添加 <code>label</code> 标签</p>
<p>如果你没有为每个输入控件设置 <code>label</code> 标签，屏幕阅读器将无法正确识别。对于这些内联表单，你可以通过为 <code>label</code> 设置 <code>.sr-only</code> 类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如 <code>aria-label</code>、<code>aria-labelledby</code> 或 <code>title</code> 属性。如果这些都不存在，屏幕阅读器可能会采取使用 <code>placeholder</code> 属性，如果存在的话，使用placeholder来替代其他的标记，但要注意，这种方法是不妥当的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-inline"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"email"</span> <span class="attr">placeholder</span>=<span class="string">"Email"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"amount"</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Amount<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span>$<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">id</span>=<span class="string">"amount"</span> <span class="attr">placeholder</span>=<span class="string">"Amount"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span>.00<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>水平排列的表单</strong></p>
<p>通过为表单添加 <code>.form-horizontal</code> 类，并联合使用 Bootstrap 预置的栅格类，可以将 <code>label</code> 标签和控件组水平并排布局。这样做将改变 <code>.form-group</code> 的行为，使其表现为栅格系统中的行（row），因此就无需再额外添加 <code>.row</code> 了。</p>
<p><strong>支持的表单控件</strong></p>
<p>包括大部分表单控件、文本输入域控件，还支持所有 HTML5 类型的输入控件： <code>text</code>、<code>password</code>、<code>datetime</code>、<code>datetime-local</code>、<code>date</code>、<code>month</code>、<code>time</code>、<code>week</code>、<code>number</code>、<code>email</code>、<code>url</code>、<code>search</code>、<code>tel</code> 和 <code>color</code>。</p>
<p><strong>单选和多选框</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    Option one is this and that<span class="symbol">&amp;mdash;</span>be sure to include why it's great</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox disabled"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line">    Option two is disabled</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"radio"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"optionsRadios"</span> <span class="attr">id</span>=<span class="string">"optionsRadios1"</span> <span class="attr">value</span>=<span class="string">"option1"</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    Option one is this and that<span class="symbol">&amp;mdash;</span>be sure to include why it's great</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"radio"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"optionsRadios"</span> <span class="attr">id</span>=<span class="string">"optionsRadios2"</span> <span class="attr">value</span>=<span class="string">"option2"</span>&gt;</span></span><br><span class="line">    Option two can be something else and selecting it will deselect option one</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"radio disabled"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"optionsRadios"</span> <span class="attr">id</span>=<span class="string">"optionsRadios3"</span> <span class="attr">value</span>=<span class="string">"option3"</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line">    Option three is disabled</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>内联的单选和多选框</strong></p>
<p>通过将 <code>.checkbox-inline</code> 或 <code>.radio-inline</code> 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"inlineCheckbox1"</span> <span class="attr">value</span>=<span class="string">"option1"</span>&gt;</span> 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"inlineCheckbox2"</span> <span class="attr">value</span>=<span class="string">"option2"</span>&gt;</span> 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"inlineCheckbox3"</span> <span class="attr">value</span>=<span class="string">"option3"</span>&gt;</span> 3</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"radio-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"inlineRadioOptions"</span> <span class="attr">id</span>=<span class="string">"inlineRadio1"</span> <span class="attr">value</span>=<span class="string">"option1"</span>&gt;</span> 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"radio-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"inlineRadioOptions"</span> <span class="attr">id</span>=<span class="string">"inlineRadio2"</span> <span class="attr">value</span>=<span class="string">"option2"</span>&gt;</span> 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"radio-inline"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"inlineRadioOptions"</span> <span class="attr">id</span>=<span class="string">"inlineRadio3"</span> <span class="attr">value</span>=<span class="string">"option3"</span>&gt;</span> 3</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>静态控件</strong></p>
<p>如果需要在表单中将一行纯文本和 <code>label</code> 元素放置于同一行，为 `` 元素添加 <code>.form-control-static</code> 类即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-horizontal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"form-control-static"</span>&gt;</span>email@example.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"inputPassword"</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputPassword"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>禁用状态</strong></p>
<p>为输入框设置 <code>disabled</code> 属性可以禁止其与用户有任何交互（焦点、输入等）。被禁用的输入框颜色更浅，并且还添加了 <code>not-allowed</code> 鼠标状态。</p>
<p><strong>只读状态</strong></p>
<p>为输入框设置 <code>readonly</code> 属性可以禁止用户修改输入框中的内容。处于只读状态的输入框颜色更浅（就像被禁用的输入框一样），但是仍然保留标准的鼠标状态。</p>
<p><strong>帮助文本</strong></p>
<p>使用aria-describedby属性来为表单元素添加供屏幕阅读器等辅助设备使用的帮助文本以供残障人士更好的阅读网页</p>
<p><strong>校验状态</strong></p>
<p>Bootstrap 对表单控件的校验状态，如 error、warning 和 success 状态，都定义了样式。使用时，添加 <code>.has-warning</code>、<code>.has-error</code> 或 <code>.has-success</code> 类到这些控件的父元素即可。任何包含在此元素之内的 <code>.control-label</code>、<code>.form-control</code> 和 <code>.help-block</code> 元素都将接受这些校验状态的样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group has-success"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"control-label"</span> <span class="attr">for</span>=<span class="string">"inputSuccess1"</span>&gt;</span>Input with success<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputSuccess1"</span> <span class="attr">aria-describedby</span>=<span class="string">"helpBlock2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"helpBlock2"</span> <span class="attr">class</span>=<span class="string">"help-block"</span>&gt;</span>A block of help text that breaks onto a new line and may extend beyond one line.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group has-warning"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"control-label"</span> <span class="attr">for</span>=<span class="string">"inputWarning1"</span>&gt;</span>Input with warning<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputWarning1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group has-error"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"control-label"</span> <span class="attr">for</span>=<span class="string">"inputError1"</span>&gt;</span>Input with error<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"inputError1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"has-success"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkboxSuccess"</span> <span class="attr">value</span>=<span class="string">"option1"</span>&gt;</span></span><br><span class="line">      Checkbox with success</span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"has-warning"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkboxWarning"</span> <span class="attr">value</span>=<span class="string">"option1"</span>&gt;</span></span><br><span class="line">      Checkbox with warning</span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"has-error"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkboxError"</span> <span class="attr">value</span>=<span class="string">"option1"</span>&gt;</span></span><br><span class="line">      Checkbox with error</span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>控件尺寸</strong></p>
<p>通过 <code>.input-lg</code> 类似的类可以为控件设置高度，通过 <code>.col-lg-*</code> 类似的类可以为控件设置宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control input-lg"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">".input-lg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Default input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control input-sm"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">".input-sm"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control input-lg"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control input-sm"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>水平排列的表单组的尺寸</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-horizontal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group form-group-lg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span> <span class="attr">for</span>=<span class="string">"formGroupInputLarge"</span>&gt;</span>Large label<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"formGroupInputLarge"</span> <span class="attr">placeholder</span>=<span class="string">"Large input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group form-group-sm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-sm-2 control-label"</span> <span class="attr">for</span>=<span class="string">"formGroupInputSmall"</span>&gt;</span>Small label<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"formGroupInputSmall"</span> <span class="attr">placeholder</span>=<span class="string">"Small input"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>调整列的尺寸</strong></p>
<p>用栅格系统中的列（column）包裹输入框或其任何父元素，都可很容易的为其设置宽度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">".col-xs-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">".col-xs-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">".col-xs-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-按钮"><a href="#4-3-4-按钮" class="headerlink" title="4.3.4 按钮"></a>4.3.4 按钮</h4><p>为a,button或者input 元素添加按钮类（button class）即可使用 Bootstrap 提供的样式。</p>
<p><strong>针对组件的注意事项</strong></p>
<p>虽然按钮类可以应用到 <code>和</code> 元素上，但是，导航和导航条组件只支持button元素。</p>
<p><strong>链接被作为按钮使用时的注意事项</strong></p>
<p>如果 a元素被作为按钮使用 – 并用于在当前页面触发某些功能 – 而不是用于链接其他页面或链接当前页面中的其他部分，那么，务必为其设置 <code>role=&quot;button&quot;</code> 属性。</p>
<p><strong>跨浏览器展现</strong></p>
<p>我们总结的最佳实践是：<strong>强烈建议尽可能使用button元素</strong>来获得在各个浏览器上获得相匹配的绘制效果。</p>
<p>另外，我们还发现了 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=697451" target="_blank" rel="noopener">Firefox &lt;30 版本的浏览器上出现的一个 bug</a>，其表现是：阻止我们为基于 `` 元素所创建的按钮设置 <code>line-height</code> 属性，这就导致在 Firefox 浏览器上不能完全和其他按钮保持一致的高度。</p>
<p><strong>预定义样式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Standard button --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>（默认样式）Default<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>（首选项）Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Indicates a successful or positive action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>（成功）Success<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Contextual button for informational alert messages --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-info"</span>&gt;</span>（一般信息）Info<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Indicates caution should be taken with this action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-warning"</span>&gt;</span>（警告）Warning<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Indicates a dangerous or potentially negative action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-danger"</span>&gt;</span>（危险）Danger<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-link"</span>&gt;</span>（链接）Link<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>尺寸</strong></p>
<p>需要让按钮具有不同尺寸吗？使用 <code>.btn-lg</code>、<code>.btn-sm</code> 或 <code>.btn-xs</code> 就可以获得不同尺寸的按钮。</p>
<p>（大按钮）Large button</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg"</span>&gt;</span>（大按钮）Large button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-lg"</span>&gt;</span>（大按钮）Large button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>（默认尺寸）Default button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>（默认尺寸）Default button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-sm"</span>&gt;</span>（小按钮）Small button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-sm"</span>&gt;</span>（小按钮）Small button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-xs"</span>&gt;</span>（超小尺寸）Extra small button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-xs"</span>&gt;</span>（超小尺寸）Extra small button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过给按钮添加 <code>.btn-block</code> 类可以将其拉伸至父元素100%的宽度，而且按钮也变为了块级（block）元素。</p>
<p><strong>激活状态</strong></p>
<p>使用button</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg active"</span>&gt;</span>Primary button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-lg active"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用a标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-lg active"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>Primary link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-lg active"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-图片"><a href="#4-3-5-图片" class="headerlink" title="4.3.5 图片"></a>4.3.5 图片</h4><p>在 Bootstrap 版本 3 中，通过为图片添加 <code>.img-responsive</code> 类可以让图片支持响应式布局。其实质是为图片设置了 <code>max-width: 100%;</code>、 <code>height: auto;</code> 和 <code>display: block;</code> 属性，从而让图片在其父元素中更好的缩放。</p>
<p>如果需要让使用了 <code>.img-responsive</code> 类的图片水平居中，请使用 <code>.center-block</code> 类，不要用 <code>.text-center</code>。</p>
<p><strong>SVG 图像和 IE 8-10</strong></p>
<p>在 Internet Explorer 8-10 中，设置为 <code>.img-responsive</code> 的 SVG 图像显示出的尺寸不匀称。为了解决这个问题，在出问题的地方添加 <code>width: 100% \9;</code> 即可。Bootstrap 并没有自动为所有图像元素设置这一属性，因为这会导致其他图像格式出现错乱。</p>
<p><strong>图片的形状</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-rounded"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-circle"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"img-thumbnail"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-6-辅助类"><a href="#4-3-6-辅助类" class="headerlink" title="4.3.6 辅助类"></a>4.3.6 辅助类</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-muted"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-success"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-info"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-warning"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-7-情景背景色"><a href="#4-3-7-情景背景色" class="headerlink" title="4.3.7 情景背景色"></a>4.3.7 情景背景色</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg-primary"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg-success"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg-info"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg-warning"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"bg-danger"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-8-快速浮动"><a href="#4-3-8-快速浮动" class="headerlink" title="4.3.8 快速浮动"></a>4.3.8 快速浮动</h4><p>我们可以使用.pull-left和.pull-right实现快速浮动</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class="pull-left"&gt;...&lt;/div&gt;</span><br><span class="line">&lt;div class="pull-right"&gt;...&lt;/div&gt;</span><br><span class="line">// Classes</span><br><span class="line"><span class="selector-class">.pull-left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pull-right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果我们使用less也可以以mixins方式来使用</span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  .pull-left();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.another-element</span> &#123;</span><br><span class="line">  .pull-right();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.pull-left和.pull-right不能使用于navbar中，navbar中可以使用.navbar-left或者.navbar-right</p>
<h4 id="4-3-9-让内容块居中"><a href="#4-3-9-让内容块居中" class="headerlink" title="4.3.9 让内容块居中"></a>4.3.9 让内容块居中</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div class="center-block"&gt;...&lt;/div&gt;</span><br><span class="line">// Class</span><br><span class="line"><span class="selector-class">.center-block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage as a mixin</span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  .center-block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-10-清除浮动"><a href="#4-3-10-清除浮动" class="headerlink" title="4.3.10 清除浮动"></a>4.3.10 清除浮动</h4><p><strong>通过为父元素</strong>添加 <code>.clearfix</code> 类可以很容易地清除浮动（<code>float</code>）。这里所使用的是 Nicolas Gallagher 创造的 <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">micro clearfix</a> 方式。此类还可以作为 mixin 使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">Usage</span> <span class="selector-tag">as</span> <span class="selector-tag">a</span> <span class="selector-tag">class</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;div class="clearfix"&gt;...&lt;/div&gt;</span><br><span class="line">// Mixin itself</span><br><span class="line"><span class="selector-class">.clearfix</span>() &#123;</span><br><span class="line">  &amp;:before,</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Usage as a mixin</span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  .clearfix();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-11-显示或隐藏内容"><a href="#4-3-11-显示或隐藏内容" class="headerlink" title="4.3.11 显示或隐藏内容"></a>4.3.11 显示或隐藏内容</h4><p>我们可以使用.hidden和.show来强制任意元素的显示和隐藏，.invisible类也可以隐藏元素，但只是改变了可见性，元素仍旧占据位置，影响排版</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Classes</span></span><br><span class="line"><span class="selector-class">.show</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hidden</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.invisible</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage as mixins</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="selector-class">.show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.another-element</span> &#123;</span><br><span class="line">  <span class="selector-class">.hidden</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-12-响应式工具"><a href="#4-3-12-响应式工具" class="headerlink" title="4.3.12 响应式工具"></a>4.3.12 响应式工具</h4><table>
<thead>
<tr>
<th align="left">超小屏幕手机 (&lt;768px)</th>
<th align="left">小屏幕平板 (≥768px)</th>
<th align="left">中等屏幕桌面 (≥992px)</th>
<th align="left">大屏幕桌面 (≥1200px)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.visible-xs-*</code></td>
<td align="left">可见</td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-sm-*</code></td>
<td align="left">隐藏</td>
<td align="left">可见</td>
<td align="left">隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-md-*</code></td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td align="left">可见</td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-lg-*</code></td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td>可见</td>
</tr>
<tr>
<td align="left"><code>.hidden-xs</code></td>
<td align="left">隐藏</td>
<td align="left">可见</td>
<td align="left">可见</td>
<td>可见</td>
</tr>
<tr>
<td align="left"><code>.hidden-sm</code></td>
<td align="left">可见</td>
<td align="left">隐藏</td>
<td align="left">可见</td>
<td>可见</td>
</tr>
<tr>
<td align="left"><code>.hidden-md</code></td>
<td align="left">可见</td>
<td align="left">可见</td>
<td align="left">隐藏</td>
<td>可见</td>
</tr>
<tr>
<td align="left"><code>.hidden-lg</code></td>
<td align="left">可见</td>
<td align="left">可见</td>
<td align="left">可见</td>
<td>隐藏</td>
</tr>
</tbody></table>
<p>从 v3.2.0 版本起，形如 <code>.visible-*-*</code> 的类针对每种屏幕大小都有了三种变体，每个针对 CSS 中不同的 <code>display</code> 属性，列表如下：</p>
<table>
<thead>
<tr>
<th align="left">类组</th>
<th align="left">CSS <code>display</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.visible-*-block</code></td>
<td align="left"><code>display: block;</code></td>
</tr>
<tr>
<td align="left"><code>.visible-*-inline</code></td>
<td align="left"><code>display: inline;</code></td>
</tr>
<tr>
<td align="left"><code>.visible-*-inline-block</code></td>
<td align="left"><code>display: inline-block;</code></td>
</tr>
</tbody></table>
<p>因此，以超小屏幕（<code>xs</code>）为例，可用的 <code>.visible-*-*</code> 类是：<code>.visible-xs-block</code>、<code>.visible-xs-inline</code> 和 <code>.visible-xs-inline-block</code>。</p>
<p><code>.visible-xs</code>、<code>.visible-sm</code>、<code>.visible-md</code> 和 <code>.visible-lg</code> 类也同时存在。但是<strong>从 v3.2.0 版本开始不再建议使用</strong>。除了 table相关的元素的特殊情况外，它们与 <code>.visible-*-block</code> 大体相同。</p>
<h4 id="4-3-13-打印类"><a href="#4-3-13-打印类" class="headerlink" title="4.3.13 打印类"></a>4.3.13 打印类</h4><p>和常规的响应式类一样，使用下面的类可以针对打印机隐藏或显示某些内容。</p>
<table>
<thead>
<tr>
<th align="left">class</th>
<th align="left">浏览器</th>
<th align="left">打印机</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.visible-print-block</code> <code>.visible-print-inline</code> <code>.visible-print-inline-block</code></td>
<td align="left">隐藏</td>
<td align="left">可见</td>
</tr>
<tr>
<td align="left"><code>.hidden-print</code></td>
<td align="left">可见</td>
<td align="left">隐藏</td>
</tr>
</tbody></table>
<p><code>.visible-print</code> 类也是存在的，但是从 v3.2.0 版本开始<strong>不建议使用</strong>。它与 <code>.visible-print-block</code> 类大致相同，除了 `` 相关元素的特殊情况外。</p>
<h2 id="4-4-Bootstrap3组件"><a href="#4-4-Bootstrap3组件" class="headerlink" title="4.4 Bootstrap3组件"></a>4.4 Bootstrap3组件</h2><p>Bootstrap提供了以下组件：</p>
<ul>
<li>Glyphicons字体图标</li>
<li>按钮组</li>
<li>按钮式下拉菜单</li>
<li>输入框组</li>
<li>导航</li>
<li>导航条</li>
<li>路径导航(面包屑)</li>
<li>分页</li>
<li>标签</li>
<li>徽章</li>
<li>巨幕</li>
<li>页头</li>
<li>缩略图</li>
<li>警告框</li>
<li>进度条</li>
<li>媒体对象</li>
<li>列表组</li>
<li>面板</li>
</ul>
<h2 id="4-5-Bootstrap3-JavaScript插件"><a href="#4-5-Bootstrap3-JavaScript插件" class="headerlink" title="4.5 Bootstrap3 JavaScript插件"></a>4.5 Bootstrap3 JavaScript插件</h2><p>Bootstrap3提供了以下的JavaScript插件</p>
<ul>
<li>过渡效果</li>
<li>模态框</li>
<li>下拉菜单</li>
<li>滚动监听</li>
<li>标签页</li>
<li>Tooltip</li>
<li>Popup</li>
<li>按钮</li>
<li>折叠面板</li>
<li>轮播图Carousel</li>
<li>图钉</li>
</ul>
<h3 id="4-6-Bootstrap3样式定制"><a href="#4-6-Bootstrap3样式定制" class="headerlink" title="4.6 Bootstrap3样式定制"></a>4.6 Bootstrap3样式定制</h3><p><a href="https://v3.bootcss.com/customize/#grid-system" target="_blank" rel="noopener">https://v3.bootcss.com/customize/#grid-system</a></p>
<h1 id="五-Bootstrap4的使用"><a href="#五-Bootstrap4的使用" class="headerlink" title="五. Bootstrap4的使用"></a>五. Bootstrap4的使用</h1><p>目前Bootstrap已经更新到了版本4.x</p>
<h2 id="5-1-栅格系统使用FlexBox重构"><a href="#5-1-栅格系统使用FlexBox重构" class="headerlink" title="5.1 栅格系统使用FlexBox重构"></a>5.1 栅格系统使用FlexBox重构</h2><table>
<thead>
<tr>
<th>Extra small &lt;576px</th>
<th>Small ≥576px</th>
<th>Medium ≥768px</th>
<th>Large ≥992px</th>
<th>Extra large ≥1200px</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Max container width</td>
<td>None (auto)</td>
<td>540px</td>
<td>720px</td>
<td>960px</td>
<td>1140px</td>
</tr>
<tr>
<td>Class prefix</td>
<td><code>.col-</code></td>
<td><code>.col-sm-</code></td>
<td><code>.col-md-</code></td>
<td><code>.col-lg-</code></td>
<td><code>.col-xl-</code></td>
</tr>
<tr>
<td># of columns</td>
<td>12</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Gutter width</td>
<td>30px (15px on each side of a column)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Nestable</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Column ordering</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Bootstrap4的栅格系统支持等宽自动分配空间的方式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以通过使用.w-100类来实现等宽列跨越多行的布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"w-100"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以为某些列指定宽度，其他列作为自动列存在</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"w-100"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>item6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>我们也可以通过使用col-{breakpoint}-auto来使得某些列宽度随内容多少变化，而其他列作为自动列存在</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row justify-content-md-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-lg-2"</span>&gt;</span></span><br><span class="line">      1 of 3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-auto"</span>&gt;</span></span><br><span class="line">      Variable width content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-lg-2"</span>&gt;</span></span><br><span class="line">      3 of 3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span></span><br><span class="line">      1 of 3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-auto"</span>&gt;</span></span><br><span class="line">      Variable width content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-lg-2"</span>&gt;</span></span><br><span class="line">      3 of 3</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bootstrap共定义了5个级别的响应式类</li>
</ul>
<p>.col, col-sm, .col-md, .col-lg, .col-xl</p>
<p>如果我们的布局中栅格在各个尺寸下列宽占比是一致的，那我们直接使用.col类来实现自动列就行了，我们也可以为某些列指定我们想要的占比</p>
<p>我们可以混用5个级别下的响应式类来达到更好的布局控制</p>
<ul>
<li><p>列间距gutter<br>Bootstrap4中的gutter可以响应式调整</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container px-lg-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row mx-lg-n5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col py-3 px-lg-5 border bg-light"</span>&gt;</span>Custom column padding<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col py-3 px-lg-5 border bg-light"</span>&gt;</span>Custom column padding<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​      这里我们给栅格列赋予了px-lg-5设置了padding,我们在row元素和container元素都需要通过使用.px-lg-5来抵消掉列的内补</p>
<ul>
<li><p>我们可以通过.row-cols-*类来指定我们自动列每行的列数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row row-cols-2"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col"</span>&gt;</span>column<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>栅格内容对齐方式的设置<br>我们可以通过使用.align-items-start, .align-items-center, .align-items-end设置row中所有col的垂直对齐方式， 使用justify-content-start,justify-content-center和justify-content-end来设置row中所有的水平对齐方式, 也可以通过.align-self-start,.align-self-center,.align-self-end类设置某个col的垂直对齐方式</p>
</li>
<li><p>no-gutters: 可以取消栅格之间的间隙</p>
</li>
<li><p>列排序: 我们使用.order-*(例如order-12, order-1)来实现列的排序</p>
</li>
<li><p>列偏移我们可以使用offset-{breakpoint}-*来设置列的偏移量</p>
</li>
<li><p>Margin工具类Bootstrap包含各种速记响应边距和填充实用程序类，以修改元素的外观。</p>
<h2 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h2><p>使用速记类为元素或其边上的子集分配响应友好<code>margin</code>或<code>padding</code>值。包括对单个属性，所有属性以及垂直和水平属性的支持。类从默认的萨斯地图范围内<code>.25rem</code>建立<code>3rem</code>。</p>
<h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><p>适用于所有断点，从间距公用事业<code>xs</code>到<code>xl</code>，在他们没有断点的缩写。这是因为这些类是从上到下应用的<code>min-width: 0</code>，因此不受媒体查询的约束。然而，其余的断点确实包含断点缩写。</p>
<p>类别是使用的格式命名<code>{property}{sides}-{size}</code>为<code>xs</code>和<code>{property}{sides}-{breakpoint}-{size}</code>为<code>sm</code>，<code>md</code>，<code>lg</code>，和<code>xl</code>。</p>
<p>当<em>属性</em>是以下之一：</p>
<ul>
<li><p><code>m</code>-用于设置<code>margin</code></p>
</li>
<li><p><code>p</code>-用于设置<code>padding</code></p>
</li>
</ul>
<p>当<em>双方</em>是一个：</p>
<ul>
<li><p><code>t</code>-用于设置<code>margin-top</code>或<code>padding-top</code></p>
</li>
<li><p><code>b</code>-用于设置<code>margin-bottom</code>或<code>padding-bottom</code></p>
</li>
<li><p><code>l</code>-用于设置<code>margin-left</code>或<code>padding-left</code></p>
</li>
<li><p><code>r</code>-用于设置<code>margin-right</code>或<code>padding-right</code></p>
</li>
<li><p><code>x</code>-对于设置两者的类<code>*-left</code>和<code>*-right</code></p>
</li>
<li><p><code>y</code>-对于设置两者的类<code>*-top</code>和<code>*-bottom</code></p>
</li>
<li><p>为设置<code>margin</code>或<code>padding</code>元素的所有四个方面</p>
</li>
</ul>
<p>其中<em>大小</em>是以下之一：</p>
<ul>
<li><p><code>0</code>- 用于消除<code>margin</code>或<code>padding</code>通过设置的类<code>0</code> </p>
</li>
<li><p><code>1</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * .25</code> </p>
</li>
<li><p><code>2</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * .5</code> </p>
</li>
<li><p><code>3</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer</code> </p>
</li>
<li><p><code>4</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * 1.5</code> </p>
</li>
<li><p><code>5</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * 3</code> </p>
</li>
<li><p><code>auto</code>- 用于设置<code>margin</code>为自动的类</p>
</li>
</ul>
<p>（您可以通过向<code>$spacers</code>Sass地图变量添加条目来添加更多尺寸。）</p>
</li>
<li><p>支持列嵌套</p>
</li>
</ul>
<h2 id="5-2-使用工具"><a href="#5-2-使用工具" class="headerlink" title="5.2 使用工具"></a>5.2 使用工具</h2><h4 id="5-2-1-border"><a href="#5-2-1-border" class="headerlink" title="5.2.1 border"></a>5.2.1 border</h4><p>使用边界实用程序快速设置元素的边框和边框半径。非常适合图片，按钮或任何其他元素。</p>
<p><strong>边界</strong></p>
<p>将元素添加到元素以删除所有边框或边框。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/borders/#border" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border-0"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border-top-0"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border-right-0"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border-bottom-0"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border-left-0"&gt;&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>

<p><strong>边框颜色</strong></p>
<p>使用基于主题颜色的实用程序更改边框颜色。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/borders/#border-color" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border border-primary"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border border-secondary"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border border-success"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border border-danger"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border border-warning"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border border-info"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border border-light"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="border border-dark"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"border border-white"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>边界半径</strong></p>
<p>将类添加到元素中，以便轻松使元素的角变圆。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/borders/#border-radius" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-top"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-right"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-bottom"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-left"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-circle"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"..."</span> alt=<span class="string">"..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"rounded-0"</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-清除浮动-Clearfix"><a href="#5-2-2-清除浮动-Clearfix" class="headerlink" title="5.2.2 清除浮动 | Clearfix"></a>5.2.2 清除浮动 | Clearfix</h4><p>通过添加一个clearfix实用程序，快速轻松地清除容器中的浮动内容。</p>
<p>通过添加<code>.clearfix</code> <strong>到父元素可</strong>轻松清除<code>float</code>s 。也可以用作混音。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"clearfix"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Mixin itself</span></span><br><span class="line"><span class="regexp">@mixin clearfix() &#123;</span></span><br><span class="line"><span class="regexp">  &amp;::after &#123;</span></span><br><span class="line"><span class="regexp">    display: block;</span></span><br><span class="line"><span class="regexp">    content: "";</span></span><br><span class="line"><span class="regexp">    clear: both;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Usage as a mixin</span></span><br><span class="line"><span class="regexp">.element &#123;</span></span><br><span class="line"><span class="regexp">  @include clearfix;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何使用clearfix。如果没有clearfix，则换行div不会跨越会导致布局破碎的按钮。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/clearfix/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bg-info clearfix"</span>&gt;</span><br><span class="line">  &lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-secondary float-left"</span>&gt;Example Button floated left&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button type="button" class="btn btn-secondary float-right"&gt;Example Button floated right&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-关闭图标-Close-icon"><a href="#5-2-3-关闭图标-Close-icon" class="headerlink" title="5.2.3 关闭图标 | Close icon"></a>5.2.3 关闭图标 | Close icon</h4><p>使用通用的关闭图标来解散内容，如模式和警报。</p>
<p><strong>确保为屏幕阅读器添加文字</strong>，正如我们操作<code>aria-label</code>那样。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/close-icon/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"close"</span> aria-label=<span class="string">"Close"</span>&gt;</span><br><span class="line">  &lt;span aria-hidden=<span class="string">"true"</span>&gt;&amp;times;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-颜色-Colors"><a href="#5-2-4-颜色-Colors" class="headerlink" title="5.2.4 颜色 | Colors"></a>5.2.4 颜色 | Colors</h4><p>用少数颜色工具类来表达颜色意义。包括对悬停状态样式链接的支持。</p>
<p><strong>颜色</strong></p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/colors/#color" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-primary"</span>&gt;.text-primary&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-secondary"&gt;.text-secondary&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-success"</span>&gt;.text-success&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-danger"&gt;.text-danger&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-warning"</span>&gt;.text-warning&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-info"&gt;.text-info&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-light bg-dark"</span>&gt;.text-light&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-dark"&gt;.text-dark&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-muted"</span>&gt;.text-muted&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-white bg-dark"&gt;.text-white&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>上下文文本类在提供悬停和焦点状态的锚点上也可以很好地工作。<strong>请注意，</strong> <strong><code>.text-white</code>和<code>.text-muted</code></strong> <strong>类没有链接样式。</strong></p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/colors/#color" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>Primary link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-secondary"&gt;Secondary link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-success"&gt;Success link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-danger"&gt;Danger link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-warning"&gt;Warning link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-info"&gt;Info link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-light bg-dark"&gt;Light link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-dark"&gt;Dark link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-muted"&gt;Muted link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="#" class="text-white bg-dark"&gt;White link&lt;/</span>a&gt;&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>背景颜色</strong></p>
<p>与上下文文本颜色类相似，可以轻松地将元素的背景设置为任何上下文类。就像文本类一样，锚组件会在悬停时变暗。后台实用程序<strong>没有设置</strong> <strong><code>color</code></strong>，因此在某些情况下您需要使用<code>.text-*</code>实用程序。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/colors/#background-color" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-primary text-white"</span>&gt;.bg-primary&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-secondary text-white"&gt;.bg-secondary&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-success text-white"</span>&gt;.bg-success&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-danger text-white"&gt;.bg-danger&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-warning text-white"</span>&gt;.bg-warning&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-info text-white"&gt;.bg-info&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-light text-dark"</span>&gt;.bg-light&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-dark text-white"&gt;.bg-dark&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-white text-dark"</span>&gt;.bg-white&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>背景梯度</strong></p>
<p>当<code>$enable-gradients</code>设置为true时，您将能够使用<code>.bg-gradient-</code>实用程序类。<strong>默认情况下，</strong> <code>**$enable-gradients**</code><strong>被禁用，下面的示例被故意破坏。</strong>这从您开始使用Bootstrap开始就更容易定制。后续启用相关课程以继续了解Sass选项等等。 </p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/colors/#background-gradient" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-gradient-primary text-white"</span>&gt;.bg-gradient-primary&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-gradient-secondary text-white"&gt;.bg-gradient-secondary&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-gradient-success text-white"</span>&gt;.bg-gradient-success&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-gradient-danger text-white"&gt;.bg-gradient-danger&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-gradient-warning text-white"</span>&gt;.bg-gradient-warning&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-gradient-info text-white"&gt;.bg-gradient-info&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"p-3 mb-2 bg-gradient-light text-dark"</span>&gt;.bg-gradient-light&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="p-3 mb-2 bg-gradient-dark text-white"&gt;.bg-gradient-dark&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>处理特殊性</strong></p>
<p>由于其他选择器的特殊性，有时上下文类无法应用。在某些情况下，一个充分的解决方法是将元素的内容封装``在类中。</p>
<p><strong>将意义传递给辅助技术</strong></p>
<p>使用颜色来增加意义只能提供一种视觉指示，而不会传达给辅助技术的用户 - 如屏幕阅读器。确保由颜色表示的信息或者来自内容本身（例如可见文本），或者通过其他方式包含，例如隐藏在<code>.sr-only</code>课程中的其他文本。</p>
<h4 id="5-2-5-显示属性-Display-property"><a href="#5-2-5-显示属性-Display-property" class="headerlink" title="5.2.5 显示属性 | Display property"></a>5.2.5 显示属性 | Display property</h4><p>通过我们的显示实用程序快速响应地切换组件的显示值。包括对一些更常见的值的支持，以及一些额外功能，用于控制打印时的显示。</p>
<p><strong>共同的<code>display</code>价值</strong></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code>属性</a>接受了一些值，我们用实用程序类支持其中的许多值。我们故意不提供每个价值作为实用工具，所以我们支持：</p>
<ul>
<li><p><code>.d-none</code></p>
</li>
<li><p><code>.d-inline</code></p>
</li>
<li><p><code>.d-inline-block</code></p>
</li>
<li><p><code>.d-block</code></p>
</li>
<li><p><code>.d-table</code></p>
</li>
<li><p><code>.d-table-cell</code></p>
</li>
<li><p><code>.d-flex</code></p>
</li>
<li><p><code>.d-inline-flex</code></p>
</li>
</ul>
<p>通过将任何类应用到您选择的元素来使用它们。例如，下面介绍如何使用内联，块或内联块实用程序（同样适用于其他类）。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/display/#common-display-values" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"d-inline bg-success"</span>&gt;d-inline&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="d-inline bg-success"&gt;d-inline&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://getbootstrap.com/docs/4.0/utilities/display/#common-display-values" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"d-block bg-primary"</span>&gt;d-block&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://getbootstrap.com/docs/4.0/utilities/display/#common-display-values" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"d-inline-block bg-warning"</span>&gt;d-inline-block&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="d-inline-block bg-warning"&gt;d-inline-block&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>对于上面提到的每一个实用程序也都有响应变化。</p>
<ul>
<li><p><code>.d-none</code></p>
</li>
<li><p><code>.d-inline</code></p>
</li>
<li><p><code>.d-inline-block</code></p>
</li>
<li><p><code>.d-block</code></p>
</li>
<li><p><code>.d-table</code></p>
</li>
<li><p><code>.d-table-cell</code></p>
</li>
<li><p><code>.d-flex</code></p>
</li>
<li><p><code>.d-inline-flex</code></p>
</li>
<li><p><code>.d-sm-none</code></p>
</li>
<li><p><code>.d-sm-inline</code></p>
</li>
<li><p><code>.d-sm-inline-block</code></p>
</li>
<li><p><code>.d-sm-block</code></p>
</li>
<li><p><code>.d-sm-table</code></p>
</li>
<li><p><code>.d-sm-table-cell</code></p>
</li>
<li><p><code>.d-sm-flex</code></p>
</li>
<li><p><code>.d-sm-inline-flex</code></p>
</li>
<li><p><code>.d-md-none</code></p>
</li>
<li><p><code>.d-md-inline</code></p>
</li>
<li><p><code>.d-md-inline-block</code></p>
</li>
<li><p><code>.d-md-block</code></p>
</li>
<li><p><code>.d-md-table</code></p>
</li>
<li><p><code>.d-md-table-cell</code></p>
</li>
<li><p><code>.d-md-flex</code></p>
</li>
<li><p><code>.d-md-inline-flex</code></p>
</li>
<li><p><code>.d-lg-none</code></p>
</li>
<li><p><code>.d-lg-inline</code></p>
</li>
<li><p><code>.d-lg-inline-block</code></p>
</li>
<li><p><code>.d-lg-block</code></p>
</li>
<li><p><code>.d-lg-table</code></p>
</li>
<li><p><code>.d-lg-table-cell</code></p>
</li>
<li><p><code>.d-lg-flex</code></p>
</li>
<li><p><code>.d-lg-inline-flex</code></p>
</li>
<li><p><code>.d-xl-none</code></p>
</li>
<li><p><code>.d-xl-inline</code></p>
</li>
<li><p><code>.d-xl-inline-block</code></p>
</li>
<li><p><code>.d-xl-block</code></p>
</li>
<li><p><code>.d-xl-table</code></p>
</li>
<li><p><code>.d-xl-table-cell</code></p>
</li>
<li><p><code>.d-xl-flex</code></p>
</li>
<li><p><code>.d-xl-inline-flex</code></p>
</li>
</ul>
<p><strong>隐藏元素</strong></p>
<p>为了加速移动设备的开发，请使用响应式显示类来显示和隐藏设备中的元素。避免创建完全不同的同一站点版本，而是针对每个屏幕大小响应地隐藏元素。</p>
<p>要隐藏元素，只需使用<code>.d-none</code>类或其中一个<code>.d-{sm,md,lg,xl}-none</code>类来响应任何屏幕变化。</p>
<p>要仅在给定的屏幕大小间隔上显示元素，可以组合一个<code>.d-*-none</code>类的<code>.d-*-*</code>类，例如<code>.d-none.d-md-block.d-xl-none</code>将隐藏除中型和大型设备外的所有屏幕大小的元素。</p>
<table>
<thead>
<tr>
<th align="left">屏幕尺寸</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">隐藏在所有</td>
<td align="left">d-none</td>
</tr>
<tr>
<td align="left">只在xs上隐藏</td>
<td align="left">d-none d-sm-block</td>
</tr>
<tr>
<td align="left">只隐藏在sm上</td>
<td align="left">d-sm-none d-md-block</td>
</tr>
<tr>
<td align="left">仅在md上隐藏</td>
<td align="left">d-md-none d-lg-block</td>
</tr>
<tr>
<td align="left">只隐藏在lg上</td>
<td align="left">d-lg-none d-xl-block</td>
</tr>
<tr>
<td align="left">仅在xl上隐藏</td>
<td align="left">d-xl-none</td>
</tr>
<tr>
<td align="left">全部可见</td>
<td align="left">d-block</td>
</tr>
<tr>
<td align="left">仅在xs上可见</td>
<td align="left">d-block d-sm-none</td>
</tr>
<tr>
<td align="left">仅在sm上可见</td>
<td align="left">d-none d-sm-block d-md-none</td>
</tr>
<tr>
<td align="left">仅在md上可见</td>
<td align="left">d-none d-md-block d-lg-none</td>
</tr>
<tr>
<td align="left">仅在lg上可见</td>
<td align="left">d-none d-lg-block d-xl-none</td>
</tr>
<tr>
<td align="left">仅在xl上可见</td>
<td align="left">d-none d-xl-block</td>
</tr>
</tbody></table>
<p><strong>显示打印</strong></p>
<p><code>display</code>使用我们的打印显示实用程序进行打印时更改元素的值。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">打印样式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.d-print-block</td>
<td align="left">打印时应用display:block到元素</td>
</tr>
<tr>
<td align="left">.d-print-inline</td>
<td align="left">打印时应用display:内联到元素</td>
</tr>
<tr>
<td align="left">.d-print-inline-block</td>
<td align="left">打印时应用display:inline-block到元素</td>
</tr>
<tr>
<td align="left">.d-print-none</td>
<td align="left">打印时，将元素display:none应用于元素</td>
</tr>
</tbody></table>
<h4 id="5-2-6-内嵌-embed"><a href="#5-2-6-内嵌-embed" class="headerlink" title="5.2.6 内嵌 | embed"></a>5.2.6 内嵌 | embed</h4><p><strong>内嵌 | Embeds</strong></p>
<p>通过创建可在任何设备上缩放的固有比率，根据父级的宽度创建响应式视频或幻灯片嵌入。</p>
<p><strong>关于</strong></p>
<p>规则被直接施加到<code>，</code>，<code>和</code>元件；<code>.embed-responsive-item</code>如果要为其他属性的样式进行匹配，可以使用明确的后代类。</p>
<p><strong>专家提示！</strong>你不需要包含<code>frameborder=&quot;0&quot;</code>在你的``s中，因为我们会为你覆盖。</p>
<p><strong>示例</strong></p>
<p>将任何嵌入内容嵌入到具有纵横比``的父元素中<code>.embed-responsive</code>。<code>.embed-responsive-item</code>并非严格要求，但鼓励使用。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/embed/#example" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive embed-responsive-16by9"</span>&gt;</span><br><span class="line">  &lt;iframe <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive-item"</span> src=<span class="string">"https://www.youtube.com/embed/zpOULjyy-n8?rel=0"</span> allowfullscreen&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>纵横比</strong></p>
<p>宽高比可以使用修饰符类自定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="number">21</span>:<span class="number">9</span> aspect ratio --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive embed-responsive-21by9"</span>&gt;</span><br><span class="line">  &lt;iframe <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive-item"</span> src=<span class="string">"..."</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">16</span>:<span class="number">9</span> aspect ratio --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive embed-responsive-16by9"</span>&gt;</span><br><span class="line">  &lt;iframe <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive-item"</span> src=<span class="string">"..."</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">4</span>:<span class="number">3</span> aspect ratio --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive embed-responsive-4by3"</span>&gt;</span><br><span class="line">  &lt;iframe <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive-item"</span> src=<span class="string">"..."</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="number">1</span>:<span class="number">1</span> aspect ratio --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive embed-responsive-1by1"</span>&gt;</span><br><span class="line">  &lt;iframe <span class="class"><span class="keyword">class</span></span>=<span class="string">"embed-responsive-item"</span> src=<span class="string">"..."</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-7-浮动-Float"><a href="#5-2-7-浮动-Float" class="headerlink" title="5.2.7 浮动 | Float"></a>5.2.7 浮动 | Float</h4><p>使用我们的响应式浮动实用程序在任何断点上切换任何元素上的浮点数。</p>
<p><strong>概述</strong></p>
<p>这些实用程序类使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">CSS <code>float</code>属性</a>根据当前视口大小将元素浮动到左侧或右侧，或禁用浮动。<code>!important</code>包含在内以避免特殊性问题。这些使用与我们的网格系统相同的视口断点。</p>
<p><strong>类别</strong></p>
<p>用类切换浮点数：</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/float/#classes" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"float-left"</span>&gt;Float left on all viewport sizes&lt;<span class="regexp">/div&gt;&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="float-right"&gt;Float right on all viewport sizes&lt;/</span>div&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float-none"</span>&gt;</span>Don't float on all viewport sizes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>混入</strong></p>
<p>或者是Sass Mixin：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.element &#123;</span><br><span class="line">  @include float-left;</span><br><span class="line">&#125;</span><br><span class="line">.another-element &#123;</span><br><span class="line">  @include float-right;</span><br><span class="line">&#125;</span><br><span class="line">.one-more &#123;</span><br><span class="line">  @include float-none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>响应性</strong></p>
<p>响应性的变化也存在于每一个<code>float</code>值中。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/float/#responsive" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"float-sm-left"</span>&gt;Float left on viewports sized SM (small) or wider&lt;<span class="regexp">/div&gt;&lt;br&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="float-md-left"&gt;Float left on viewports sized MD (medium) or wider&lt;/</span>div&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">&lt;div class="float-lg-left"&gt;Float left on viewports sized LG (large) or wider&lt;/div&gt;&lt;br&gt;</span><br><span class="line">&lt;div class="float-xl-left"&gt;Float left on viewports sized XL (extra-large) or wider&lt;/div&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>

<p>这里有所有的支持类。</p>
<ul>
<li><p><code>.float-left</code></p>
</li>
<li><p><code>.float-right</code></p>
</li>
<li><p><code>.float-none</code></p>
</li>
<li><p><code>.float-sm-left</code></p>
</li>
<li><p><code>.float-sm-right</code></p>
</li>
<li><p><code>.float-sm-none</code></p>
</li>
<li><p><code>.float-md-left</code></p>
</li>
<li><p><code>.float-md-right</code></p>
</li>
<li><p><code>.float-md-none</code></p>
</li>
<li><p><code>.float-lg-left</code></p>
</li>
<li><p><code>.float-lg-right</code></p>
</li>
<li><p><code>.float-lg-none</code></p>
</li>
<li><p><code>.float-xl-left</code></p>
</li>
<li><p><code>.float-xl-right</code></p>
</li>
<li><p><code>.float-xl-none</code></p>
</li>
</ul>
<h4 id="5-2-8-图像替换-Image-replacement"><a href="#5-2-8-图像替换-Image-replacement" class="headerlink" title="5.2.8 图像替换 | Image replacement"></a>5.2.8 图像替换 | Image replacement</h4><p>利用<code>.text-hide</code>类或mixin帮助用背景图像替换元素的文本内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-hide"</span> style=<span class="string">"background-image: url('/assets/brand/bootstrap-solid.svg'); width: 50px; height: 50px;"</span>&gt;Bootstrap&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-9-位置-Position"><a href="#5-2-9-位置-Position" class="headerlink" title="5.2.9 位置 | Position"></a>5.2.9 位置 | Position</h4><p>使用这些速记工具快速配置元素的位置。</p>
<p><strong>共同的价值</strong></p>
<p>快速定位类可用，但它们没有响应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"position-static"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="position-relative"&gt;...&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"position-absolute"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="position-fixed"&gt;...&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"position-sticky"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>固定顶部</strong></p>
<p>从边到边放置一个元素在视口的顶部。确保你了解项目中固定职位的影响；您可能需要添加aditional CSS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"fixed-top"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>固定底部</strong></p>
<p>将元素放置在视口的底部，从边到边。确保你了解项目中固定职位的影响；您可能需要添加aditional CSS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"fixed-bottom"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>粘顶</strong></p>
<p>将元素放置在视口的顶部，从边到边，但只能在滚过它之后进行。<code>.sticky-top</code>实用程序使用CSS <code>position: sticky</code>，这在所有浏览器中都不完全支持。</p>
<p><strong>Microsoft Edge和IE11将呈现<code>position: sticky</code>为\</strong><code>position: relative</code><strong>。</strong>因此，我们将这些样式封装在<code>@supports</code>查询中，将粘滞性限制为只能正确呈现它的浏览器。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"sticky-top"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-8-荧幕阅读器-Screenreaders"><a href="#5-2-8-荧幕阅读器-Screenreaders" class="headerlink" title="5.2.8 荧幕阅读器 | Screenreaders"></a>5.2.8 荧幕阅读器 | Screenreaders</h4><p>使用屏幕阅读器实用程序隐藏除屏幕阅读器以外的所有设备上的元素</p>
<p>隐藏所有设备的元素<strong>，除了屏幕阅读器</strong>使用<code>.sr-only</code>。<code>.sr-only</code>与<code>.sr-only-focusable</code>焦点合并时再次显示元素（例如，通过键盘用户）。也可以用作mixin。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"sr-only sr-only-focusable"</span> href=<span class="string">"#content"</span>&gt;Skip to main content&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Usage as a mixin</span></span><br><span class="line"><span class="regexp">.skip-navigation &#123;</span></span><br><span class="line"><span class="regexp">  @include sr-only;</span></span><br><span class="line"><span class="regexp">  @include sr-only-focusable;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-9-尺寸"><a href="#5-2-9-尺寸" class="headerlink" title="5.2.9 尺寸"></a>5.2.9 尺寸</h4><p>使用我们的宽度和高度实用程序轻松制作宽或高（相对于其父项）的元素。</p>
<p>宽度和高度实用程序从<code>$sizes</code>Sass地图中生成<code>_variables.scss</code>。包括支持<code>25%</code>，<code>50%</code>，<code>75%</code>，和<code>100%</code>默认。根据需要在这里生成不同的实用程序，修改这些值。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/sizing/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"w-25 p-3"</span> style=<span class="string">"background-color: #eee;"</span>&gt;Width <span class="number">25</span>%&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="w-50 p-3" style="background-color: #eee;"&gt;Width 50%&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"w-75 p-3"</span> style=<span class="string">"background-color: #eee;"</span>&gt;Width <span class="number">75</span>%&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="w-100 p-3" style="background-color: #eee;"&gt;Width 100%&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://getbootstrap.com/docs/4.0/utilities/sizing/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">"height: 100px; background-color: rgba(255,0,0,0.1);"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"h-25 d-inline-block"</span> style=<span class="string">"width: 120px; background-color: rgba(0,0,255,.1)"</span>&gt;Height <span class="number">25</span>%&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="h-50 d-inline-block" style="width: 120px; background-color: rgba(0,0,255,.1)"&gt;Height 50%&lt;/</span>div&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"h-75 d-inline-block"</span> style=<span class="string">"width: 120px; background-color: rgba(0,0,255,.1)"</span>&gt;Height <span class="number">75</span>%&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="h-100 d-inline-block" style="width: 120px; background-color: rgba(0,0,255,.1)"&gt;Height 100%&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>您也可以根据需要使用<code>max-width: 100%;</code>和使用<code>max-height: 100%;</code>实用程序。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/sizing/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"mw-100"</span> src=<span class="string">"..."</span> alt=<span class="string">"Max-width 100%"</span>&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://getbootstrap.com/docs/4.0/utilities/sizing/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">"height: 100px; background-color: rgba(255,0,0,0.1);"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mh-100"</span> style=<span class="string">"width: 100px; height: 200px; background-color: rgba(0,0,255,0.1);"</span>&gt;Max-height <span class="number">100</span>%&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-10-间隔-Spacing"><a href="#5-2-10-间隔-Spacing" class="headerlink" title="5.2.10 间隔|Spacing"></a>5.2.10 间隔|Spacing</h4><p>Bootstrap包含各种速记响应边距和填充实用程序类，以修改元素的外观。</p>
<p><strong>表示法</strong></p>
<p>适用于所有断点，从间距公用事业<code>xs</code>到<code>xl</code>，在他们没有断点的缩写。这是因为这些类是从上到下应用的<code>min-width: 0</code>，因此不受媒体查询的约束。然而，其余的断点确实包含断点缩写。</p>
<p>类别是使用的格式命名<code>{property}{sides}-{size}</code>为<code>xs</code>和<code>{property}{sides}-{breakpoint}-{size}</code>为<code>sm</code>，<code>md</code>，<code>lg</code>，和<code>xl</code>。</p>
<p>当<em>属性</em>是以下之一：</p>
<ul>
<li><p><code>m</code>-用于设置<code>margin</code></p>
</li>
<li><p><code>p</code>-用于设置<code>padding</code></p>
</li>
</ul>
<p>当<em>双方</em>是一个：</p>
<ul>
<li><p><code>t</code>-用于设置<code>margin-top</code>或<code>padding-top</code></p>
</li>
<li><p><code>b</code>-用于设置<code>margin-bottom</code>或<code>padding-bottom</code></p>
</li>
<li><p><code>l</code>-用于设置<code>margin-left</code>或<code>padding-left</code></p>
</li>
<li><p><code>r</code>-用于设置<code>margin-right</code>或<code>padding-right</code></p>
</li>
<li><p><code>x</code>-对于设置两者的类<code>*-left</code>和<code>*-right</code></p>
</li>
<li><p><code>y</code>-对于设置两者的类<code>*-top</code>和<code>*-bottom</code></p>
</li>
<li><p>为设置<code>margin</code>或<code>padding</code>元素的所有四个方面</p>
</li>
</ul>
<p>其中<em>大小</em>是以下之一：</p>
<ul>
<li><p><code>0</code>- 用于消除<code>margin</code>或<code>padding</code>通过设置的类<code>0</code> </p>
</li>
<li><p><code>1</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * .25</code> </p>
</li>
<li><p><code>2</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * .5</code> </p>
</li>
<li><p><code>3</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer</code> </p>
</li>
<li><p><code>4</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * 1.5</code> </p>
</li>
<li><p><code>5</code>- （默认情况下）的类时，设置<code>margin</code>或<code>padding</code>以<code>$spacer * 3</code> </p>
</li>
<li><p><code>auto</code>- 用于设置<code>margin</code>为自动的类</p>
</li>
</ul>
<p>（您可以通过向<code>$spacers</code>Sass地图变量添加条目来添加更多尺寸。）</p>
<p><strong>实例</strong></p>
<p>以下是这些类的一些有代表性的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.mt<span class="number">-0</span> &#123;</span><br><span class="line">  margin-top: <span class="number">0</span> !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.ml<span class="number">-1</span> &#123;</span><br><span class="line">  margin-left: ($spacer * <span class="number">.25</span>) !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.px<span class="number">-2</span> &#123;</span><br><span class="line">  padding-left: ($spacer * <span class="number">.5</span>) !important;</span><br><span class="line">  padding-right: ($spacer * <span class="number">.5</span>) !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p<span class="number">-3</span> &#123;</span><br><span class="line">  padding: $spacer !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>水平居中</strong></p>
<p>此外，Bootstrap还包含一个<code>.mx-auto</code>用于将固定宽度块级别内容水平居中的类，即具有<code>display: block</code>和<code>width</code>设置水平边距的内容<code>auto</code>。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/spacing/#horizontal-centering" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mx-auto"</span> style=<span class="string">"width: 200px;"</span>&gt;</span><br><span class="line">  Centered element</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-11-文本-Text"><a href="#5-2-11-文本-Text" class="headerlink" title="5.2.11 文本 | Text"></a>5.2.11 文本 | Text</h4><p>常见文本工具的文档和示例，以控制对齐，包装，重量等等。</p>
<p><strong>文本对齐</strong></p>
<p>轻松地将文本重新对齐到具有文本对齐类的组件。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#text-alignment" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-justify"</span>&gt;Ambitioni dedisse scripsisse iudicaretur. Cras mattis iudicium purus sit amet fermentum. Donec sed odio operae, eu vulputate felis rhoncus. Praeterea iter est quasdam res quas ex communi. At nos hinc posthac, sitientis piros Afros. Petierunt uti sibi concilium totius Galliae <span class="keyword">in</span> diem certam indicere. Cras mattis iudicium purus sit amet fermentum.&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于左对齐，右对齐和中心对齐，可以使用与网格系统使用相同视口宽度断点的响应类。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#text-alignment" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-left"</span>&gt;Left aligned text on all viewport sizes.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-center"&gt;Center aligned text on all viewport sizes.&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-right"</span>&gt;Right aligned text on all viewport sizes.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p class="text-sm-left"&gt;Left aligned text on viewports sized SM (small) or wider.&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-md-left"</span>&gt;Left aligned text on viewports sized MD (medium) or wider.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-lg-left"&gt;Left aligned text on viewports sized LG (large) or wider.&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-xl-left"</span>&gt;Left aligned text on viewports sized XL (extra-large) or wider.&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>文本换行和溢出</strong></p>
<p>防止文本与<code>.text-nowrap</code>类一起打包。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#text-wrapping-and-overflow" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-1 text-nowrap"</span>&gt;</span><br><span class="line">    Curabitur blandit tempus ardua ridiculus sed magna.</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="col-11"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="..." alt="An image to show the text doesn't wrap"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于更长的内容，您可以添加一个<code>.text-truncate</code>类以省略号截断文本。<strong>需要</strong><code>**display: inline-block**</code><strong>或</strong><code>**display: block**</code><strong><em>\</em>.**</strong>。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#text-wrapping-and-overflow" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- Block level --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-2 text-truncate"</span>&gt;</span><br><span class="line">    Praeterea iter est quasdam res quas ex communi.</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Inline level --&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"d-inline-block text-truncate"</span> style=<span class="string">"max-width: 150px;"</span>&gt;</span><br><span class="line">  Praeterea iter est quasdam res quas ex communi.</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>文本转换</strong></p>
<p>使用文本大写类转换组件中的文本。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#text-transform" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-lowercase"</span>&gt;Lowercased text.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="text-uppercase"&gt;Uppercased text.&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"text-capitalize"</span>&gt;CapiTaliZed text.&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>text-capitalize</code>只更改每个单词的第一个字母，使其他字母的大小写不受影响。</p>
<p><strong>字体粗细和斜体</strong></p>
<p>快速更改文字的粗细或斜体文字。</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/text/#font-weight-and-italics" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"font-weight-bold"</span>&gt;Bold text.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="font-weight-normal"&gt;Normal weight text.&lt;/</span>p&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"font-weight-light"</span>&gt;Light weight text.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p class="font-italic"&gt;Italic text.&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-12-垂直对齐-Vertical-alignment"><a href="#5-2-12-垂直对齐-Vertical-alignment" class="headerlink" title="5.2.12 垂直对齐 | Vertical alignment"></a>5.2.12 垂直对齐 | Vertical alignment</h4><p>轻松更改内联，内联块，内嵌表格和表格单元格元素的垂直对齐方式。</p>
<p>用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align" target="_blank" rel="noopener"><code>vertical-alignment</code></a>实用程序更改元素的对齐方式。请注意，垂直对齐仅影响内联，内联块，内联表和表格单元格元素。</p>
<p>选择<code>.align-baseline</code>，<code>.align-top</code>，<code>.align-middle</code>，<code>.align-bottom</code>，<code>.align-text-bottom</code>，和<code>.align-text-top</code>。</p>
<p>内联元素：</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/vertical-align/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-baseline"</span>&gt;baseline&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="align-top"&gt;top&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-middle"</span>&gt;middle&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="align-bottom"&gt;bottom&lt;/</span>span&gt;</span><br><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-text-top"</span>&gt;text-top&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;span class="align-text-bottom"&gt;text-bottom&lt;/</span>span&gt;</span><br></pre></td></tr></table></figure>

<p>使用表格单元格：</p>
<p><a href="https://getbootstrap.com/docs/4.0/utilities/vertical-align/#content" target="_blank" rel="noopener">打开getbootstrap.com上的示例</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;table style=<span class="string">"height: 100px;"</span>&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-baseline"</span>&gt;baseline&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td class="align-top"&gt;top&lt;/</span>td&gt;</span><br><span class="line">      &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-middle"</span>&gt;middle&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td class="align-bottom"&gt;bottom&lt;/</span>td&gt;</span><br><span class="line">      &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">"align-text-top"</span>&gt;text-top&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td class="align-text-bottom"&gt;text-bottom&lt;/</span>td&gt;</span><br><span class="line">    &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>tbody&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-13-可见性"><a href="#5-2-13-可见性" class="headerlink" title="5.2.13 可见性"></a>5.2.13 可见性</h4><p>控制具有可见性实用程序的元素的可见性，而不修改显示。</p>
<p><code>visibility</code>使用我们的可见性实用程序设置元素。它们根本不会修改<code>display</code>值，并有助于隐藏大多数用户的内容，但仍然保留屏幕阅读器的内容。</p>
<p>根据需要适用<code>.visible</code>或<code>.invisible</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"visible"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="invisible"&gt;...&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">// Class</span></span><br><span class="line">.visible &#123;</span><br><span class="line">  visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">.invisible &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage as a mixin</span></span><br><span class="line">.element &#123;</span><br><span class="line">  @include invisible(visible);</span><br><span class="line">&#125;</span><br><span class="line">.element &#123;</span><br><span class="line">  @include invisible(hidden);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript教程</title>
    <url>/2020/06/04/2020-2020-06-04-JavaScript%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h1><h2 id="1-1-JavaScript之HelloWorld"><a href="#1-1-JavaScript之HelloWorld" class="headerlink" title="1.1 JavaScript之HelloWorld"></a>1.1 JavaScript之HelloWorld</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"hello world!!!"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>script可以内联代码，也可以通过src属性来引入外部指定脚本代码</p>
<h2 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 运算符"></a>1.2 运算符</h2><p>运算元：  指的是运算符作用的对象</p>
<p>一元运算符： 作用于一个运算元</p>
<p>二元运算符： 作用于两个运算元</p>
<p>JavaScript中运算符主要用于连接简单表达式，组成一个复杂的表达式。常见的有算数表达式、比较表达式、逻辑表达式、赋值表达式等，也有单目运算符，指操作原始表达式。大多数运算符都由标点符号组成（+、&gt;=、!），也有关键字表示的运算符，如typeof、delete、instanceof等。</p>
<ul>
<li><p>一、算数运算符：<br>1、加法运算符：a + b<br>2、减法运算符： a - b<br>3、乘法运算符： a * b<br>4、除法运算符：a / b<br>5、余数运算符：a % b<br>6、自增运算符：++a 或者a++<br>7、自减运算符：–a 或者 a–<br>8、求负运算符：-a<br>9、数值运算符： +a</p>
</li>
<li><p>二、赋值运算符：<br>赋值运算符用于给变量赋值,最常见的赋值运算符是等号，表达式a=b表示将b赋值给a.<br>1、a += b // 等同于 a = a + b<br>2、a -= b // 等同于 a = a - b<br>3、a *= b // 等同于 a = a * b<br>4、a /= b // 等同于 a = a / b<br>5、a %= b // 等同于 a = a % b<br>6、a &gt;&gt;= b // 等同于 a = a &gt;&gt; b<br>7、a &lt;&lt;= b // 等同于 a = a &lt;&lt; b<br>8、a &gt;&gt;&gt;= b // 等同于 a = a &gt;&gt;&gt; b<br>9、a &amp;= b // 等同于 a = a &amp; b<br>10、a |= b // 等同于 a = a | b<br>11、a ^= b // 等同于 a = a ^ b</p>
</li>
<li><p>三、比较运算符：<br>比较运算符比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript提供了8个比较运算符。<br>1、相等:==<br>2、严格相等: ===<br>3、不相等:!=<br>4、严格不相等:!==<br>5、小于:&lt;<br>6、小于或等于:&lt;=<br>7、大于:&gt;<br>8、大于或等于:&gt;=</p>
</li>
<li><p>四、三元运算符:<br>语法：表达式1 ? 表达式2 : 表达式3<br>说明：如果表达式1为true ，则整个表达式的结果就是表达式2的值，如果表达式false，则整个表达式的结果就是表达式3的值.</p>
</li>
<li><p>五、位运算符:<br>1、或运算：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。<br>2、与运算：符号为&amp;，表示两个二进制位都为1，则结果为1，否则为0。<br>3、否运算：符号为～，表示将一个二进制位变成相反值。<br>4、异或运算：符号为ˆ，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。<br>5、左移运算：符号为&lt;&lt;右<br>6、移运算：符号为&gt;&gt;</p>
</li>
</ul>
<p><strong>运算符的优先级</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>运算符</strong></th>
<th align="center"><strong>说明</strong></th>
<th align="center"><strong>结合性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>[]</code>、<code>.</code>、<code>()</code></td>
<td align="center">字段访问、数组索引、函数调用和表达式分组</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">++ – -~!delete new typeof void</td>
<td align="center">一元运算符、返回数据类型、对象创建、未定 义的值</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*、/、%</td>
<td align="center">相乘、相除、求余数</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+、-</td>
<td align="center">相加、相减、字符串串联</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td>
<td align="center">左位移、右位移、无符号右移</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td align="center">小于、小于或等于、大于、大于或等于、是否 为特定类的实例</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">==、!=、===、!==</td>
<td align="center">相等、不相等、全等，不全等</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;</td>
<td align="center">按位“与”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">^</td>
<td align="center">按位“异或”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">|</td>
<td align="center">按位“或”</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&amp;&amp;</td>
<td align="center">短路与（逻辑“与”）</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">||</td>
<td align="center">短路或（逻辑“或”）</td>
<td align="center">从左向右</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">?:</td>
<td align="center">条件运算符</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">=、+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;、&lt;=、&gt;、&gt;=、&gt;&gt;=</td>
<td align="center">混合赋值运算符</td>
<td align="center">从右向左</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">,</td>
<td align="center">多个计算</td>
<td align="center">按优先级计算，然后从右向左</td>
</tr>
</tbody></table>
<h2 id="1-3-switch语句"><a href="#1-3-switch语句" class="headerlink" title="1.3 switch语句"></a>1.3 switch语句</h2><p><code>switch</code> 语句可以替代多个 <code>if</code> 判断。</p>
<p><code>switch</code> 语句为多分支选择的情况提供了一个更具描述性的方式。</p>
<p><code>switch</code> 语句有至少一个 <code>case</code> 代码块和一个可选的 <code>default</code> 代码块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    alert( <span class="string">'Too small'</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert( <span class="string">'Exactly!'</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert( <span class="string">'Too big'</span> );</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert( <span class="string">"I don't know such values"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任何表达式都可以成为</strong> <code>switch/case</code> <strong>的参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (+a) &#123;</span><br><span class="line">  <span class="keyword">case</span> b + <span class="number">1</span>:</span><br><span class="line">    alert(<span class="string">"this runs, because +a is 1, exactly equals b+1"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">"this doesn't run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>+a</code> 返回 <code>1</code>，这个值跟 <code>case</code> 中 <code>b + 1</code> 相比较，然后执行对应的代码。</p>
<p><strong>Case分组</strong></p>
<p>共享同一段代码的几个 <code>case</code> 分支可以被分为一组：</p>
<p>比如，如果我们想让 <code>case 3</code> 和 <code>case 5</code> 执行同样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    alert(<span class="string">'Right!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// (*) 下面这两个 case 被分在一组</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    alert(<span class="string">'Wrong!'</span>);</span><br><span class="line">    alert(<span class="string">"Why don't you take a math class?"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    alert(<span class="string">'The result is strange. Really.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch的case执行的是严格相等，因此类型必须匹配</strong></p>
<h2 id="1-4-值的比较"><a href="#1-4-值的比较" class="headerlink" title="1.4 值的比较"></a>1.4 值的比较</h2><p>值的比较</p>
<p>我们知道，在数学中有很多用于比较大小的运算符：</p>
<ul>
<li>大于 / 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。</li>
<li>大于等于 / 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。</li>
<li>检查两个值的相等：<code>a == b</code>（注意表达式中是两个等号 <code>=</code>，若写为单个等号 <code>a = b</code> 则表示赋值）。</li>
<li>检查两个值不相等，在数学中使用 <code>≠</code> 符号，而在 JavaScript 中则通过在赋值符号前加叹号表示：`a != b</li>
</ul>
<p><a href="https://zh.javascript.info/comparison#bi-jiao-jie-guo-wei-boolean-lei-xing" target="_blank" rel="noopener">比较结果为 Boolean 类型</a></p>
<p>和其他运算符一样，比较运算符也会有返回值，返回值为布尔值（Boolean）。</p>
<ul>
<li><code>true</code> —— 表示“yes（是）”，“correct（正确）”或“the truth（真相）”。</li>
<li><code>false</code> —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真相）”。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">2</span> &gt; <span class="number">1</span> );  <span class="comment">// true（正确）</span></span><br><span class="line">alert( <span class="number">2</span> == <span class="number">1</span> ); <span class="comment">// false（错误）</span></span><br><span class="line">alert( <span class="number">2</span> != <span class="number">1</span> ); <span class="comment">// true（正确）</span></span><br></pre></td></tr></table></figure>

<p>和其他类型的值一样，比较的结果可以被赋值给任意变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">5</span> &gt; <span class="number">4</span>; <span class="comment">// 把比较的结果赋值给 result</span></span><br><span class="line">alert( result ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh.javascript.info/comparison#zi-fu-chuan-bi-jiao" target="_blank" rel="noopener">字符串比较</a></p>
<p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。</p>
<p>换言之，字符串是按字符（母）逐个进行比较的。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">'Z'</span> &gt; <span class="string">'A'</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">'Glow'</span> &gt; <span class="string">'Glee'</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="string">'Bee'</span> &gt; <span class="string">'Be'</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>字符串的比较算法非常简单：</p>
<ol>
<li>首先比较两个字符串的首位字符大小。</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。</li>
</ol>
<p>在上面的例子中，<code>&#39;Z&#39; &gt; &#39;A&#39;</code> 在算法的第 1 步就得到了返回结果，而字符串 <code>Glow</code> 与 <code>Glee</code> 则继续逐个字符比较：</p>
<ol>
<li><code>G</code> 和 <code>G</code> 相等。</li>
<li><code>l</code> 和 <code>l</code> 相等。</li>
<li><code>o</code> 比 <code>e</code> 大，算法停止，第一个字符串大于第二个。</li>
</ol>
<p><strong>非真正的字典顺序，而是 Unicode 编码顺序</strong></p>
<p>在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。</p>
<p>比如说，字符串比较对字母大小写是敏感的。大写的 <code>&quot;A&quot;</code> 并不等于小写的 <code>&quot;a&quot;</code>。哪一个更大呢？实际上小写的 <code>&quot;a&quot;</code> 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 <a href="https://zh.javascript.info/string" target="_blank" rel="noopener">字符串</a> 这章讨论更多关于字符串的细节。</p>
<p><a href="https://zh.javascript.info/comparison#bu-tong-lei-xing-jian-de-bi-jiao" target="_blank" rel="noopener">不同类型间的比较</a></p>
<p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">'2'</span> &gt; <span class="number">1</span> ); <span class="comment">// true，字符串 '2' 会被转化为数字 2</span></span><br><span class="line">alert( <span class="string">'01'</span> == <span class="number">1</span> ); <span class="comment">// true，字符串 '01' 会被转化为数字 1</span></span><br></pre></td></tr></table></figure>

<p>对于布尔类型值，<code>true</code> 会被转化为 <code>1</code>、<code>false</code> 转化为 <code>0</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="literal">true</span> == <span class="number">1</span> ); <span class="comment">// true</span></span><br><span class="line">alert( <span class="literal">false</span> == <span class="number">0</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>一个有趣的现象</strong></p>
<p>有时候，以下两种情况会同时发生：</p>
<ul>
<li>若直接比较两个值，其结果是相等的。</li>
<li>若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 <code>true</code>，一个是 <code>false</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">alert( <span class="built_in">Boolean</span>(a) ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"0"</span>;</span><br><span class="line">alert( <span class="built_in">Boolean</span>(b) ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">alert(a == b); <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 <code>&quot;0&quot;</code> 变成了 <code>0</code>）。若只是将一个变量转化为 <code>Boolean</code> 值，则会使用其他的类型转换规则。</p>
<p><a href="https://zh.javascript.info/comparison#yan-ge-xiang-deng" target="_blank" rel="noopener">严格相等</a></p>
<p>普通的相等性检查 <code>==</code> 存在一个问题，它不能区分出 <code>0</code> 和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">0</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也同样无法区分空字符串和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">''</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是因为在比较不同类型的值时，处于相等判断符号 <code>==</code> 两侧的值会先被转化为数字。空字符串和 <code>false</code> 也是如此，转化后它们都为数字 0。</p>
<p>如果我们需要区分 <code>0</code> 和 <code>false</code>，该怎么办？</p>
<p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
<p>换句话说，如果 <code>a</code> 和 <code>b</code> 属于不同的数据类型，那么 <code>a === b</code> 不会做任何的类型转换而立刻返回 <code>false</code>。</p>
<p>让我们试试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="number">0</span> === <span class="literal">false</span> ); <span class="comment">// false，因为被比较值的数据类型不同</span></span><br></pre></td></tr></table></figure>

<p>同样的，与“不相等”符号 <code>!=</code> 类似，“严格不相等”表示为 <code>!==</code>。</p>
<p>严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。</p>
<p><a href="https://zh.javascript.info/comparison#dui-null-he-undefined-jin-hang-bi-jiao" target="_blank" rel="noopener">对 null 和 undefined 进行比较</a></p>
<p>当使用 <code>null</code> 或 <code>undefined</code> 与其他值进行比较时，其返回结果常常出乎你的意料。</p>
<ul>
<li><p>当使用严格相等 <code>===</code> 比较二者时</p>
<p>它们不相等，因为它们属于不同的类型。<code>alert( null === undefined ); // false</code></p>
</li>
<li><p>当使用非严格相等 <code>==</code> 比较二者时</p>
<p>JavaScript 存在一个特殊的规则，会判定它们相等。他们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。<code>alert( null == undefined ); // true</code></p>
</li>
<li><p>当使用数学式或其他比较方法 <code>&lt; &gt; &lt;= &gt;=</code> 时：</p>
<p><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</p>
</li>
</ul>
<p>下面让我们看看，这些规则会带来什么有趣的现象。同时更重要的是，我们需要从中学会如何远离这些特性带来的“陷阱”。</p>
<p><a href="https://zh.javascript.info/comparison#qi-guai-de-jie-guo-nullvs0" target="_blank" rel="noopener">奇怪的结果：null vs 0</a></p>
<p>通过比较 <code>null</code> 和 0 可得：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">                               alert( <span class="literal">null</span> &gt; <span class="number">0</span> );  <span class="comment">// (1) false</span></span><br><span class="line">alert( <span class="literal">null</span> == <span class="number">0</span> ); <span class="comment">// (2) false</span></span><br><span class="line">alert( <span class="literal">null</span> &gt;= <span class="number">0</span> ); <span class="comment">// (3) true</span></span><br></pre></td></tr></table></figure>

<p>是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“<code>null</code> 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。</p>
<p>为什么会出现这种反常结果，这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。这就是为什么（3）中 <code>null &gt;= 0</code> 返回值是 true，（1）中 <code>null &gt; 0</code> 返回值是 false。</p>
<p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 <code>null == 0</code> 会返回 false。</p>
<p><a href="https://zh.javascript.info/comparison#te-li-du-hang-de-undefined" target="_blank" rel="noopener">特立独行的 undefined</a></p>
<p><code>undefined</code> 不应该被与其他值进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="literal">undefined</span> &gt; <span class="number">0</span> ); <span class="comment">// false (1)</span></span><br><span class="line">alert( <span class="literal">undefined</span> &lt; <span class="number">0</span> ); <span class="comment">// false (2)</span></span><br><span class="line">alert( <span class="literal">undefined</span> == <span class="number">0</span> ); <span class="comment">// false (3)</span></span><br></pre></td></tr></table></figure>

<p>为何它看起来如此厌恶 0？返回值都是 false！</p>
<p>原因如下：</p>
<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
<p><a href="https://zh.javascript.info/comparison#gui-bi-cuo-wu" target="_blank" rel="noopener">规避错误</a></p>
<p>我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：</p>
<p>除了严格相等 <code>===</code> 外，其他凡是有 <code>undefined/null</code> 参与的比较，我们都需要额外小心。</p>
<p>除非你非常清楚自己在做什么，否则永远不要使用 <code>&gt;= &gt; &lt; &lt;=</code> 去比较一个可能为 <code>null/undefined</code> 的变量。对于取值可能是 <code>null/undefined</code> 的变量，请按需要分别检查它的取值情况。</p>
<p><a href="https://zh.javascript.info/comparison#zong-jie" target="_blank" rel="noopener">总结</a></p>
<ul>
<li>比较运算符始终返回布尔值。</li>
<li>字符串的比较，会按照“词典”顺序逐字符地比较大小。</li>
<li>当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。</li>
<li>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</li>
<li>在使用 <code>&gt;</code> 或 <code>&lt;</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</li>
</ul>
<h2 id="1-5-函数Function"><a href="#1-5-函数Function" class="headerlink" title="1.5 函数Function"></a>1.5 函数Function</h2><p>一、函数基本概念</p>
<p>　　为完成某一功能的程序指令(语句)的集合，称为函数。</p>
<p>二、JavaScript函数的分类</p>
<p>　　1、自定义函数(我们自己编写的函数)，如：function funName(){}</p>
<p>　　2、系统函数(JavaScript自带的函数)，如alert函数。</p>
<p>三、函数的调用方式</p>
<p>　　1、普通调用：functionName(实际参数…)</p>
<p>　　2、通过指向函数的变量去调用：</p>
<p>　　　　　　var myVar=函数名;</p>
<p>　　　　　　myVar(实际参数…);</p>
<p>四、函数返回值</p>
<p>　　1.当函数无明确返回值时，返回的值就是”undefined”。</p>
<p>　　2.当函数有返回值时，返回值是什么就返回什么。</p>
<p>五、函数的可变参数:</p>
<p>函数的参数列表可以是任意多个，并且数据类型可以是任意的类型，JavaScript的函数天然支持可变参数，JavaScript有一个arguments变量可以访问所有传到函数内部的参数。</p>
<p><strong>范例：JavaScript使用arguments创建参数可变的函数</strong></p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">/*add函数是一个参数可变的函数*/</span></span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">var</span> result=<span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line"> <span class="number">6</span>             <span class="comment">//alert(arguments[i]);</span></span><br><span class="line"> <span class="number">7</span>             result+=<span class="built_in">arguments</span>[i];</span><br><span class="line"> <span class="number">8</span>         &#125;</span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     alert(<span class="string">"add(1,2,3)="</span>+add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用add函数时传入3个参数</span></span><br><span class="line"><span class="number">13</span>     alert(<span class="string">"add(1,2,3,4,5,6)="</span>+add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));<span class="comment">//调用add函数时传入6个参数</span></span><br><span class="line"><span class="number">14</span>     alert(<span class="string">"add()="</span>+add());<span class="comment">//调用add函数时不传入参数</span></span><br><span class="line"><span class="number">15</span>     alert(<span class="string">"add(1,\"HelloWorld\")="</span>+add(<span class="number">1</span>,<span class="string">"HelloWorld"</span>));<span class="comment">//调用add函数时传入不同类型的参数</span></span><br><span class="line"><span class="number">16</span>   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>六、函数的动态创建</p>
<p>　　<strong>创建动态函数的基本格式：var 变量名 = new Function(“参数1”，”参数2”，”参数n”，”执行语句”);</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="number">2</span>     <span class="keyword">var</span> square = <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"var sum ; sum = x+y;return sum;"</span>);</span><br><span class="line"><span class="number">3</span>     alert(<span class="string">"square(2,3)的结果是："</span>+square(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"><span class="number">4</span>   &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>七、匿名函数</p>
<p>　直接声明一个匿名函数，立即使用。用匿名函数的好处就是省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突，一旦命名冲突以最后声明的为准。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="function"><span class="keyword">function</span>(<span class="params">i1, i2</span>) </span>&#123; <span class="keyword">return</span> i1 + i2; &#125;(<span class="number">10</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>八、JavaScript不支持函数重载</p>
<p>九. 函数表达式</p>
<p>另一种创建函数的语法称为 <strong>函数表达式</strong>。</p>
<p>通常会写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，函数被创建并像其他赋值一样，被明确地分配给了一个变量。不管函数是被怎样定义的，都只是一个存储在变量 <code>sayHi</code> 中的值。</p>
<p>上面这两段示例代码的意思是一样的：“创建一个函数，并把它存进变量 <code>sayHi</code>”。</p>
<p>我们还可以用 <code>alert</code> 打印这个变量值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( sayHi ); <span class="comment">// 显示函数代码</span></span><br></pre></td></tr></table></figure>

<p>注意，最后一行代码并不会运行函数，因为 <code>sayHi</code> 后没有括号。在其他编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。</p>
<p>在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。</p>
<p>的确，在某种意义上说一个函数是一个特殊值，我们可以像 <code>sayHi()</code> 这样调用它。</p>
<p>但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。</p>
<p>我们可以复制函数到其他变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// (1) 创建</span></span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;    <span class="comment">// (2) 复制</span></span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// Hello     // (3) 运行复制的值（正常运行）！</span></span><br><span class="line">sayHi(); <span class="comment">// Hello    //     这里也能运行（为什么不行呢）</span></span><br></pre></td></tr></table></figure>

<p>解释一下上段代码发生的细节：</p>
<ol>
<li><code>(1)</code> 行声明创建了函数，并把它放入到变量 <code>sayHi</code>。</li>
<li><code>(2)</code> 行将 <code>sayHi</code> 复制到了变量 <code>func</code>。请注意：<code>sayHi</code> 后面没有括号。如果有括号，<code>func = sayHi()</code> 会把 <code>sayHi()</code> 的调用结果写进<code>func</code>，而不是 <code>sayHi</code> <strong>函数</strong> 本身。</li>
<li>现在函数可以通过 <code>sayHi()</code> 和 <code>func()</code> 两种方式进行调用。</li>
</ol>
<p>注意，我们也可以在第一行中使用函数表达式来声明 <code>sayHi</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello"</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这两种声明的函数是一样的。</p>
<p><strong>为什么这里末尾会有个分号？</strong></p>
<p>你可能想知道，为什么函数表达式结尾有一个分号 <code>;</code>，而函数声明没有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>答案很简单：</p>
<ul>
<li>在代码块的结尾不需要加分号 <code>;</code>，像 <code>if { ... }</code>，<code>for { }</code>，<code>function f { }</code> 等语法结构后面都不用加。</li>
<li>函数表达式是在语句内部的：<code>let sayHi = ...;</code>，作为一个值。它不是代码块而是一个赋值语句。不管值是什么，都建议在语句末尾添加分号 <code>;</code>。所以这里的分号与函数表达式本身没有任何关系，它只是用于终止语句。</li>
</ul>
<h2 id="1-6-现代模式”use-strict”"><a href="#1-6-现代模式”use-strict”" class="headerlink" title="1.6 现代模式”use strict”"></a>1.6 现代模式”use strict”</h2><p>严格模式是在ES5中引入的，它可以视为JS的一个子集，在严格模式下，限制了JS的标准使用下一些行为。</p>
<ul>
<li>严格模式消除了一些 JavaScript的静默错误，通过改变它们来抛出错误。</li>
<li>严格的模式修复了 JavaScript引擎难以执行优化的错误：有时候，严格模式代码可以比非严格模式的相同的代码运行得更快。</li>
<li>严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。</li>
</ul>
<p>这个指令看上去像一个字符串 <code>&quot;use strict&quot;</code> 或者 <code>&#39;use strict&#39;</code>。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p>
<p><code>&quot;use strict&quot;</code> 可以被放在函数主体的开头，而不是整个脚本的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<p>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p>
<p>一旦进入了严格模式，就没有回头路了。</p>
<h4 id="一：简单介绍"><a href="#一：简单介绍" class="headerlink" title="一：简单介绍"></a>一：简单介绍</h4><p>严格模式是在ES5中引入的，它可以视为JS的一个子集，在严格模式下，限制了JS的标准使用下一些行为。</p>
<ul>
<li>严格模式消除了一些 JavaScript的静默错误，通过改变它们来抛出错误。</li>
<li>严格的模式修复了 JavaScript引擎难以执行优化的错误：有时候，严格模式代码可以比非严格模式的相同的代码运行得更快。</li>
<li>严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。</li>
</ul>
<p>但是需要注意的是：<strong>不支持严格模式的浏览器将会执行与支持严格模式的浏览器不同行为的严格模式代码。</strong>所以不要依靠严格模式，而是应当加强自己代码的鲁棒性</p>
<h4 id="二：使用方法"><a href="#二：使用方法" class="headerlink" title="二：使用方法"></a>二：使用方法</h4><p>严格模式可以应用于整个脚本或单个函数中。其中的<strong>脚本</strong>不仅仅包括了单个文件，还包括了<strong>dom中事件处理，eval()，Function()，以及window.setTimeOut()中的字符串</strong>。</p>
<h5 id="1：为某个脚本使用严格模式"><a href="#1：为某个脚本使用严格模式" class="headerlink" title="1：为某个脚本使用严格模式"></a>1：为某个脚本使用严格模式</h5><p>需要在<strong>所有代码</strong>前，声明</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure>

<p><em>PS：注意，必须为”use strict”;或者’use strict’;，且必须带分号结束。</em><br> 但这种使用方式在存在代码引用和合并的时候，会无法正常激活严格模式。因为，当一个声明了严格模式的脚本，被引入合并到一个新的未使用严格模式的脚本中的时候，由于声明并没有在<strong>所有代码</strong>前使用，从而导致严格模式声明失败。<br> 为了保证严格模式的正常使用，一般的做法是用一个外部匿名函数将使用严格模式的脚本封装，然后执行。代码一般如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">/**** 原有脚本代码 ****/</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，这种方法，会将原有的代码封装到一个全局环境的函数中，原有脚本代码的作用域由全局变为了函数内部作用域，因此在使用的时候，务必注意。<br> <em>PS:一个变通的方法是，将内部脚本需要全局的变量，直接声明为全局变量，即不用var或者let定义，比如a，不适用var a;或者let a;，而是直接 a = xxx</em></p>
<h5 id="2：单函数使用严格模式"><a href="#2：单函数使用严格模式" class="headerlink" title="2：单函数使用严格模式"></a>2：单函数使用严格模式</h5><p>单函数使用严格模式，只需要在函数代码开头声明</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure>

<p>即可</p>
<h4 id="三：严格模式带来的具体差异"><a href="#三：严格模式带来的具体差异" class="headerlink" title="三：严格模式带来的具体差异"></a>三：严格模式带来的具体差异</h4><h5 id="1：消除了静默错误，改为抛出错误"><a href="#1：消除了静默错误，改为抛出错误" class="headerlink" title="1：消除了静默错误，改为抛出错误"></a>1：消除了静默错误，改为抛出错误</h5><ul>
<li>无法静默声明全局变量<br> 全局变量必须显式声明，标准模式下，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i未声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的参数必须命名唯一<br> 在正常模式中，如果函数的参数中出现重名，则最后出现的重名参数替换之前出现的参数，但之前出现的参数依然可以通过arguments属性读取。在严格模式下，禁止出现这种情况，此时会跳出错误。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>)</span>&#123; <span class="comment">// !!! 语法错误</span></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">return</span> a + a + c; <span class="comment">// 代码运行到这里会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象的属性名必须唯一<br> 严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">1</span>, <span class="attr">p</span>: <span class="number">2</span> &#125;; <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>禁止出现八进制数字数据<br> 在ES标准中，并没有八进制数据，但现在的浏览器都支持以0开头作为八进制数据。严格模式下禁止了这种数据类型，但在ES6中，新引入了’0o’前缀来表示八进制数据</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">015</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>o10; <span class="comment">// ES6: 八进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任何在正常模式下引起静默失败的赋值操作 (给不可赋值的全局变量赋值，给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 给不可扩展对象(<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FpreventExtensions" target="_blank" rel="noopener">non-extensible</a> object)的新属性赋值) 都会抛出异常</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="literal">NaN</span> = <span class="number">1</span>; <span class="comment">// 不可复制的全局变量</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> v() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"v"</span>, &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;); <span class="comment">// 不可写的属性</span></span><br><span class="line">o.v = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  <span class="keyword">get</span> v() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;  <span class="comment">// 只读属性</span></span><br><span class="line">&#125;;</span><br><span class="line">o1.v = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可扩展对象的新属性赋值</span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = <span class="string">"ohai"</span>; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>试图删除不可删除的属性时会抛出异常</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// 抛出TypeError错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ECMAScript 6中的严格模式禁止设置<a href="https://link.jianshu.com?t=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2Fprimitive" target="_blank" rel="noopener">primitive</a>值的属性.</li>
</ul>
<h5 id="2：修复了JS的随意性，提升了优化能力"><a href="#2：修复了JS的随意性，提升了优化能力" class="headerlink" title="2：修复了JS的随意性，提升了优化能力"></a>2：修复了JS的随意性，提升了优化能力</h5><p>在标准模式下，JS的随意性，或者灵活性，是的很多变量，只有在运行时才能确切知道具体指向，这就使得变量名到内存的映射也只有到运行时才能完成。严格模式修复了大部分这种行为，使得所有的变量名在编译的时候，就已经可以一起进行优化，从而提升了执行速度。</p>
<ul>
<li>禁止使用with<br> 在标准模式中，使用with的时候，with代码块内的变量，只有在运行时，才能根据with引入的Obj是否存在相应的属性，来确定具体的指向。因此，严格模式禁止使用with</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">with</span> (obj) <span class="comment">// !!! 语法错误</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？</span></span><br><span class="line">  <span class="comment">// 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。</span></span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>eval不在为上层作用域引入新变量<br> 在标准模式下，如果某个函数内部引入了eval代码。那么在函数内部，所有出现的<em>名称</em>（也就是所有的变量名）应当映射到的变量，除了引用到函数的参数，以及函数的内部变量，可以在编译的时候确定外，其他所有的<em>名称</em>只有在运行的时候，执行完eval代码后才能映射到相应的变量。因为有些变量可能是由eval代码引入到函数作用域的。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> evalX = <span class="built_in">eval</span>(<span class="string">"'use strict'; var x = 42; x"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="number">17</span>); <span class="comment">// true  未能引入x，所以还是原来的x，但如果去掉 use strict，那么为false</span></span><br><span class="line"><span class="built_in">console</span>.log(evalX === <span class="number">42</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但在严格格式下，eval不在为上层作用域引入新的局部变量和全局变量。所有的eval中出现的变量，只在eval的字符串代码块中有效。<br> 另外如果判定eval是否为严格模式，也存在各种复杂的情况。<br> – 如果<em>直接</em>调用eval(…)代码的代码块显式使用了严格格式，那么eval()也执行严格格式。如下面代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">eval</span>(...)  <span class="comment">// 无论eval中的字符串是否包含 use strict; 都会进入严格格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– 如果直接调用eval的代码块未使用严格模式，而是更上级别的代码块使用了严格模式，则eval代码按照标准模式执行，如下面代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  f()&#123;&#125; <span class="comment">// 无论eval中的字符串是否包含 use strict; 都会进入严格格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>– 如果eval(…)的字符串中显式使用了’use strict’; 则必然进入严格模式</p>
<ul>
<li>严格模式禁止删除声明变量</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// !!! 语法错误</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var y; delete y;"</span>); <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<h5 id="3：让eval和arguments变的更加简单"><a href="#3：让eval和arguments变的更加简单" class="headerlink" title="3：让eval和arguments变的更加简单"></a>3：让eval和arguments变的更加简单</h5><ul>
<li>严格模式下，eval和arguments作为保留字<br> 在严格模式下，不允许对eval和arguments进行赋值或者绑定，以下代码全部为错误语法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="number">17</span>;</span><br><span class="line"><span class="built_in">arguments</span>++;</span><br><span class="line">++<span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="keyword">set</span> p(arguments) &#123; &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">eval</span>) </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arguments"</span>, <span class="string">"'use strict'; return 17;"</span>);</span><br></pre></td></tr></table></figure>

<p>经过测试，这里的不得对arguments的复制，指的是arguments这个变量，而不是指的其中的元素，比如</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  a = <span class="number">42</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">17</span>;  <span class="comment">// 可以通过语法检测，但并不会修改b的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然是允许的，也可以通过语法检测。</p>
<ul>
<li>严格模式下，参数的值，不会随arguments对象的值的变化而修改。arguments对象的值的修改也不会影响同名函数。<br> 在标准模式下，比如一个函数第一个参数为arg，那么在函数内部，修改arg的时候，也会同步修改arguments[0]，反之亦然。但在严格模式下，两者进行了隔离。函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。</li>
<li>不再支持arguments. callee</li>
</ul>
<h5 id="4：更加安全的JS"><a href="#4：更加安全的JS" class="headerlink" title="4：更加安全的JS"></a>4：更加安全的JS</h5><ul>
<li>对this的严格限制<br> 在普通模式下，无论任何情况下，this都是一个对象。需要注意：this的指向不在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，在标准模式下，只想调用函数的对象。但如果是箭头函数，则this为定义时上下文的this。<br> -使用new新建对象</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> test()</span><br><span class="line"><span class="built_in">console</span>.log(t)  <span class="comment">// this 为新建的对象</span></span><br></pre></td></tr></table></figure>

<p>-使用call，apply，bind传入this，如果传入的是数字，字符串，布尔值等，那么就会将这些基本数据的this转换为Number，String，Boolean对象类型。如果传入的是null和undefined，则为全局变量window，默认调用下，this也为window</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.log(typeof <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">()</span></span>);  <span class="comment">// window  需要注意，单独的此类 fun()，等价于window.fun()。所以为window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="number">2</span>)</span></span>); <span class="comment">// Number</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="string">'2018-01-01 10:00:00'</span>)</span></span>); <span class="comment">// String</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(<span class="literal">null</span>)</span></span>); <span class="comment">// window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(undefined)</span></span>); <span class="comment">// window</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">bind</span><span class="params">(<span class="literal">true</span>)</span></span>()); <span class="comment">// Boolean</span></span><br></pre></td></tr></table></figure>

<p>上面的这种模式既增加了转换为对象的对象的开销，又因为将全局对象window暴露出来造成安全性问题。<br> 因此在严格模式下指定的this不再被封装为对象，而且如果没有指定this的话它值是undefined，上面的结果如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.log(typeof <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">()</span></span>);  <span class="comment">// undefined</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="number">2</span>)</span></span>); <span class="comment">// 2</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(<span class="string">'2018-01-01 10:00:00'</span>)</span></span>); <span class="comment">// '2018-01-01 10:00:00'</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">apply</span><span class="params">(<span class="literal">null</span>)</span></span>); <span class="comment">// null</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">call</span><span class="params">(undefined)</span></span>); <span class="comment">// undefined</span></span><br><span class="line">console.log(<span class="function"><span class="keyword">fun</span>.<span class="title">bind</span><span class="params">(<span class="literal">true</span>)</span></span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>禁止对函数扩展，fun.caller和fun.arguments进行读取和复制<br> 在普通模式下用这些扩展的话，当一个叫fun的函数正在被调用的时候，fun.caller是最后一个调用fun的函数，而且fun.arguments包含调用fun时用的形参。通过这些扩展，可以让<em>不安全</em>的用户操作到危险的属性。<br> 因此在严格模式下，fun.caller和fun.arguments都是不可删除的属性而且在存值、取值时都会报错</li>
</ul>
<h5 id="5：对未来的兼容"><a href="#5：对未来的兼容" class="headerlink" title="5：对未来的兼容"></a>5：对未来的兼容</h5><ul>
<li>增加了一些保留字<br> 在严格模式中一部分字符变成了保留的关键字。这些字符包括implements, interface, let, package, private, protected, public, static和yield</li>
<li>禁止不在脚本或者函数层面声明函数<br> 所谓的脚本层面，指的是文件的全局作用域。而函数层面，指的是函数的直接作用域，这里并不包括了脚本中的块作用域，以及函数中嵌套的块作用域</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 合法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eit</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 同样合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-变量"><a href="#1-7-变量" class="headerlink" title="1.7 变量"></a>1.7 变量</h2><p>如果将变量想象成一个“数据”的盒子，盒子上有一个唯一的标注盒子名字的贴纸。这样我们能更轻松地掌握“变量”的概念。</p>
<p>例如，变量 <code>message</code> 可以被想象成一个标有 <code>&quot;message&quot;</code> 的盒子，盒子里面的值为 <code>&quot;Hello!&quot;</code>：</p>
<p>我们可以在盒子内放入任何值。</p>
<p>并且，这个盒子的值，我们想改变多少次，就可以改变多少次：</p>
<p>当值改变的时候，之前的数据就被从变量中删除了：</p>
<p><strong>变量命名</strong></p>
<p>JavaScript 的变量命名有两个限制：</p>
<ol>
<li>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</li>
<li>首字符必须非数字。</li>
</ol>
<p><strong>全局变量和局部变量</strong></p>
<p>全局变量： 声明在全局环境下的变量或者在函数中未使用var而直接赋值的变量也会被自动提升到全局环境</p>
<p>局部变量： 在函数内容声明的变量，只在函数内部有效，如果与全局变量重名，则优先级更高</p>
<h2 id="1-8-条件运算符和"><a href="#1-8-条件运算符和" class="headerlink" title="1.8 条件运算符和?"></a>1.8 条件运算符和?</h2><p><code>if(...)</code> 语句计算括号里的条件表达式，如果计算结果是 <code>true</code>，就会执行对应的代码块。</p>
<p><code>if (…)</code> 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。</p>
<ul>
<li>数字 <code>0</code>、空字符串 <code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都会被转换成 <code>false</code>。因为他们被称为 “falsy” 值。</li>
<li>其他值被转换为 <code>true</code>，所以它们被称为 “truthy”。</li>
</ul>
<p>所以，下面这个条件下的代码永远不会执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">// 0 是 falsy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……但下面的条件 —— 始终有效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="comment">// 1 是 truthy</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以将未计算的布尔值传入 <code>if</code> 语句，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cond = (year == <span class="number">2015</span>); <span class="comment">// 相等运算符的结果是 true 或 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。</p>
<p>有时我们需要测试一个条件的几个变体。我们可以通过使用 <code>else if</code> 子句实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = prompt(<span class="string">'In which year was ECMAScript-2015 specification published?'</span>, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">2015</span>) &#123;</span><br><span class="line">  alert( <span class="string">'Too early...'</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (year &gt; <span class="number">2015</span>) &#123;</span><br><span class="line">  alert( <span class="string">'Too late'</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert( <span class="string">'Exactly!'</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>条件运算符</strong></p>
<p>这个运算符通过问号 <code>?</code> 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = condition ? value1 : value2;</span><br></pre></td></tr></table></figure>

<p>计算条件结果，如果结果为真，则返回 <code>value1</code>，否则返回 <code>value2</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> accessAllowed = (age &gt; <span class="number">18</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>技术上讲，我们可以省略 <code>age &gt; 18</code> 外面的括号。问号运算符的优先级较低，所以它会在比较运算符 <code>&gt;</code> 后执行。</p>
<p>下面这个示例会执行和前面那个示例相同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较运算符 “age &gt; 18” 首先执行</span></span><br><span class="line"><span class="comment">//（不需要将其包含在括号中）</span></span><br><span class="line"><span class="keyword">let</span> accessAllowed = age &gt; <span class="number">18</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-交互：alert、prompt-和-confirm"><a href="#1-9-交互：alert、prompt-和-confirm" class="headerlink" title="1.9 交互：alert、prompt 和 confirm"></a>1.9 交互：alert、prompt 和 confirm</h2><p><a href="https://zh.javascript.info/alert-prompt-confirm#alert" target="_blank" rel="noopener">alert</a></p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(message);</span><br></pre></td></tr></table></figure>

<p>运行这行代码，浏览器会弹出一个信息弹窗并暂停脚本，直到用户点击了“确定”。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>

<p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p>
<p><a href="https://zh.javascript.info/alert-prompt-confirm#prompt" target="_blank" rel="noopener">prompt</a></p>
<p><code>prompt</code> 函数接收两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = prompt(title, [<span class="keyword">default</span>]);</span><br></pre></td></tr></table></figure>

<p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p>
<ul>
<li><p><code>title</code></p>
<p>显示给用户的文本</p>
</li>
<li><p><code>default</code></p>
<p>可选的第二个参数，指定 input 框的初始值。</p>
</li>
</ul>
<p>用户可以在 prompt 对话框的 input 框内输入一些内容，然后点击确定。或者他们可以通过按“取消”按钮或按下键盘的 Esc 键，以取消输入。</p>
<p><code>prompt</code> 将返回用户在 <code>input</code> 框内输入的文本，如果用户取消了输入，则返回 <code>null</code>。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = prompt(<span class="string">'How old are you?'</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">`You are <span class="subst">$&#123;age&#125;</span> years old!`</span>); <span class="comment">// You are 100 years old!</span></span><br></pre></td></tr></table></figure>

<p><strong>IE 浏览器会提供默认值</strong></p>
<p>第二个参数是可选的。但是如果我们不提供的话，Internet Explorer 会把 <code>&quot;undefined&quot;</code> 插入到 prompt。</p>
<p>我们可以在 Internet Explorer 中运行下面这行代码来看看效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = prompt(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<p>所以，为了 prompt 在 IE 中有好的效果，我们建议始终提供第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = prompt(<span class="string">"Test"</span>, <span class="string">''</span>); <span class="comment">// &lt;-- for IE</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh.javascript.info/alert-prompt-confirm#confirm" target="_blank" rel="noopener">confirm</a></p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = confirm(question);</span><br></pre></td></tr></table></figure>

<p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p>
<p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoss = confirm(<span class="string">"Are you the boss?"</span>);</span><br><span class="line"></span><br><span class="line">alert( isBoss ); <span class="comment">// 如果“确定”按钮被按下，则显示 true</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>我们学习了与用户交互的 3 个浏览器的特定函数：</p>
<ul>
<li><p><code>alert</code></p>
<p>显示信息。</p>
</li>
<li><p><code>prompt</code></p>
<p>显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 Esc 键返回 <code>null</code>。</p>
</li>
<li><p><code>confirm</code></p>
<p>显示信息等待用户点击确定或取消。点击确定返回 <code>true</code>，点击取消或按下 Esc 键返回 <code>false</code>。</p>
</li>
</ul>
<p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<h2 id="1-10-数据类型"><a href="#1-10-数据类型" class="headerlink" title="1.10 数据类型"></a>1.10 数据类型</h2><p><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>
<p><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</p>
<blockquote>
<p><strong>注：</strong>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p>
</blockquote>
<p><strong>typeof 操作符</strong></p>
<p>你可以使用 <strong>typeof</strong> 操作符来查看 JavaScript 变量的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">"John"</span>                 <span class="comment">// 返回 string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span>                   <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>                    <span class="comment">// 返回 number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>                  <span class="comment">// 返回 boolean</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]              <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">name</span>:<span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;  <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()             <span class="comment">// 返回 object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;         <span class="comment">// 返回 function</span></span><br><span class="line"><span class="keyword">typeof</span> myCar                  <span class="comment">// 返回 undefined (如果 myCar 没有声明)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                   <span class="comment">// 返回 object</span></span><br></pre></td></tr></table></figure>

<p>请注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组(Array)的数据类型是 object</li>
<li>日期(Date)的数据类型为 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型为 undefined<br>（很多开发人员将undefined和undeclared混为一谈，但在JavaScript中它们是两码事。undefined是值的一种,表示变量声明过但还没有进行赋值。undeclared则表示变量还没有被声明过。）</li>
</ul>
<p>如果对象是 JavaScript Array 或 JavaScript Date ，我们就无法通过 <strong>typeof</strong> 来判断他们的类型，因为都是 返回 object。</p>
<p><strong>constructor 属性</strong></p>
<p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"John"</span>.constructor                 <span class="comment">// 返回函数 String()  &#123; [native code] &#125;</span></span><br><span class="line">(<span class="number">3.14</span>).constructor                 <span class="comment">// 返回函数 Number()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="literal">false</span>.constructor                  <span class="comment">// 返回函数 Boolean() &#123; [native code] &#125;</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].constructor              <span class="comment">// 返回函数 Array()   &#123; [native code] &#125;</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">'John'</span>, <span class="attr">age</span>:<span class="number">34</span>&#125;.constructor  <span class="comment">// 返回函数 Object()  &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor             <span class="comment">// 返回函数 Date()    &#123; [native code] &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;.constructor         <span class="comment">// 返回函数 Function()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 类型转换</strong></p>
<p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<p><strong>将数字转换为字符串</strong></p>
<p>全局方法 <strong>String()</strong> 可以将数字转换为字符串。</p>
<p>该方法可用于任何类型的数字，字母，变量，表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>)       <span class="comment">// 将数字 123 转换为字符串并返回</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">100</span> + <span class="number">23</span>)  <span class="comment">// 将数字表达式转换为字符串并返回</span></span><br></pre></td></tr></table></figure>

<p>Number 方法 <strong>toString()</strong> 也是有同样的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x.toString()</span><br><span class="line">(<span class="number">123</span>).toString()</span><br><span class="line">(<span class="number">100</span> + <span class="number">23</span>).toString()</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://www.runoob.com/jsref/jsref-obj-number.html" target="_blank" rel="noopener">Number 方法</a> 章节中，你可以找到更多数字转换为字符串的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">toExponential()</td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left">toFixed()</td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。(只包含小数位)</td>
</tr>
<tr>
<td align="left">toPrecision()</td>
<td align="left">把数字格式化为指定的长度。(包含整数位)</td>
</tr>
</tbody></table>
<p><strong>将布尔值转换为字符串</strong></p>
<p>全局方法 <strong>String()</strong> 可以将布尔值转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>)     <span class="comment">// 返回 "false"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>)     <span class="comment">// 返回 "true"</span></span><br></pre></td></tr></table></figure>

<p>Boolean 方法 <strong>toString()</strong> 也有相同的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span>.toString()     <span class="comment">// 返回 "false"</span></span><br><span class="line"><span class="literal">true</span>.toString()      <span class="comment">// 返回 "true"</span></span><br></pre></td></tr></table></figure>

<p><strong>将日期转换为字符串</strong></p>
<p>Date() 返回字符串。</p>
<p>Date()   // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</p>
<p>全局方法 String() 可以将日期对象转换为字符串。</p>
<p>String(new Date())   // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</p>
<p>Date 方法 <strong>toString()</strong> 也有相同的效果。</p>
<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">obj.toString()  <span class="comment">// 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>getDate()</th>
<th>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</th>
</tr>
</thead>
<tbody><tr>
<td>getDay()</td>
<td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td>getMonth()</td>
<td>从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<p><strong>将字符串转换为数字</strong></p>
<p>全局方法 <strong>Number()</strong> 可以将字符串转换为数字。</p>
<p>字符串包含数字(如 “3.14”) 转换为数字 (如 3.14).</p>
<p>空字符串转换为 0。</p>
<p>其他的字符串会转换为 NaN (不是个数字)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"3.14"</span>)  <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">" "</span>)    <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">""</span>)    <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">"99 88"</span>)  <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>parseFloat()</th>
<th>解析一个字符串，并返回一个浮点数。</th>
</tr>
</thead>
<tbody><tr>
<td>parseInt()</td>
<td>解析一个字符串，并返回一个整数。</td>
</tr>
</tbody></table>
<p><strong>一元运算符 +</strong></p>
<p><strong>Operator +</strong> 可用于将变量转换为数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"5"</span>;      <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;      <span class="comment">// x 是一个数字</span></span><br></pre></td></tr></table></figure>

<p>如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="string">"John"</span>;   <span class="comment">// y 是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> x = + y;      <span class="comment">// x 是一个数字 (NaN)</span></span><br></pre></td></tr></table></figure>

<p><strong>将布尔值转换为数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>)     <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>)      <span class="comment">// 返回 1</span></span><br></pre></td></tr></table></figure>

<p><strong>将日期转换为数字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">全局方法 <span class="built_in">Number</span>() 可将日期转换为数字。</span><br><span class="line"></span><br><span class="line">d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">Number</span>(d)          <span class="comment">// 返回 1404568027739</span></span><br><span class="line">日期方法 getTime() 也有相同的效果。</span><br><span class="line"></span><br><span class="line">d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime()        <span class="comment">// 返回 1404568027739</span></span><br></pre></td></tr></table></figure>

<p><strong>自动转换类型</strong></p>
<p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="literal">null</span>    <span class="comment">// 返回 5         null 转换为 0</span></span><br><span class="line"><span class="string">"5"</span> + <span class="literal">null</span>  <span class="comment">// 返回"5null"   null 转换为 "null"</span></span><br><span class="line"><span class="string">"5"</span> + <span class="number">1</span>     <span class="comment">// 返回 "51"      1 转换为 "1" </span></span><br><span class="line"><span class="string">"5"</span> - <span class="number">1</span>     <span class="comment">// 返回 4         "5" 转换为 5</span></span><br></pre></td></tr></table></figure>

<p><strong>自动转换为字符串</strong></p>
<p>当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myVar;</span><br><span class="line"></span><br><span class="line">myVar = &#123;<span class="attr">name</span>:<span class="string">"Fjohn"</span>&#125;  <span class="comment">// toString 转换为 "[object Object]"</span></span><br><span class="line">myVar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]       <span class="comment">// toString 转换为 "1,2,3,4"</span></span><br><span class="line">myVar = <span class="keyword">new</span> <span class="built_in">Date</span>()      <span class="comment">// toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200"</span></span><br></pre></td></tr></table></figure>

<p>数字和布尔值也经常相互转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myVar = <span class="number">123</span>             <span class="comment">// toString 转换为 "123"</span></span><br><span class="line">myVar = <span class="literal">true</span>            <span class="comment">// toString 转换为 "true"</span></span><br><span class="line">myVar = <span class="literal">false</span>           <span class="comment">// toString 转换为 "false"</span></span><br></pre></td></tr></table></figure>

<p>下表展示了使用不同的数值转换为数字(Number), 字符串(String), 布尔值(Boolean):</p>
<table>
<thead>
<tr>
<th align="left">原始值</th>
<th align="left">转换为数字</th>
<th align="left">转换为字符串</th>
<th align="left">转换为布尔值</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">false</td>
<td align="left">0</td>
<td align="left">“false”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_false" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">true</td>
<td align="left">1</td>
<td align="left">“true”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_true" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">“0”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_number_0" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">“1”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_number_1" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“0”</td>
<td align="left">0</td>
<td align="left">“0”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_0" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“000”</td>
<td align="left">0</td>
<td align="left">“000”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_000" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“1”</td>
<td align="left">1</td>
<td align="left">“1”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_1" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">NaN</td>
<td align="left">NaN</td>
<td align="left">“NaN”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_nan" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">Infinity</td>
<td align="left">Infinity</td>
<td align="left">“Infinity”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_infinity" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">-Infinity</td>
<td align="left">-Infinity</td>
<td align="left">“-Infinity”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_infinity_minus" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“”</td>
<td align="left">0</td>
<td align="left">“”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_empty" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“20”</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_number" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">“Runoob”</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_string_text" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[ ]</td>
<td align="left">0</td>
<td align="left">“”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_empty" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[20]</td>
<td align="left">20</td>
<td align="left">“20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_one_number" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[10,20]</td>
<td align="left">NaN</td>
<td align="left">“10,20”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_two_numbers" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[“Runoob”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_one_string" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">[“Runoob”,”Google”]</td>
<td align="left">NaN</td>
<td align="left">“Runoob,Google”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_array_two_strings" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">function(){}</td>
<td align="left">NaN</td>
<td align="left">“function(){}”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_function" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">{ }</td>
<td align="left">NaN</td>
<td align="left">“[object Object]”</td>
<td align="left">true</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_object" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">0</td>
<td align="left">“null”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_null" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">NaN</td>
<td align="left">“undefined”</td>
<td align="left">false</td>
<td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjs_type_convert_undefined" target="_blank" rel="noopener">尝试一下 »</a></td>
</tr>
</tbody></table>
<h3 id="2-0-1-值"><a href="#2-0-1-值" class="headerlink" title="2.0.1 值"></a>2.0.1 值</h3><ul>
<li><p>数组</p>
<ul>
<li>和其他强类型语言不同，在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组就是通过这种方式来实现的）</li>
<li>对数组声明后即可向其中加入值，不需要预先设定大小</li>
<li>使用delete运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化</li>
<li>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）</li>
<li>类数组<br>有时需要将类数组（一组通过数字索引的值）转换为真正的数组例如，一些DOM查询操作会返回DOM元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）。工具函数slice(..)经常被用于这类转换：<br><code>Array.prototype.slice.call( arguments )</code></li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符串不可变: 指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
</li>
<li><p>许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串，如<code>Array.prototype.join.call(a, &quot;-&quot;)</code> <code>Array.prototype.map.call(a, (v) =&gt; {})</code>;<br>`Array.prototype<br><strong>数组逆序</strong>（借用Array.prototype.reverse(),但是这个函数只能作用于可变对象，字符串为不可变对象，因此进行变通使用）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">var</span> c = a.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数字</p>
<ul>
<li><p>JavaScript只有一种数值类型：number（数字），包括“整数”和带小数的十进制数</p>
</li>
<li><p>由于数字值可以使用Number对象进行封装（参见第3章），因此数字值可以调用Number.prototype中的方法, <code>toFixed</code>, <code>toPrecision()</code>,等`</p>
</li>
<li><p>还可以使用指数形式<code>1E3</code>, 二进制，八进制和十六进制(0x)来表示</p>
</li>
<li><p>较小的数值： 二进制浮点数最大的问题（不仅JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现如下情况：<code>0.1 + 0.2 === 0.3</code> 为false</p>
<p>二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004，所以条件判断结果为false。</p>
<p>那么应该怎样来判断0.1 + 0.2和0.3是否相等呢？最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript的数字来说，这个值通常是2^-52 (2.220446049250313e-16)。</p>
<p>从ES6开始，该值定义在<code>Number.EPSILON</code>，可以基于这个误差值来解决上述问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">n1, n2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs( n1 - n2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(equal(<span class="number">0.1</span>+<span class="number">0.2</span>, <span class="number">0.3</span>));</span><br></pre></td></tr></table></figure>

<p><strong>整数的安全范围</strong></p>
<p>能够呈现的最大浮点数大约是1.798e+308（这是一个相当大的数字），它定义在Number. MAXVALUE中。最小浮点数定义在Number.MIN VALUE中，大约是5e-324，它不是负数，但无限接近于0！</p>
<p>数字的呈现方式决定了“整数”的安全值范围远远小于Number.MAX VALUE。</p>
<p>能够被“安全”呈现的最大整数是2^53-1，即9007199254740991，在ES6中被定义为Number.MAX SAFE INTEGER。最小整数是-9007199254740991，在ES6中被定义为Number.MIN SAFE INTEGER。<br><strong>整数检测</strong></p>
<p>ES6: <code>Number.isInteger()</code><br>Polyfill</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> num === <span class="string">"number"</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>安全整数检测</strong><br>ES6: <code>Number.isSafeInteger()</code></p>
<p>Polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp; <span class="built_in">Math</span>.abs(num) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>特殊的值</p>
<ul>
<li><p><strong>undefined和null</strong> : undefined类型只有一个值，即undefined。null类型也只有一个值，即null。它们的名称既是类型也是值。undefined和null常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。</p>
<p>例如：<br>• null指空值（empty value）• undefined指没有值（missing value）或者：• undefined指从未赋值• null指曾赋过值，但是目前没有值null是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而undefined却是一个标识符，可以被当作变量来使用和赋值。</p>
</li>
<li><p>void运算符: void并不改变表达式的结果，只是让表达式不返回值<br><code>return void setTImeout(doSomething, 100)</code></p>
</li>
<li><p>特殊的数字：<br><strong>NaN</strong>是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。ES6开始我们可以使用工具函数<code>Number.isNaN(..)</code>, ES6之前使用<code>window.isNaN</code></p>
<p><strong>Infinity和-Infinity</strong>:   如果数学运算（如加法）的结果超出处理范围，则由IEEE 754规范中的“就近取整”（round-to-nearest）模式来决定最后的结果。例如，相对于Infinity, Number.MAX VALUE +Math.pow(2, 969)与Number.MAX VALUE更为接近，因此它被“向下取整”（round down）；而Number.MAX VALUE + Math.pow(2, 970)与Infinity更为接近，所以它被“向上取整”（roundup）。</p>
<p><strong>+0和-0</strong>:   我们可以使用以下代码来区分+0和-0: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNegZero</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  n = <span class="built_in">Number</span>( n );</span><br><span class="line">  <span class="keyword">return</span> ( n === <span class="number">0</span> ) &amp;&amp; ( <span class="number">1</span> / n === -<span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>特殊等式</strong><br>如前所述，NaN和-0在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..)（或者polyfill）。而-0等于0（对于===也是如此，参见第4章），因此我们必须使用isNegZero(..)这样的工具函数。ES6中新加入了一个工具方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有的特殊情况：<br>对于ES6之前的版本，Object.is(..)有一个简单的polyfill：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为-0</span></span><br><span class="line">    <span class="keyword">if</span>(v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/v1 === <span class="number">1</span>/v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是NaN</span></span><br><span class="line">    <span class="keyword">if</span>(v1 !== v1)&#123;</span><br><span class="line">        <span class="keyword">return</span> v2 !== v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="keyword">return</span> v1 === v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-0-2-原生函数"><a href="#2-0-2-原生函数" class="headerlink" title="2.0.2 原生函数"></a>2.0.2 原生函数</h3><p>常用的原生函数有：</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()——ES6中新加入的！实际上，它们就是内建函数。</li>
</ul>
<p><strong>内部属性[[Class]]</strong></p>
<p>所有typeof返回值为”object”的对象（如数组）都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/regexp-literal/i</span>));</span><br><span class="line"><span class="comment">// 基本类型值被各自的封装对象自动包装，所以它们的内部[[Class]]属性值分别为"String"、"Number"和"Boolean"。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"abc"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">42</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p><strong>封装对象包装</strong></p>
<p>封装对象（object wrapper）扮演着十分重要的角色。由于基本类型值没有．length和．toString()这样的属性和方法，需要通过封装对象才能访问，此时JavaScript会自动为基本类型值包装（box或者wrap）一个封装对象：</p>
<p>如果需要经常用到这些字符串属性和方法，比如在for循环中使用i &lt; a.length，那么从一开始就创建一个封装对象也许更为方便，这样JavaScript引擎就不用每次都自动创建了。但实际证明这并不是一个好办法，因为浏览器已经为．length这样的常见情况做了性能优化，直接使用封装对象来“提前优化”代码反而会降低执行效率。</p>
<p>一般情况下，我们不需要直接使用封装对象。最好的办法是让JavaScript引擎自己决定什么时候应该使用封装对象。换句话说，就是应该优先考虑使用”abc”和42这样的基本类型值，而非newString(“abc”)和new Number(42)。<br><strong>拆封</strong><br>如果想要得到封装对象中的基本类型值，可以使用valueOf()函数：<code>var a = new String(&quot;abc&quot;); console.log(a.valueOf());</code></p>
<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封(强制类型转换)<code>var a = new String(&quot;abc&quot;); var b = a + &quot;&quot;;</code></p>
<h3 id="2-0-3-强制类型转换"><a href="#2-0-3-强制类型转换" class="headerlink" title="2.0.3 强制类型转换"></a>2.0.3 <strong>强制类型转换</strong></h3><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。</p>
<p>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）</p>
<p>在介绍显示和隐式类型转换之前我们需要先掌握<strong>字符串</strong>，<strong>数字</strong>和<strong>布尔值</strong>之间类型转换的<strong>基本规则</strong>。</p>
<ul>
<li><p><strong>toString()</strong><br>它负责<strong>非字符串到字符串的强制类型转换</strong></p>
<ul>
<li><strong>基本类型值的字符串化规则</strong>为: null转换为”null”, undefined转换为”undefined”， true转换为”true”, 数字类型转化为带引号的字符串，数字的极大值，极小值转换为指数形式 </li>
<li><strong>普通对象</strong>，返回内部属性[[Class]](如”[object Object]”),如果对象有自己的toString()方法，就会使用该方法的返回值。</li>
<li><strong>数组的toString()</strong>就经过了重新定义，将所有单元字符串化以后再用<strong>“,”</strong>连接起来</li>
</ul>
<p><strong>JSON字符串化</strong><br>JSON.stringify()并非严格意义上的强制类型转换，因为其中也涉及toString()的相关规则，这里顺带介绍一下，<strong>对大多数简单值来说, JSON字符串化和toString()效果基本相同</strong>，只不过序列化的结果总是字符串，所有安全的JSON值(<strong>JSON-safe</strong>)都可以使用JSON.stringify()字符串化，安全的JSON值是指能够呈现为有效JSON格式的值。undefined, function, symbol和包含循环引用的对象都不符合JSON结构标准。<strong>JSON.stringify()在对象中遇到undefined，function和symbol时会自动将其忽略，在数组中返回null(以保证数组元素位置不变)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<p>对包含循环引用的对象执行JSON.stringify()会报错，如果对象定义了<strong>toJSON()</strong>方法，JSON字符串化会首先调用该方法，然后用它的返回值来进行序列化。<br>如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义toJSON()方法来返回一个安全的JSON</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环引用对象的字符串化会报错</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    b: <span class="number">42</span>,</span><br><span class="line">    c: o,</span><br><span class="line">    d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在a中创建一个循环引用</span></span><br><span class="line">o.e = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(a);  <span class="comment">// TypeError: Converting circular structure to JSON</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toJSON返回的应该是一个适当的值，可以是任何类型，然后再由JSON.stringify()对其进行格式化,</span></span><br><span class="line"><span class="comment">// 也就是toJSON()应该返回一个能够被字符串化的安全的JSON值，而不是返回一个JSON字符串</span></span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="keyword">this</span>.b &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(a));  <span class="comment">// &#123;"b": 42&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以向JSON.stringify()传递一个参数<strong>replacer</strong>，它可以是数组或者函数，用来指定序列化过程中<strong>哪些属性应该被处理，哪些应该被排除</strong><br><strong>如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他属性将被忽略</strong><br>如果replacer是一个<strong>函数</strong>，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值，如果要忽略某个键就返回undefined，否则返回指定的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用replacer参数排除属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    job: <span class="string">"frontender"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, [<span class="string">"name"</span>, <span class="string">"age"</span>])); <span class="comment">// &#123;"name":"david","age":27&#125;, jon属性被排除了</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, (k, v) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用"</span>); <span class="comment">// 调用4次</span></span><br><span class="line">    <span class="keyword">if</span>(k !== <span class="string">"job"</span>)&#123; <span class="keyword">return</span> v &#125;  <span class="comment">// 排除job属性</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>JSON.stringify()还有一个参数<strong>space</strong>，用来指定输出的缩进格式，space为正整数时是指定每一级缩进的字符数,它可以为一个字符串，此时最前面的10个字符用于每一级的缩进</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用space参数指定缩进</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">"***"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>toNumber</strong><br><strong>true转换为1</strong>， <strong>false转换为0</strong>, <strong>undefined转换为NaN</strong>, <strong>null转换为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>));  <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>));  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>为了将值转换为相应的基本类型值，抽象操作toPrimitive会<strong>首先该值是否有valueOf()方法</strong>，如果有并且返回基本类型的值，就是用该值进行强制类型转换，如果<strong>没有就使用toString()的返回值</strong>(如果存在)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">c.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">""</span>); <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(a)); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(b)); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(c)); <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">""</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([]));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="number">0</span>])); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>([<span class="string">"abc"</span>]));  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">* **toBoolean**</span><br><span class="line">首先，也是最重要的一点是，JavaScript中有两个关键词true和false，分别代表布尔类型中的真和假。我们常误以为数值1和0分别等同于true和false。在有些语言中可能是这样，但在JavaScript中布尔值和数字是不一样的。虽然我们可以将1强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。</span><br><span class="line">  </span><br><span class="line">  **假值**</span><br><span class="line">  JavaScript中的值可以分为以下两类：</span><br><span class="line">  (1) **可以被强制类型转换为false的值**</span><br><span class="line">  (2) 其他（被强制类型转换为true的值）</span><br><span class="line">  以下这些是假值：**undefined**， **null**， **false**， **+0**、**-0**和**NaN**， &quot;&quot;假值的布尔强制类型转换结果为false。</span><br><span class="line">**真值**</span><br><span class="line">  </span><br><span class="line">假值列表之外的值都是真值</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;javascript</span><br><span class="line">  var a &#x3D; &quot;false&quot;;</span><br><span class="line">  var b &#x3D; &quot;0&quot;;</span><br><span class="line">  var c &#x3D; &quot;&#39;&#39;&quot;;</span><br><span class="line">  &#x2F;&#x2F; 因为a,b,c都不是空字符串，因此转换成Boolean,都为真值</span><br><span class="line">  console.log(Boolean(a));  &#x2F;&#x2F; true</span><br><span class="line">  console.log(Boolean(b));  &#x2F;&#x2F; true</span><br><span class="line">  console.log(Boolean(c));  &#x2F;&#x2F; true</span><br><span class="line">  var d &#x3D; Boolean(a &amp;&amp; b &amp;&amp; c);</span><br><span class="line">  console.log(d);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>显示强制类型转换</strong><br><strong>字符串和数字之间的转换</strong>: 使用<strong>String</strong>()和<strong>Number</strong>()(没有new关键字), 转换规则分别遵守前面toString()和toNumber()规则<br>除了String(..)和Number(..)以外，还有其他方法可以实现字符串和数字之间的显式转换：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"3.14"</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<p>a.toString()是显式的（“toString”意为“to a string”），不过其中涉及隐式转换。因为toString()对42这样的基本类型值不适用，所以JavaScript引擎会<strong>自动为42创建一个封装对象</strong>，然后对该对象调用toString()。这里显式转换中含有隐式转换。</p>
<p>上例中<strong>+c是+运算符的一元（unary）形式（即只有一个操作数）。+运算符显式地将c转换为数字</strong>，而非数字加法运算（也不是字符串拼接）。<br>   <strong>日期显示转换为时间戳</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示将日期转换为时间戳</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(+d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript有一处奇特的语法，即构造函数没有参数时可以不用带()</span></span><br><span class="line"><span class="keyword">var</span> timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line"><span class="built_in">console</span>.log(timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用getTime显示获取可能更好些</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最好还是使用ES5中新增的Date.now()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br><span class="line"><span class="comment">// 为老版本提供polyfill</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Date</span>.now)&#123;</span><br><span class="line">    <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们不建议对日期类型使用强制类型转换，应该使用Date.now()来获得当前的时间戳，使用newDate(..).getTime()来获得指定时间的时间戳。</span></span><br></pre></td></tr></table></figure>

<p>   <strong>奇特的~运算符</strong></p>
<p>   ~运算符（即字位操作“非”）,它<strong>与某些特殊数字在一起使用时会产生类型强制类型转换的效果</strong>，返回另外一个数字, 它首先将值强制类型转换为32位数字，然后执行字位非（对每一个数字进行反转）</p>
<p>   还可以有另外一种诠释，源自早期的计算机科学和离散数学：<del>返回2的补码。这样一来问题就清楚多了！</del>x大致等同于-(x+1)。很奇怪，但相对更容易说明问题：</p>
<p>   <code>~42; // -(42 + 1) ==&gt; -43</code><br> 在-(x+1)中唯一能够得到0（或者严格说是-0）的x值是-1。也就是说如果x为-1时，~和一些数字值在一起会返回假值0，其他情况则返回真值。</p>
<p> -1是一个“<strong>哨位值</strong>”，哨位值是那些在各个类型中（这里是数字）被赋予了特殊含义的值。在C语言中我们用-1来代表函数执行失败，用大于等于0的值来代表函数执行成功。JavaScript中字符串的<strong>indexOf</strong>(..)方法也遵循这一惯例，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从0开始），否则返回-1。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello World"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(a.indexOf(<span class="string">"lo"</span>) &gt;= <span class="number">0</span> )&#123;  <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(a.indexOf(<span class="string">"lo"</span>) != <span class="number">-1</span> )&#123; <span class="comment">// true</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">if</span>(a.indexOf(<span class="string">"ol"</span>) &lt; <span class="number">0</span>)&#123;   <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"没有找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(a.indexOf(<span class="string">"ol"</span>) == <span class="number">-1</span>)&#123;  <span class="comment">// true</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"没有找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// &gt;= 0和== -1这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，</span></span><br><span class="line">   <span class="comment">// 这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ~和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：</span></span><br><span class="line">   <span class="built_in">console</span>.log(~a.indexOf(<span class="string">"lo"</span>)); <span class="comment">// -4 真值</span></span><br><span class="line">   <span class="keyword">if</span>(~a.indexOf(<span class="string">"lo"</span>))&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(!~a.indexOf(<span class="string">"ol"</span>)); <span class="comment">// true</span></span><br><span class="line">   <span class="keyword">if</span>(!~a.indexOf(<span class="string">"ol"</span>))&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"未找到匹配"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ~比&gt;= 0和== -1更简洁</span></span><br></pre></td></tr></table></figure>

<p>   <strong>字位截除</strong></p>
<p>   我们可以使用<code>~~1E20</code>或者<code>1E20 | 0</code> 两种方式来截取到Int32</p>
<p>   <strong>显示解析数字字符串</strong></p>
<p>   <strong>解析非字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">0.000008</span>)); <span class="comment">// "0"来自"0.000008"",  .不是数字，解析停止</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">0.0000008</span>));  <span class="comment">// 8  "8"来自8e-7</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="literal">false</span>, <span class="number">16</span>); <span class="comment">//250 "fa"来自于"false""</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>, <span class="number">16</span>); <span class="comment">//  15 "f"来自于"function""</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0x10"</span>)); <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"103"</span>, <span class="string">"2"</span>)); <span class="comment">// 2 3对于2进制转化超出有限值舍去</span></span><br></pre></td></tr></table></figure>

<p>   <strong>显示转换为布尔值</strong></p>
<p>与前面的String(..)和Number(..)一样，Boolean(..)（不带new）是显式的<strong>ToBoolean</strong>强制类型转换</p>
<p>一元运算符！显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值（或者将假值反转为真值）。所以<strong>显式强制类型转换为布尔值最常用的方法是！!</strong>，因为第二个！会将结果反转回原值</p>
</li>
<li><p><strong>隐式强制类型转换</strong><br><strong>字符串和数字之间的隐式强制类型转换</strong><br>通过重载，<strong>+运算符即能用于数字加法，也能用于字符串拼接</strong>。JavaScript怎样来判断我们要执行的是哪个操作？例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"42"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + b);</span><br><span class="line"><span class="built_in">console</span>.log(c + d);</span><br><span class="line"><span class="keyword">var</span> e = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> f = [<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">//因为数组的valueOf()操作无法得到简单基本类型值，</span></span><br><span class="line"><span class="comment">// 于是它转而调用toString()。因此上例中的两个数组变成了"1,2"和"3,4"。+将它们拼接后返回"1,23,4"。</span></span><br><span class="line"><span class="built_in">console</span>.log(e+f);  <span class="comment">// 1,23,4</span></span><br><span class="line"><span class="comment">// 简单来说就是，如果+的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -是数字减法运算符，因此a -0会将a强制类型转换为数字。也可以使用a ＊ 1和a /1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。</span></span><br><span class="line"><span class="keyword">var</span> g = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> h = [<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(g-h);</span><br><span class="line"><span class="comment">// 为了执行减法运算，a和b都需要被转换为数字，它们首先被转换为字符串（通过toString()），然后再转换为数字。</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔值到数字的隐式强制类型转换</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyOne</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 跳过假值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>[i])&#123;</span><br><span class="line">            sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(onlyOne(b, a));</span><br></pre></td></tr></table></figure>

<p>通过sum += arguments[i]中的隐式强制类型转换，将真值（true/truthy）转换为1并进行累加。如果有且仅有一个参数为true，则结果为1；否则不等于1, sum == 1条件不成立。同样的功能也可以通过显式强制类型转换来实现<br><strong>隐式强制类型转换为布尔值</strong></p>
<p>下面的情况会发生布尔值隐式强制类型转换。</p>
<p>(1)  if (..)语句中的条件判断表达式。</p>
<p>(2) for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）。</p>
<p>(3) while (..)和do..while(..)循环中的条件判断表达式。</p>
<p>(4) ? ：中的条件判断表达式。</p>
<p>(5) 逻辑运算符||（逻辑或）和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>
<p><strong>||和&amp;&amp;</strong></p>
<p>称它们为“<strong>选择器运算符</strong>”（selector operators）或者“<strong>操作数选择器运算符</strong>”（operand selector operators）更恰当些。在JavaScript中它们返回的并不是布尔值。它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a || b); <span class="comment">// 42 </span></span><br><span class="line"><span class="built_in">console</span>.log(a &amp;&amp; b); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(c || b); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(c &amp;&amp; b); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换个角度来理解</span></span><br><span class="line"><span class="built_in">console</span>.log(a || b);</span><br><span class="line"><span class="built_in">console</span>.log(a?a:b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a&amp;&amp;b);</span><br><span class="line"><span class="built_in">console</span>.log(a?b:a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短路</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line">a &amp;&amp; foo();</span><br></pre></td></tr></table></figure>

<p>||和&amp;&amp;首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就<strong>先进行ToBoolean强制类型转换，然后再执行条件判断</strong>。</p>
<p>对于||来说，如果条件判断结果为true就返回第一个操作数（a和c）的值，如果为false就返回第二个操作数（b）的值。</p>
<p>&amp;&amp;则相反，如果条件判断结果为true就返回第二个操作数（b）的值，如果为false就返回第一个操作数（a和c）的值。</p>
<p>||和&amp;&amp;返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。c&amp;&amp; b中c为null，是一个假值，因此&amp;&amp;表达式的结果是null（即c的值），而非条件判断的结果false。<br><strong>符号的强制类型转换</strong></p>
<p>ES6中引入了符号类型，它的强制类型转换有一个坑，在这里有必要提一下。ES6允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"cool"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(s1));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"not cool"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2 + <span class="string">""</span>);  <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>

<p>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）</p>
</li>
<li><p><strong>宽松相等和严格相等</strong><br><strong>“==允许在相等比较中进行强制类型转换，而===不允许。”</strong><br><strong>相等比较操作的性能</strong><br>有人觉得==会比===慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。<br>如果进行比较的两个<strong>值类型相同，则==和===使用相同的算法</strong>，所以除了JavaScript引擎实现上的细微差别之外，它们之间并没有什么不同。<br><strong>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用==，没有就用===，不用在乎性能。</strong><br><strong>==和===都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同， ==会进行强制类型转换，而===不会。</strong><br>宽松不相等（loose not-equality）! =就是==的相反值，! ==同理<br><strong>1．字符串和数字之间的相等比较</strong>（将字符串转化为数字进行比较）<br>(1) 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。<br>(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。<br><strong>2．其他类型和布尔类型之间的相等比较</strong>（布尔值转化为数字进行比较）<br>(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果；<br>(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。<br><strong>3. null和undefined之间的相等比较</strong><br><strong>在==中null和undefined相等（它们也与其自身相等）</strong>，除此之外其他值都不存在这种情况。<br><strong>4．对象和非对象之间的相等比较</strong>（将对象转化为基本数据类型进行比较）<br>(1) 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果；<br>(2) 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x) == y的结果。<br><strong>5．安全运用隐式强制类型转换</strong><br>• 如果<strong>两边的值中有true或者false，千万不要使用==</strong>。<br>• 如果两边的值中有[]、””或者0，尽量不要使用==。完整比较图：</p>
<ul>
<li><p>红色：===</p>
</li>
<li><p>橙色：==</p>
</li>
<li><p>黄色：&lt;= 和 &gt;= 同时成立，== 不成立</p>
</li>
<li><p>蓝色：只有 &gt;=</p>
</li>
<li><p>绿色：只有 &lt;=</p>
<p><img src="https://img-blog.csdn.net/20180224085748686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2tpdGVfeWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>抽象关系比较</strong><br>a &lt; b中涉及的隐式强制类型转换不太引人注意，不过还是很有必要深入了解一下。“抽象关系比较”（abstract relational comparison），分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。<strong>该算法仅针对a &lt; b, a=””&gt; b会被处理为b &lt; a</strong>比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">42</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">"43"</span>];</span><br><span class="line">a &lt; b <span class="comment">// true</span></span><br><span class="line">b &lt; a <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果<strong>比较双方都是字符串，则按字母顺序来进行比较</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"42"</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">"043"</span>];</span><br><span class="line">a &lt; b</span><br></pre></td></tr></table></figure>

<p>a和b并没有被转换为数字，因为ToPrimitive返回的是字符串，所以这里比较的是”42”和”043”两个字符串，它们分别以”4”和”0”开头。因为”0”在字母顺序上小于”4”，所以最后结果为false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b</span><br><span class="line">结果还是<span class="literal">false</span>，因为a是[object <span class="built_in">Object</span>], b也是[object <span class="built_in">Object</span>](<span class="built_in">Object</span>.prototype.toString()获得[[Class]]属性值)，所以按照字母顺序a &lt; b并不成立。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="1-11-循环"><a href="#1-11-循环" class="headerlink" title="1.11 循环"></a>1.11 循环</h2><p>我们经常需要重复执行一些操作。</p>
<p>例如，我们需要将列表中的商品逐个输出，或者运行相同的代码将数字 1 到 10 逐个输出。</p>
<p><strong>循环</strong> 是一种重复运行同一代码的方法。</p>
<ul>
<li>for</li>
<li>forEach</li>
<li>do…while</li>
<li>while</li>
<li>for…in</li>
<li>for…of</li>
<li>for…in vs for…of</li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>您可以使用break中断for循环</li>
<li>您可以使用continue继续for循环的下一次迭代</li>
</ul>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>在ES5中引入。给定一个数组，您可以使用list.forEach（）迭代其属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">list.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//index is optional</span></span><br><span class="line">list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过需要注意的是你无法摆脱这个循环。</p>
</blockquote>
<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; list.length)</span><br></pre></td></tr></table></figure>

<p>您可以使用break中断while循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>你可以使用continue跳转到下一个迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; list.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]) <span class="comment">//value</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//index</span></span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用break中断while循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用continue跳转到下一个迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与do…while的区别在于do…while总是至少执行一次循环。</p>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p>迭代对象的所有可枚举属性，给出属性名称。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(property) <span class="comment">//property name</span></span><br><span class="line">  <span class="built_in">console</span>.log(object[property]) <span class="comment">//property value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>ES2015引入了for循环，它结合了forEach的简洁性和破解能力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterate over the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the index as well, using `entries()`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用const。此循环在每次迭代中创建一个新范围，因此我们可以安全地使用它而不是let。</p>
<h3 id="for…in-VS-FOR…OF"><a href="#for…in-VS-FOR…OF" class="headerlink" title="for…in VS FOR…OF"></a>for…in VS FOR…OF</h3><p>与for…in的区别在于：</p>
<ul>
<li>for…of 迭代属性值</li>
<li>for…in 迭代属性名称</li>
</ul>
<h1 id="二-深入学习"><a href="#二-深入学习" class="headerlink" title="二. 深入学习"></a>二. 深入学习</h1><h2 id="2-1-作用域和闭包"><a href="#2-1-作用域和闭包" class="headerlink" title="2.1 作用域和闭包"></a>2.1 作用域和闭包</h2><h4 id="2-1-2-编译原理"><a href="#2-1-2-编译原理" class="headerlink" title="2.1.2 编译原理"></a>2.1.2 编译原理</h4><p>传统的编译语言中，程序中的一段源代码在执行之前会经历三个步骤，被称为”编译“</p>
<ol>
<li><strong>分词/词法分析（Tokenizing/Lexing）</strong><br>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</li>
<li><strong>解析/语法分析（Parsing）</strong><br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST）。var a = 2；的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。</li>
<li><strong>代码生成</strong><br><strong>将AST转换为可执行代码的过程被称为代码生成</strong>。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将var a = 2；的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等），并将一个值储存在a中。</li>
</ol>
<p>JavaScript引擎要复杂得多，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</p>
<h4 id="2-1-3-理解作用域"><a href="#2-1-3-理解作用域" class="headerlink" title="2.1.3 理解作用域"></a>2.1.3 理解作用域</h4><p><strong>重要概念</strong></p>
<ul>
<li>引擎从头到尾负责整个JavaScript程序的编译及执行过程。</li>
<li>编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活。</li>
<li>作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对<strong>这些标识符的访问权限</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>针对上述的代码语句，编译器将执行下述处理逻辑</p>
<ol>
<li>遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就会举手示意并抛出一个异常！总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</li>
</ol>
<p><strong>引擎和作用域的对话</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。<br>引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？</p>
<ol>
<li><p>作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。</p>
</li>
<li><p>引擎：哥们太够意思了！好吧，我来执行一下foo。</p>
</li>
<li><p>引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？</p>
</li>
<li><p>作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。</p>
</li>
<li><p>引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。</p>
</li>
<li><p>引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？</p>
</li>
<li><p>作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有，console是个内置对象。给你。</p>
</li>
<li><p>引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。</p>
</li>
<li><p>引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。</p>
</li>
<li><p>作用域：放心吧，这个变量没有变动过，拿走，不谢。</p>
</li>
<li><p>引擎：真棒。我来把a的值，也就是2，传递进log(..)。</p>
</li>
</ol>
<p><strong>LHS和RHS</strong></p>
<p><code>LHS</code> 和 <code>RHS</code>是对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。<br> LHS(<code>Left-hand Side</code>)引用和RHS(<code>Right-hand Side</code>)引用。通常是指等号（赋值运算）的左右边的引用。</p>
<p><strong>RHS的目的是取得源值</strong></p>
<p><strong>LHS是取得源引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>LHS找到c</li>
<li>RHS寻找foo(2)的值</li>
<li>把2赋值给a时，LHS找到a</li>
<li>var b = a时候, LHS找到b, RHS找到a</li>
<li>return a + b时候，RHS找到a和b</li>
</ol>
<p>所以一共3次LHS，3次RHS</p>
<h4 id="2-1-4作用域嵌套"><a href="#2-1-4作用域嵌套" class="headerlink" title="2.1.4作用域嵌套"></a>2.1.4作用域嵌套</h4><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。</p>
<p>因此，回顾一下引擎和作用域之间的对话，会进一步听到：</p>
<ol>
<li>引擎：foo的作用域兄弟，你见过b吗？我需要对它进行RHS引用。</li>
<li>作用域：听都没听过，走开。</li>
<li>引擎：foo的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过b吗？我需要对它进行RHS引用。</li>
<li>作用域：当然了，给你吧。遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</li>
</ol>
<p><img src="/img/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9F%A5%E6%89%BE.jpg" alt="作用域查找.jpg"></p>
<p>这个建筑代表程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。LHS和RHS引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。</p>
<p><strong>为什么区分LHS和RHS</strong></p>
<p>因为在变量没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>第一次对b进行RHS查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得注意的是，ReferenceError是非常重要的异常类型。相较之下，当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。“不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”</p>
<p>ES5中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<p><strong>总结</strong></p>
<p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。</p>
<p>如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p>
<p>JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2这样的声明会被分解成两个独立的步骤：</p>
<ol>
<li>首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>
<li>接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。</li>
</ol>
<h4 id="2-1-5-词法作用域"><a href="#2-1-5-词法作用域" class="headerlink" title="2.1.5 词法作用域"></a>2.1.5 词法作用域</h4><p>词法作用域就是定义在词法分析阶段的作用域</p>
<p>作用域查找会在找到第一个匹配的标识符时停止， 在多层的嵌套作用域中可以定义同名的标识符，这叫做”遮蔽效应“（内部的标识符遮蔽了外部的标识符）。</p>
<p>无论函数在哪里调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p>
<p>词法作用域只会查找一级标识符，比如a,   b,  c，类似于foo.bar.baz，词法作用域只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。</p>
<p><strong>注意</strong></p>
<p>通过eval和with可以做到欺骗词法，但是会导致性能大大降低，因此我们应该尽量避免使用eval和with</p>
<h4 id="2-1-6-函数作用域"><a href="#2-1-6-函数作用域" class="headerlink" title="2.1.6 函数作用域"></a>2.1.6 函数作用域</h4><p>属于这个函数的全部变量都可以在这个函数的范围内使用（在嵌套的作用域中也可以访问），这能够充分利用JavaScript变量可以根据需要动态改变值的特性。</p>
<p><strong>隐藏内部实现</strong></p>
<p>我们可以从缩写的代码中挑选出任意一个小片段，然后用函数声明对它进行包装，也就是说这段代码中涉及到的变量或者函数都将绑定在这个新创建的包装函数的作用域中。</p>
<blockquote>
<p>最小授权原则： 在软件设计中，应该最小限度地暴露必要的内容，而将其他内容都”隐藏“起来，比如某个某个模块或者对象的API的设计</p>
</blockquote>
<p><strong>规避冲突</strong></p>
<p>”隐藏“作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突，冲突会导致变量的值被恶意修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    bar(i * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码因为变量冲突导致了死循环</p>
<p><strong>全局命名空间</strong></p>
<p>很多第三方库在全局作用域中声明一个名字足够独特的变量，通常是一个对象，这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addClass()&#123;&#125;,</span><br><span class="line">    removeClass()&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>模块管理</strong></p>
<p>另外一种避免全局冲突的方法是使用模块机制，如Seajs, require.js,commonjs等，这写工具并没有违反词法作用域规则，而是强制所有标识符都不能注入到共享作用域中，而是保持在私有的，无冲突的作用中。</p>
<h4 id="2-1-7-函数声明，函数表达式，匿名函数"><a href="#2-1-7-函数声明，函数表达式，匿名函数" class="headerlink" title="2.1.7 函数声明，函数表达式，匿名函数"></a>2.1.7 函数声明，函数表达式，匿名函数</h4><p>区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是第一行代码， 而是整个声明中的位置），如果function是声明中的第一个词，则为函数声明，否则就是一个函数表达式。</p>
<p>如以下两段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">2</span> ;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>第1段代码必须显示声明函数foo并显示调用，污染了所在的作用域</p>
<p>第2段代码为一个函数表达式，并使用匿名函数免除了对所在作用域的污染</p>
<p><strong>回调函数中的匿名函数表达式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I wanted 1 second!!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码使用setTimeout的回调函数使用了匿名函数表达式</p>
<p>匿名函数表达式写起来非常简单快捷，但是同时也存在几个缺点：</p>
<ol>
<li>在追踪堆栈中不会显示出有意义的函数名，使得调试困难。</li>
<li>如果没有函数名，就只能通过过时的arguments.callee引用自身</li>
<li>函数名对于代码的可读性、可理解性很重要</li>
</ol>
<p><strong>始终给函数表达式添加函数名是最佳实践</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I wanted 1 second!!!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-立即执行函数-IIFE-Immediately-invoked-Function-Expression"><a href="#2-1-8-立即执行函数-IIFE-Immediately-invoked-Function-Expression" class="headerlink" title="2.1.8 立即执行函数(IIFE, Immediately invoked Function Expression)"></a>2.1.8 立即执行函数(IIFE, Immediately invoked Function Expression)</h4><p>由于函数被包含在一对()括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如(function foo(){ .. })()。第一个()将函数变成表达式，第二个()执行了这个函数。</p>
<p><strong>IIFE传递参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(global.a);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>我们将window对象的引用传递进去，但将参数命名为global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。</p>
<p><strong>IIFE运行顺序的倒置，UMD代码封装用到</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">def</span>)</span>&#123;</span><br><span class="line">  def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(global.a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-9-块作用域"><a href="#2-1-9-块作用域" class="headerlink" title="2.1.9 块作用域"></a>2.1.9 块作用域</h4><p>下述两段代码暴露了一些问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">   <span class="keyword">var</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">   bar = something(bar);</span><br><span class="line">   <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环的循环变量会暴露到外部作用域，而不是只被限制在了for循环的范围内</p>
<p>而if内的变量声明也会暴露到外部作用域中</p>
<p>因此我们需要块作用域的存在</p>
<p><strong>with</strong></p>
<p>with的使用会创建出一个块级作用域</p>
<p><strong>try/catch</strong></p>
<p>非常少有人会注意到JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效</p>
<p><strong>let</strong></p>
<p>到目前为止，我们知道JavaScript在暴露块作用域的功能中有一些奇怪的行为。如果仅仅是这样，那么JavaScript开发者多年来也就不会将块作用域当作非常有用的机制来使用了。</p>
<p>幸好，ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。let关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。</p>
<p><strong>const</strong></p>
<p>除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。</p>
<h4 id="2-1-10-提升"><a href="#2-1-10-提升" class="headerlink" title="2.1.10 提升"></a>2.1.10 提升</h4><p>提升只会发生在函数声明和变量声明，函数表达式不会发生提升 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo());   </span><br><span class="line"><span class="built_in">console</span>.log(foo1());   <span class="comment">// TypeError</span></span><br><span class="line"><span class="built_in">console</span>.log(str);      <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello foo1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"hello str"</span>;</span><br></pre></td></tr></table></figure>

<p>在提升过程中，函数声明比变量声明优先级高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码发生提升后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h4 id="2-1-11-作用域和闭包"><a href="#2-1-11-作用域和闭包" class="headerlink" title="2.1.11 作用域和闭包"></a>2.1.11 作用域和闭包</h4><p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取<a href="https://baike.baidu.com/item/局部变量/9844788" target="_blank" rel="noopener">局部变量</a>，所以闭包可以理解成“定义在一个<a href="https://baike.baidu.com/item/函数/301912" target="_blank" rel="noopener">函数</a>内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印5个5，因为5个匿名函数使用的i都为全局作用域的i,而setTimeout的回调函数会在for循环执行完成之后执行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常打印0,1,2,3,4,5，使用IIFE创建新的作用域，每个匿名函数产生闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常打印0,1,2,3,4,5, 使用let创建块级作用域，只在for循环内才能访问到i</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CommonUtils = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">"common utils"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printStr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        printStr: printStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">CommonUtils.printStr();</span><br></pre></td></tr></table></figure>

<p>IIFE匿名函数内部return回模块的公共API， 内部函数引用了外部作用域的变量，这样便构成了一个模块</p>
<p><strong>现代的模块机制</strong></p>
<p>一个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Modules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deps.length; i++)&#123;</span><br><span class="line">            deps[i] = modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name] = impl.apply(impl, deps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        define: define,</span><br><span class="line">        <span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Modules.define("bar", [], function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello: hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Modules.define(<span class="string">"foo"</span>, [<span class="string">"bar"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        awesome: awesome</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = Modules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo = Modules.get(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.hello(<span class="string">"hippo"</span>));</span><br><span class="line">foo.awesome();</span><br></pre></td></tr></table></figure>

<h2 id="2-2-this"><a href="#2-2-this" class="headerlink" title="2.2 this"></a>2.2 this</h2><p>当一个函数被调用的时候，引擎会创建执行上下文，用来记录函数在哪里被调用（调用栈），函数的调用方式，传入的参数信息，this就是这些记录的一个属性。this是在调用时候被绑定的，完全取决于函数的调用位置。</p>
<p>我们分析一下下述代码中的调用栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为: baz</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"baz"</span>); </span><br><span class="line">    bar();  <span class="comment">// &lt;-- bar 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为baz -&gt; bar</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo 的代用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈为baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>

<p>我们可以把调用栈想象为一个函数调用链，我们也可以在每个函数内添加断点利用浏览器的开发者恐惧来得到调用栈。</p>
<h3 id="2-2-1-this的绑定规则"><a href="#2-2-1-this的绑定规则" class="headerlink" title="2.2.1 this的绑定规则"></a>2.2.1 this的绑定规则</h3><ul>
<li><p>默认绑定<br>函数直接调用，即不通过点操作符进行调用，非严格模式下,this指向window, 严格模式下为undefined</p>
</li>
<li><p>隐式绑定<br>调用位置如果被某个对象拥有或者包含</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

<p>上述代码foo函数被调用时候调用位置会使用obj上下文来引用函数，因此我们可以说函数被调用时，obj对象拥有或者包含它<br>对象属性引用链可能包含多级属性引用，调用位置会把最后一层作为上下文来引用函数</p>
<p>如<code>obj1.obj2.foo()</code>会使用obj2作为foo函数调用时候的是上下文。<br><strong>隐式丢失</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span>;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>上述代码中，虽然bar是obj.foo的一个引用，它引用的是foo函数本身，因此此时bar()其实是一个函数的直接调用，因此会采用默认绑定规则。</p>
<p><strong>回调函数中也会发生隐式赋值，fn也只是引用foo函数本身，因此执行时候也是等同于函数的直接低啊用，会采用默认绑定规则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a  = <span class="string">"oops, global"</span>;</span><br><span class="line">doFoo(obj.foo);</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示绑定(使用call和apply)<br>从this的绑定角度上来说，call和apply是一样的，二者不同点体现在其他参数上</p>
<ul>
<li><p>硬绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可以复用的辅助函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = bind(foo, obj);</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>

<p>我们也可以使用ES5提供的内置的方法Function.prototype.bind</p>
</li>
</ul>
</li>
<li><p>new绑定<br>在JavaScript中，构造函数只是一些使用new操作符调用的普通函数， 其实并不存在构造函数的调用，而是对于函数的”<strong>构造调用</strong>“<br>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行<strong>[[Prototype]]</strong>连接</li>
<li>这个新对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li>
</ol>
</li>
</ul>
<h3 id="2-2-2-this绑定规则的优先级"><a href="#2-2-2-this绑定规则的优先级" class="headerlink" title="2.2.2 this绑定规则的优先级"></a>2.2.2 this绑定规则的优先级</h3><p><strong>显示绑定优先级高于隐式绑定</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo();</span><br><span class="line">obj2.foo();</span><br><span class="line">obj1.foo.call(obj2);</span><br><span class="line">obj2.foo.call(obj1);</span><br></pre></td></tr></table></figure>

<p><strong>new绑定优先级高于隐式绑定优先级</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">obj1.foo(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log(obj1.a);   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示绑定</span></span><br><span class="line">obj1.foo.call(obj2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 绑定</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">/// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>new绑定和显示绑定的比较</strong></p>
<p>New不能和call,apply一起使用，我们使用硬绑定来测试它们的优先级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a  = something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将foo函数的this应绑定到this上面</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>new bar(3)并没有像我们预计的那样把obj1.a修改为3,而是修改了硬绑定（到obj1）调用bar中的this,创建了一个新的对象</p>
<p><strong>判断this</strong></p>
<ol>
<li>函数是否使用new调用，如果是的话this绑定的是新创建的对象</li>
<li>函数是否通过call, apply显示绑定或者通过bind函数硬绑定调用，如果是的话，this绑定的是指定的对象</li>
<li>函数是否在某个上下文调用(隐式绑定),如果是的话，this绑定的是那个上下文对象</li>
<li>如果都不是的话，使用默认绑定，如果在严格模式下， 就绑定到undefined,否则绑定到全局对象。</li>
</ol>
<p><strong>绑定中的一些特殊情况</strong></p>
<ul>
<li><p>把null,undefined作为绑定的对象传入call,apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则（比如在进行函数柯里化或者this指向不重要的时候）</p>
<p>然而，总是使用null来忽略this绑定可能产生一些副作用，如果某个函数确实使用了this,那默认绑定规则会把this绑定到全局对象（在浏览器中这个对象是window），这将导致不可预计的结果（比如修改全局对象）</p>
</li>
<li><p>更安全的this<br>我们使用一个空的委托对象(或者叫非军事区对象DMZ: demilitarized zone)来表达我们希望this为空的意图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a: "</span> + a + <span class="string">",b: "</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">foo.apply(ø, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(ø, <span class="number">2</span>);</span><br><span class="line">bar(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>软绑定</strong></p>
<p>硬绑定可以把this强制绑定到指定的对象(除了使用new时)，防止函数调用应用默认绑定规则，但是硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this的指向了。</p>
<p>如果可以给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</p>
<p>可以使用一种称为软绑定的方法来实现我们想要的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(! <span class="built_in">Function</span>.prototype.softBind )&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span> || <span class="keyword">this</span> === (<span class="built_in">window</span> || global))? obj : <span class="keyword">this</span>,</span><br><span class="line">                curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"obj"</span> &#125;,</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">"obj2"</span> &#125;,</span><br><span class="line">    obj3 = &#123; <span class="attr">name</span>: <span class="string">"obj3"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind(obj);</span><br><span class="line">fooOBJ();   <span class="comment">// name: obj</span></span><br><span class="line">fooOBJ.call(obj2)  <span class="comment">// name: obj2</span></span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo();    <span class="comment">// name: obj2</span></span><br><span class="line"></span><br><span class="line">setTimeout(obj2.foo, <span class="number">10</span>);  <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-箭头函数的this绑定规则"><a href="#2-2-3-箭头函数的this绑定规则" class="headerlink" title="2.2.3 箭头函数的this绑定规则"></a>2.2.3 箭头函数的this绑定规则</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2);</span><br></pre></td></tr></table></figure>

<p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1,bar(引用箭头函数)的this也会绑定到obj1， 箭头函数的绑定无法被修改。(new也不行)</p>
<p>回调函数中使用箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo1.call(obj);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-对象"><a href="#2-3-对象" class="headerlink" title="2.3 对象"></a>2.3 对象</h2><p>对象的两种定义方式:</p>
<ul>
<li>使用对象字面量{}</li>
<li>使用构造函数Object</li>
</ul>
<h3 id="2-3-1-类型"><a href="#2-3-1-类型" class="headerlink" title="2.3.1 类型"></a>2.3.1 <strong>类型</strong></h3><p>JS包括六种主要类型</p>
<p>string, number, boolean, null, undefined, object</p>
<p><strong>内置对象</strong></p>
<p>内置对象表现形式像其他语言中的type或者class，但是在JS中，它们实际上只是一些内置函数，它们可以当做构造函数(使用new来调用)， 从而构造一个对应子类型的新对象。</p>
<h3 id="2-3-2-对象属性"><a href="#2-3-2-对象属性" class="headerlink" title="2.3.2 对象属性"></a>2.3.2 <strong>对象属性</strong></h3><p>对象的内容由一些存储在特定命名位置（任意类型）值组成，它们就是对象的属性，表现形式上属性好像存储在对象内部，但是在引擎内部这些值的存储方式是多种多样的，一般不会存在对象容器内，存储在对象容器内部的是这些属性的名称，它们就像指针（引用），指向这些值的真正的存储位置。</p>
<p><strong>属性的访问方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObj.a    <span class="comment">// 属性访问</span></span><br><span class="line">myObj[<span class="string">'a'</span>]  <span class="comment">// 键访问</span></span><br></pre></td></tr></table></figure>

<p>ES6新增了可计算属性名</p>
<p><code>myObj: { [prefix + &#39;bar&#39;]: &quot;hello&quot;}</code></p>
<p><strong>数组</strong></p>
<p>数组可以只用数组字面量[]或者Array构造函数来声明</p>
<p><code>var arr = [] or var arr = new Array()</code></p>
<p>数组元素类型没有限制，如果试图向数组添加一个属性，但是属性名看起来像一个数字，那它会作为下标</p>
<p><code>var arr[&#39;0&#39;] =  &#39;hello&#39;</code></p>
<h3 id="2-3-3-对象复制"><a href="#2-3-3-对象复制" class="headerlink" title="2.3.3 对象复制"></a>2.3.3 <strong>对象复制</strong></h3><p><strong>对于JSON安全</strong> (可以被序列化一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象)的对象来说，可以使用</p>
<p><code>var obj1 = JSON.parse(JSON.stringify(obj));</code></p>
<p><strong>ES6提供了Object.assign实现浅复制</strong></p>
<p><code>Object.assign({}, obj)</code></p>
<h3 id="2-3-4-属性描述符"><a href="#2-3-4-属性描述符" class="headerlink" title="2.3.4 属性描述符"></a>2.3.4 属性描述符</h3><p>ES5提供了属性描述符来描述属性的特性（<strong>值value</strong>, <strong>可写writable</strong>, <strong>可枚举enumerable(决定属性是否能被for..in循环和Object.keys()遍历到)</strong>, <strong>可配置configurable</strong>）</p>
<p>我们可以使用<strong>Object.defineProperty()</strong>来定义属性或者修改属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>configurable属性代表可配置性</p>
<p>值为false的话，不可以使用delete进行属性删除， 可以把writable由true改为false, 不能由false改为true</p>
<p><strong>对象常量</strong></p>
<p>结合writable: false和configurable: false就可以创建一个真正的属性常量(不可修改，重定义或者删除)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"FAVORITE NUMBER"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>禁止扩展</strong></p>
<p>禁止一个对象添加新属性并且保留已有属性，可以使用<strong>Object.preventExtensions()</strong></p>
<p>在严格模式下会抛出TypeError， 非严格模式下静默失败</p>
<p><strong>密封</strong></p>
<p>在Object.preventExtensions()的基础上把现有所有属性设置为configurable: false可以使用 <strong>Object.seal()</strong> </p>
<p>密封后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（可以修改属性的值）</p>
<p><strong>冻结</strong></p>
<p><strong>Object.freeze()</strong>   在密封基础上把现有所有属性设置为writable: false</p>
<p>禁止对于对象本身及其任意直接属性的修改（不过，这个对象引用的其他对象是不受影响的）， 如果要实现</p>
<p><strong>深度冻结</strong>则需要遍历调用Object.freeze()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objDeepFreeze = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!obj) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"被冻结对象不能为空"</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"被冻结目标必须是对象"</span>);</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = obj[key];</span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> value === <span class="string">'object'</span> )&#123;</span><br><span class="line">       dhelper.objDeepFreeze(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-setter和getter"><a href="#2-3-5-setter和getter" class="headerlink" title="2.3.5 setter和getter"></a>2.3.5 <strong>setter和getter</strong></h3><p>1.通过对象初始化器在创建对象的时候指明（也可以称为通过字面值创建对象时声明）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;</span><br><span class="line">    a : <span class="number">7</span>,</span><br><span class="line">    <span class="keyword">get</span> b()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a +<span class="number">1</span>;&#125;,<span class="comment">//通过 get,set的 b,c方法间接性修改 a 属性</span></span><br><span class="line">    <span class="keyword">set</span> c(x)&#123;<span class="keyword">this</span>.a = x/<span class="number">2</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">  o.c = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>2.使用 Object.create 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="literal">null</span>;</span><br><span class="line">  o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype,<span class="comment">//指定原型为 Object.prototype</span></span><br><span class="line">      &#123;</span><br><span class="line">        bar:&#123;</span><br><span class="line">          <span class="keyword">get</span> :function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">set</span> : function (val) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Setting `o.a` to "</span>,val);</span><br><span class="line">            <span class="keyword">this</span>.a = val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="comment">//第二个参数</span></span><br><span class="line">    );</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">  o.a = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>Object.prototype也可以替换成想要继承的原型对象，如<code>var o = {a: 10};</code></p>
<p>3.使用 Object.defineProperty 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123; <span class="attr">a</span> : <span class="number">1</span>&#125;<span class="comment">//声明一个对象,包含一个 a 属性,值为1</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o,<span class="string">"b"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> : function (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.a = val;</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable : <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">  o.b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>4.使用 Object.defineProperties方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="string">"string"</span>&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperties(obj,&#123;</span><br><span class="line">    <span class="string">"A"</span>:&#123;</span><br><span class="line">      <span class="keyword">get</span>:function()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a+<span class="number">1</span>;&#125;,</span><br><span class="line">      <span class="keyword">set</span>:function(val)&#123;<span class="keyword">this</span>.a = val;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"B"</span>:&#123;</span><br><span class="line">      <span class="keyword">get</span>:function()&#123;<span class="keyword">return</span> <span class="keyword">this</span>.b+<span class="number">2</span>;&#125;,</span><br><span class="line">      <span class="keyword">set</span>:function(val)&#123;<span class="keyword">this</span>.b = val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(obj.A);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.B);</span><br><span class="line">  obj.A = <span class="number">3</span>;</span><br><span class="line">  obj.B = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.A);</span><br><span class="line">  <span class="built_in">console</span>.log(obj.B);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>5.使用 Object.prototype.<strong>defineGetter</strong> 以及 Object.prototype.<strong>defineSetter</strong> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">  o.__defineGetter__(<span class="string">"giveMeA"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;);</span><br><span class="line">  o.__defineSetter__(<span class="string">"setMeNew"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = val;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(o.giveMeA);</span><br><span class="line">  o.setMeNew = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.giveMeA);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="2-3-6-使用in-或者-hasOwnProperty判断属性存在性"><a href="#2-3-6-使用in-或者-hasOwnProperty判断属性存在性" class="headerlink" title="2.3.6 使用in 或者 hasOwnProperty判断属性存在性"></a>2.3.6 使用in 或者 hasOwnProperty判断属性存在性</h3><p>属性返回值可能为undefined，但是这个undefined可能是属性中存储的undefined也可能是因为属性不存在所以返回undefined，可以使用hasOwnProperty函数来区分这两种情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span> <span class="keyword">in</span> myObj);</span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure>

<p>如果通过Object.create(null)来创建对象，原型没有连接到Object.prototype，这种情况下可以使用更强硬的方法来进行判断:</p>
<p><code>Object.prototype.hasOwnProperty.call(myObj, &#39;a&#39;);</code></p>
<p>它借用了基础的hasOwnProperty()方法并把它显示绑定到myObj上</p>
<p><strong>注意</strong></p>
<p>in操作符是判断某个属性名是否存在，对于数组[2,4,6], 属性名为0,1,2，因此<code>4 in [2,4,6]</code>会得到false值</p>
<p><strong>一些常用的属性操作函数</strong></p>
<ul>
<li>obj.propertyIsEnumable()检查给定属性是否可枚举</li>
<li>Object.keys()会返回一个数组，包含所有可枚举属性</li>
<li>Object.getOwnPropertyNames()会返回一个数组，包含所有属性，无论他们是否可以枚举</li>
<li>Object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性，不会查找原型链[[Prototype]]</li>
<li>in和hasOwnProperty的区别在于是否查找原型链， in会查找原型链， hasOwnProperty不会查找原型链</li>
<li>目前没有内置方法获取in操作符使用的属性列表（对象本身的属性及原型链中的属性），我们可以递归某个对象的整条原型链并保存每一层中使用Object.keys()得到的属性列表—只包含可枚举属性。</li>
</ul>
<h3 id="2-3-7-对象的遍历"><a href="#2-3-7-对象的遍历" class="headerlink" title="2.3.7 对象的遍历"></a>2.3.7 对象的遍历</h3><ul>
<li>for..in循环可以用来遍历对象的可枚举属性列表（包括[[Prototype]]链）</li>
<li>对于数值索引的数组来说，可以使用标准的for循环来遍历值：</li>
<li>ES5中增加了一些数组的辅助迭代器，包括<strong>forEach(..)</strong>、<strong>every(..)</strong>和<strong>some(..)</strong>。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。forEach(..)会遍历数组中的所有值并忽略回调函数的返回值。every(..)会一直运行直到回调函数返回false（或者“假”值）, some(..)会一直运行直到回调函数返回true（或者“真”值）。every(..)和some(..)中特殊的返回值和普通for循环中的break语句类似，它们会提前终止遍历</li>
<li>遍历数组下标时候采用的数字顺序，但是遍历对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样，因此，在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们是不可靠的。</li>
<li>ES6增加了一种用来遍历数组的for..of循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</li>
</ul>
<h2 id="2-4-类-继承-混入"><a href="#2-4-类-继承-混入" class="headerlink" title="2.4 类, 继承, 混入"></a>2.4 类, 继承, 混入</h2><p>类不是JS必须的编程基础，而是一种可选的代码抽象。JS实际上并没有类，类只是一种设计模式，我们可以使用一些方法来实现近似类的功能，为了满足对于类设计模式的最普遍的需求，JavaScript提供了一些近似类的语法。</p>
<h3 id="2-4-1-类的机制"><a href="#2-4-1-类的机制" class="headerlink" title="2.4.1 类的机制"></a>2.4.1 类的机制</h3><p><strong>类和实例</strong></p>
<p>一个类就是一张蓝图，为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有的数据属性。这个对象就是类中描述的所有特性的一份副本。</p>
<p><strong>构造函数</strong></p>
<p>类的实例由一个特殊的类方法构造，这个方法名通常和类名相同，被称为构造函数，这个方法的任务就是初始化实例需要的所有信息（状态）</p>
<h3 id="2-4-2-类的继承"><a href="#2-4-2-类的继承" class="headerlink" title="2.4.2 类的继承"></a><strong>2.4.2 类的继承</strong></h3><p>JS中 类的声明有两种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES6中的class声明</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而实例化类，就是一个简单的 new 就完了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(), <span class="keyword">new</span> Animal2());</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1797988/201912/1797988-20191215155708186-785877660.jpg" alt=""></p>
<ol>
<li><p><strong>原型链继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将原型对象赋值为另一个类型的实例，原型对象将包含一个指向另一个原型的指针</span></span><br><span class="line"><span class="comment"> * 构成实例与原型的链条</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象赋值为父类的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child().__proto__.__proto__.constructor);  <span class="comment">// Function Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象是共用的</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child();</span><br><span class="line">s1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.arr, s2.arr);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>通过原型链实现继承时候，不能使用对象字面量创建原型方法，因为这样会重写原型链<br>这种继承方式会实现为各个实例共享原型对象， 且在创建子类型的时候不能向超类型的构造函数中传递参数。</p>
</li>
<li><p><strong>构造函数方式继承</strong><br>用子类型的构造函数内部调用要继承的父类的构造函数，构造函数去继承构造函数，不存在共享和无法传递参数的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    <span class="comment">// 调用超类的构造函数，构造函数继承了构造函数</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child();</span><br><span class="line">s1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.arr, s2.arr);</span><br><span class="line"><span class="comment">// TypeError: s1.sayName is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.sayName());</span><br></pre></td></tr></table></figure>

<p>最大优势是可以在调用超累的构造函数时候传递参数<br>问题是：无法继承原型中的方法和属性， 且因为使用构造函数来实现，创建每个实例时候，超类的方法和属性都要在每个实例上重新创建一遍，性能损耗严重。</p>
</li>
<li><p><strong>组合继承</strong><br>将原型链继承和构造函数继承相结合进行使用，原型链继承来实现对原型链上方法和属性的继承（实现属性和方法的共用），构造函数继承实现对实例属性的继承（实现私有的实例化），这样既实现了原型上方法和属性的复用，又能够保证每个实例有自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    <span class="comment">// 构造函数继承， 第一次调用Person()</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承，第二次调用Person()</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor); <span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor); <span class="comment">// [Function: Person]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修复constructor的指向,否则无法继承后无法区分p和c的具体类型</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor);  <span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(c.constructor);  <span class="comment">// [Function: Child]</span></span><br></pre></td></tr></table></figure>

<p>这种方式的最大问题是要调用两次超类的构造函数</p>
<p><strong>组合继承的优化</strong><br>优化步骤1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对两次调用超类构造函数的问题优化版本1</span></span><br><span class="line"><span class="comment"> * 修改原型链继承方式，作为继承超类原型来用，</span></span><br><span class="line"><span class="comment"> * 完善借用构造函数继承无法继承到超类原型的缺点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类的原型指向了超类的原型</span></span><br><span class="line">Child.prototype = Person.prototype;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">// 无法区分s的具体类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Child, s <span class="keyword">instanceof</span> Person); <span class="comment">// true, true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: Person]</span></span><br></pre></td></tr></table></figure>

<p>优化步骤2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 针对两次调用超类构造函数的问题优化版本2</span></span><br><span class="line"><span class="comment"> * 修改子类的constructor指向</span></span><br><span class="line"><span class="comment"> * 利用Object.create() 去 创建中间对象从而将子类和超类区分开；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">"child"</span>;</span><br><span class="line">    Person.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Object.create来作为中间链，将子类和超类区分开，且保持正确的链接</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"><span class="comment">// 修复constructor指向</span></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Child, s <span class="keyword">instanceof</span> Person); <span class="comment">// true, true</span></span><br><span class="line"><span class="built_in">console</span>.log(s.constructor); <span class="comment">// [Function: Person]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于Object.create()函数的原型继承</strong><br>Object.create函数规范化了原型继承，这个函数接收两个参数，第一个参数为原型对象，第二个参数为为新对象定义的额外属性的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelly"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person1.name = <span class="string">"person1 name"</span>;</span><br><span class="line">person1.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person);</span><br><span class="line">person2.name = <span class="string">"person2 name"</span>;</span><br><span class="line">person2.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);</span><br><span class="line"><span class="built_in">console</span>.log(person2.name);</span><br></pre></td></tr></table></figure>

<p>Object.create中继承的参数的内容并不是直接放到子类中,而是存在与子类的原型中; 所以会出现覆盖(实例属性覆盖继承的原型属性)和共享属性的特征（如上例中的person.friends）</p>
</li>
<li><p><strong>寄生式继承</strong><br>与原型式继承紧密相关的一种思路,即创建一个用于封装过程的函数，该函数在内部以某种方式增强对象，最后就像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone  = <span class="built_in">Object</span>.create(origin);</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"david"</span>,</span><br><span class="line">    friends: [<span class="string">"Sheldy"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"tom"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.friends);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);</span><br><span class="line">anotherPerson.sayHi();</span><br></pre></td></tr></table></figure>

<p>使用寄生继承来为对象添加函数，不能做到函数复用而降低性能，这一点与构造函数继承类似</p>
</li>
<li><p><strong>寄生组合继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subtype, supertype</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 以超类的原型对象为参数创建新对象，新对象的原型链接到超类的原型</span></span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Object</span>.create(supertype.prototype);</span><br><span class="line">    <span class="comment">// 中间对象的构造函数指定为子类的构造函数</span></span><br><span class="line">    middle.constructor = subtype;</span><br><span class="line">    <span class="comment">// 指定middle为子类的原型对象</span></span><br><span class="line">    subtype.prototype = middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数，完成实例属性的继承</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需先完成原型继承(这一步从父类原型链上继承来所有方法和属性)，然后再扩展子类的原型，否则会覆盖掉在SubType.prototype上面定义的方法</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">instance1.sayName();</span><br><span class="line">instance1.sayAge();</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">instance2.sayName();</span><br><span class="line">instance2.sayAge();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 class使用extends完成继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Polygon"</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I am a "</span>, <span class="keyword">this</span>.name + <span class="string">"."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Square"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> area(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.area = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mySquare = <span class="keyword">new</span> Square(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mySquare);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-5-原型和原型链"><a href="#2-5-原型和原型链" class="headerlink" title="2.5 原型和原型链"></a>2.5 原型和原型链</h2><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。</p>
<p>当你通过各种语法进行属性查找时都会查找[[Prototype]]链，直到找到属性或者查找完整条原型链。</p>
<p><strong>但是到哪里是[[Prototype]]的“尽头”呢？</strong></p>
<p>所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把[[Prototype]]链的顶端设置为）这个Object.prototype对象，所以它包含JavaScript中许多通用的功能。</p>
<h3 id="一、prototype"><a href="#一、prototype" class="headerlink" title="一、prototype"></a>一、prototype</h3><p>在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age       </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'kavin'</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">//kavin</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name)  <span class="comment">//kavin</span></span><br></pre></td></tr></table></figure>

<p>上述例子中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。</p>
<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151024134-512558007.png" alt="img"></p>
<h3 id="二、proto"><a href="#二、proto" class="headerlink" title="二、proto"></a>二、<strong>proto</strong></h3><p>这是每个对象(除null外)都会有的属性，叫做<strong>proto</strong>，这个属性会指向该对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>而关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img"></p>
<p>补充说明：</p>
<p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="三、constructor"><a href="#三、constructor" class="headerlink" title="三、constructor"></a>三、constructor</h3><p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person===Person.prototype.constructor)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>所以再更新下关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151615691-1017611190.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person.constructor &#x3D;&#x3D;&#x3D; Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<h3 id="四、实例与原型"><a href="#四、实例与原型" class="headerlink" title="四、实例与原型"></a>四、实例与原型</h3><p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'Daisy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h3 id="五、原型的原型"><a href="#五、原型的原型" class="headerlink" title="五、原型的原型"></a>五、原型的原型</h3><p> 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708152327825-11086376.png" alt="img"></p>
<h3 id="六、原型链"><a href="#六、原型链" class="headerlink" title="六、原型链"></a>六、原型链</h3><p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>
<p>其实简单来说，就是上述四-五的过程。</p>
<p>继上述五中所说，那 Object.prototype 的原型呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png" alt="img"></p>
<p>图中由相互关联的原型组成的链状结构就是<strong>原型链</strong>，也就是蓝色的这条线。</p>
<h3 id="七-属性的设置和屏蔽"><a href="#七-属性的设置和屏蔽" class="headerlink" title="七. 属性的设置和屏蔽"></a>七. <strong>属性的设置和屏蔽</strong></h3><p>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性。</p>
<p><code>myObject.foo = &quot;bar&quot;</code></p>
<ul>
<li><p>如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p>
</li>
<li><p>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作。如果原型链上找不到foo, foo就会被直接添加到myObject上。然而，如果foo存在于原型链上层，赋值语句myObject.foo = “bar”的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍</p>
</li>
<li><p>如果属性名foo既出现在myObject中也出现在myObject的[[Prototype]]链上层，那么就会发生屏蔽。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo总是会选择原型链中最底层的foo属性。屏蔽比我们想象中更加复杂。下面我们分析一下如果foo不直接存在于myObject中而是存在于原型链上层时myObject.foo = “bar”会出现的三种情况。</p>
<ol>
<li><p>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性（参见第3章）并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    value: <span class="string">"person"</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;  <span class="comment">// TypeError: Cannot assign to read only property 'type' of object '#&lt;Student&gt;'</span></span><br><span class="line"><span class="built_in">console</span>.log(s.type); <span class="comment">// student</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    value: <span class="string">"person"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;  <span class="comment">// TypeError: Cannot assign to read only property 'type' of object '#&lt;Student&gt;'</span></span><br><span class="line"><span class="built_in">console</span>.log(s.type);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在[[Prototype]]链上层存在foo并且它是一个setter（参见第3章），那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>._type = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"type"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._type</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"setter: "</span> + val);</span><br><span class="line">        <span class="keyword">this</span>._type = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, classNo</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.classNo = classNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">"david"</span>, <span class="number">1</span>);</span><br><span class="line">s.type = <span class="string">"student"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.type);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="2-6-行为委托"><a href="#2-6-行为委托" class="headerlink" title="2.6 行为委托"></a>2.6 行为委托</h2><p>  下面是一个行为委托的小例子</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> Task = &#123;</span><br><span class="line">      setId: <span class="function"><span class="keyword">function</span>(<span class="params">ID</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.id = ID;</span><br><span class="line">      &#125;,</span><br><span class="line">      outputID: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.id)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将XYZ对象委托给Task</span></span><br><span class="line">  <span class="keyword">var</span> XYZ = <span class="built_in">Object</span>.create(Task);</span><br><span class="line">  XYZ.prepareTask = <span class="function"><span class="keyword">function</span>(<span class="params">ID, Label</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setId(ID);</span><br><span class="line">      <span class="keyword">this</span>.label = Label;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  XYZ.outputTaskDetails = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.outputID();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.label);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  XYZ.prepareTask(<span class="number">11</span>, <span class="string">"javascript"</span>);</span><br><span class="line">  XYZ.outputTaskDetails();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ABC = Object.create(Task);</span></span><br><span class="line"><span class="comment">// ABC ...</span></span><br></pre></td></tr></table></figure>

<p>  在这段代码中，Task和XYZ并不是类（或者函数），它们是对象。XYZ通过Object. create(..)创建，它的[[Prototype]]委托了Task对象（参见第5章）。</p>
<p>  相比于面向类（或者说面向对象），这种编码风格称为“对象关联”（OLOO, objectslinked to other objects）。我们真正关心的只是XYZ对象（和ABC对象）委托了Task对象。</p>
<p>  <strong>对象关联风格的代码还有一些不同之处</strong></p>
<ol>
<li><p>在上面的代码中，id和label数据成员都是直接存储在XYZ上（而不是Task）。通常来说，在[[Prototype]]委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。</p>
<ol start="2">
<li>在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有outputTask方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]]链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义（参见第4章）。这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。</li>
</ol>
</li>
<li><p>this.setID(ID); XYZ中的方法首先会寻找XYZ自身是否有setID(..)，但是XYZ中并没有这个方法名，因此会通过[[Prototype]]委托关联到Task继续寻找，这时就可以找到setID(..)方法。此外，由于调用位置触发了this的隐式绑定规则（参见第2章），因此虽然setID(..)方法在Task中，运行时this仍然会绑定到XYZ，这正是我们想要的。在之后的代码中我们还会看到this.outputID()，原理相同。换句话说，我们和XYZ进行交互时可以使用Task中的通用方法，因为XYZ委托了Task。委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。</p>
<p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p>
</li>
</ol>
<p>下面再看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.me = who;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.identity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>, who);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identity() + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>上面的代码是典型的类设计模式的实现代码，下面用行为委托来进行改写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用行为委托来进行改写</span></span><br><span class="line"><span class="keyword">var</span> Foo = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.me = who;</span><br><span class="line">    &#125;,</span><br><span class="line">    identity: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I am "</span> + <span class="keyword">this</span>.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Bar = <span class="built_in">Object</span>.create(Foo);</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + <span class="keyword">this</span>.identity() + <span class="string">"."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b1.init(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b2.init(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p><strong>一个登陆控制的例子</strong><br>类设计模式写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors = [];</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.showDialog = <span class="function"><span class="keyword">function</span>(<span class="params">title, msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(title + msg);</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.success = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Success"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">Controller.prototype.failure = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.push(err);</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Error"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Controller.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype = <span class="built_in">Object</span>.create(Controller.prototype);</span><br><span class="line">LoginController.prototype.constructor = LoginController;</span><br><span class="line">LoginController.prototype.getUser = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype.getPassword = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).value;</span><br><span class="line">&#125;</span><br><span class="line">LoginController.prototype.validateEntry = <span class="function"><span class="keyword">function</span>(<span class="params">user, pw</span>)</span>&#123;</span><br><span class="line">    user  = user || <span class="keyword">this</span>.getUser();</span><br><span class="line">    pw = pw || <span class="keyword">this</span>.getPassword();</span><br><span class="line">    <span class="keyword">if</span>(!(user &amp;&amp; pw))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Please enter a username &amp; password!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pw.length &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Password must be 5+ characters!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.success(<span class="string">"login success!!!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LoginController.prototype.failure = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    Controller.prototype.failure.call(<span class="keyword">this</span>, <span class="string">"Login invalid: "</span> + err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./登陆控制(类设计模式写法).js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">onsubmit</span>=<span class="string">"return onSubmit()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">       <span class="function"><span class="keyword">function</span> <span class="title">onSubmit</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> lc = <span class="keyword">new</span> LoginController();</span></span><br><span class="line">            lc.validateEntry();</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>行为委托写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Controller = &#123;</span><br><span class="line">  errors: [],</span><br><span class="line">  showDialog: <span class="function"><span class="keyword">function</span>(<span class="params">title, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.alert(title + msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Success"</span>, msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.errors.push(err);</span><br><span class="line">    <span class="keyword">this</span>.showDialog(<span class="string">"Error"</span>, err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将LoginController委托给Controller</span></span><br><span class="line"><span class="keyword">var</span> LoginController = <span class="built_in">Object</span>.create(Controller);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(LoginController, &#123;</span><br><span class="line">  getUser: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getPassword: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>).value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  validateEntry: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">user, pw</span>) </span>&#123;</span><br><span class="line">      user = user || <span class="keyword">this</span>.getUser();</span><br><span class="line">      pw = pw || <span class="keyword">this</span>.getPassword();</span><br><span class="line">      <span class="keyword">if</span> (!(user &amp;&amp; pw)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Please enter a username &amp; password!"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pw.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failure(<span class="string">"Password must be 5+ characters!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.success(<span class="string">"login success!!!"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在JavaScript中努力实现类机制（参见第4和第5章），也可以拥抱更自然的[[Prototype]]委托机制。</p>
<h2 id="2-6-异步和性能"><a href="#2-6-异步和性能" class="headerlink" title="2.6 异步和性能"></a>2.6 异步和性能</h2><h3 id="2-6-1-事件循环"><a href="#2-6-1-事件循环" class="headerlink" title="2.6.1 事件循环"></a>2.6.1 事件循环</h3><h4 id="（1）JS为何设计为单线程"><a href="#（1）JS为何设计为单线程" class="headerlink" title="（1）JS为何设计为单线程"></a>（1）JS为何设计为单线程</h4><hr>
<h5 id="js设计为单线程还是跟他的用途有关"><a href="#js设计为单线程还是跟他的用途有关" class="headerlink" title="js设计为单线程还是跟他的用途有关"></a>js设计为单线程还是跟他的用途有关</h5><p>试想一下 如果js设计为多线程 那么同时修改和删除同一个dom 浏览器又该如何执行?</p>
<p>#JS为何需要异步</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">9999</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我在执行 但用户不知道"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"你好啊"</span>)</span><br></pre></td></tr></table></figure>

<p>上图例子 for循环耗时会很久</p>
<p>这意味着 用户得不到 ‘你好啊’ 的响应 就会下意识会认为浏览器卡死了 所以js必须要有异步</p>
<p>js通过事件循环来实现异步 这也是js的运行机制</p>
<hr>
<h4 id="（2）JS事件的循环"><a href="#（2）JS事件的循环" class="headerlink" title="（2）JS事件的循环"></a>（2）JS事件的循环</h4><h5 id="1-归类"><a href="#1-归类" class="headerlink" title="1.归类"></a>1.归类</h5><p>遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task)。</p>
<p>宏任务：整体的<em>Scrip*t *setTimeout</em> <em>setInterval</em><br> 微任务：<em>Promise</em>      process.nextTick    </p>
<p> 示例代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个同步任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>)            --------&gt; 直接被执行</span><br><span class="line">                                      目前打印结果为：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个宏任务</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    --------&gt; 整体的setTimeout被放进宏任务列表</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)                    目前宏任务列表记为【s2】</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里是同步任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);         --------&gt; 直接被执行</span><br><span class="line">  resolve();                          目前打印结果为：<span class="number">1</span>、<span class="number">3</span></span><br><span class="line">  <span class="comment">// then是一个微任务</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       --------&gt; 整体的then[包含里面的setTimeout]被放进微任务列表</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)                    目前微任务列表记为【t45】</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">第一轮小结：</span><br><span class="line">执行到这里的结果：<span class="number">1</span>、<span class="number">3</span></span><br><span class="line"></span><br><span class="line">宏任务列表如下：</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>住：promise对象详解：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p>
<h5 id="2-有微则微，无微则宏"><a href="#2-有微则微，无微则宏" class="headerlink" title="2.有微则微，无微则宏"></a>2.有微则微，无微则宏</h5><p>如果微任务列表里面有任务 会执行完毕后在执行宏任务。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">浏览器瞅了一眼微任务列表 发现里面有微任务 就开始全部执行</span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)            --------&gt; 直接被执行</span><br><span class="line">                                        目前打印结果为：<span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    --------&gt; 被放进宏任务列表了</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)                    目前宏任务列表记为【s2、s5】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">浏览器发现微任务执行完毕了</span><br><span class="line"></span><br><span class="line">开始执行宏任务列表</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)   --------&gt; 直接被执行</span><br><span class="line">                               目前打印结果为：<span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)   --------&gt; 直接被执行</span><br><span class="line">                               目前打印顺序为： <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span>、<span class="number">5</span>、<span class="number">5</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">最终结果为： <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">2</span>、<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h5 id="3-总结-实战"><a href="#3-总结-实战" class="headerlink" title="3.总结 + 实战"></a>3.总结 + 实战</h5><p>反复执行以上步骤 就是事件循环(event loop) 一定要分的清任务类型 (宏任务 和 微任务)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">TIP: 为了容易辨别起名为p1（p开头 里面打印<span class="number">1</span>）</span><br><span class="line"> process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         --------&gt; 被放微任务列表</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'1'</span>);                             微任务列表记为：【p1】</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'2'</span>);                   --------&gt; 直接执行</span><br><span class="line">   resolve();                                    目前打印顺序为：<span class="number">2</span></span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 --------&gt; 整体的then被放进微任务列表[包含其中的setTimeout <span class="number">4</span>]</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'3'</span>);                             微任务列表记为：【p1 t34】</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;              --------&gt; 被放宏任务列表</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'5'</span>)                              宏任务列表记为：【s5】</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            --------&gt; 被放宏任务列表</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'6'</span>)                            宏任务列表记为：【s5 s6】</span><br><span class="line">   &#125;);</span><br><span class="line">   resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 --------&gt; 整体的then被放进微任务列表[包含其中的setTimeout和其中的多层嵌套]</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                      微任务列表记为：【p1 t34 t789】</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">       &#125;);</span><br><span class="line">       resolve()</span><br><span class="line">     &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'10'</span>)                      --------&gt; 直接执行</span><br><span class="line">                                                  目前打印顺序为：<span class="number">2</span>、<span class="number">10</span></span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">第一轮小结：</span><br><span class="line">执行结果为：<span class="number">2</span>、<span class="number">10</span></span><br><span class="line"></span><br><span class="line">宏任务列表如下：</span><br><span class="line"><span class="comment">// s5</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s6</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t34</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// t789</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">开始执行第二轮：</span><br><span class="line">有微任务 先执行微任务</span><br><span class="line">将微任务列表代码块搬下来</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;             --------&gt; 执行p1</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);                                 目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// t34</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>);                       --------&gt; 直接执行</span><br><span class="line">                                                    目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                --------&gt; 被放宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)                                宏任务列表记为：【s5 s6 s4】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// t789</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;              --------&gt; 被放宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>)                              宏任务列表记为：【s5 s6 s4 s789】</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">微任务执行完毕了 该执行我们的宏任务列表了</span><br><span class="line">因为微任务里面包含一部分宏任务</span><br><span class="line">所以现在的宏任务列表已经增加了</span><br><span class="line">现在把当前的宏任务列表搬下来</span><br><span class="line"><span class="comment">//s5</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s5</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'5'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s6</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s6</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//s4</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s4</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// s789</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;           --------&gt; 执行s789</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>)                           目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       --------&gt; 被放宏任务列表</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'8'</span>)                       宏任务列表记为：【s8】</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            --------&gt; 整体的then被放微任务列表[包含里面的setTimeout]</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                 微任务列表记为：【t9】</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">再次小结：</span><br><span class="line">当前结果：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span></span><br><span class="line">马上就要执行完了心里万分激动啊 （ 浏览器的内心独白 ^▽^  ...）</span><br><span class="line">宏任务列表如下：</span><br><span class="line"><span class="comment">// s8</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表如下：</span><br><span class="line"><span class="comment">// t9</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">继续执行 依旧遵循有微则微 无微则宏</span><br><span class="line">浏览器发现有一条微任务</span><br><span class="line">那就开始执行吧~</span><br><span class="line"><span class="comment">//t9</span></span><br><span class="line">then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   --------&gt; 执行t9 把里面的setTimeout放入宏任务列表</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>)                   宏任务列表记为：【s8 s9】</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">微任务列表执行完毕</span><br><span class="line">开始执行宏任务（宏任务刚刚又有新增哦~[s9]）</span><br><span class="line"><span class="comment">// s8</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     --------&gt; 执行s8</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)                     目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span>、<span class="number">8</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// s9</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     --------&gt; 执行s9</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>)                     目前打印顺序为：<span class="number">2</span>、<span class="number">10</span>、<span class="number">1</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">4</span>、<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">到这里 微任务列表 和 宏任务列表均为空 就执行完毕了</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-回调"><a href="#2-6-2-回调" class="headerlink" title="2.6.2 回调"></a>2.6.2 回调</h3><h5 id="异步回调的问题"><a href="#异步回调的问题" class="headerlink" title="异步回调的问题"></a>异步回调的问题</h5><h6 id="1-调用函数过早"><a href="#1-调用函数过早" class="headerlink" title="1.调用函数过早"></a>1.调用函数过早</h6><p>调用函数过早的最值得让人注意的问题， 是你不小心定义了一个函数，使得作为函数参数的回调可能延时调用，也可能立即调用。 也即你使用了一个可能同步调用， 也可能异步调用的回调。 这样一种难以预测的回调。</p>
<p>在英语世界里， 这种可能同步也可能异步调用的回调以及包裹它的函数， 被称作是 “Zalgo” （一种都市传说中的魔鬼）， 而编写这种函数的行为， 被称作是”release Zalgo” (将Zalgo释放了出来)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line">zalgoFunction () &#123;</span><br><span class="line">  <span class="comment">// 这里还有很多其他代码,使得a = 2可能被异步调用也可能被同步调用</span></span><br><span class="line">    [<span class="meta">  a = 2  </span>]</span><br><span class="line">  &#125;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>

<p>结果会输出什么呢？ 如果zalgoFunction是同步的， 那么a 显然等于2， 但如果 zalgoFunction是异步的，那么 a显然等于1。于是， 我们陷入了无法判断调用影响的窘境。</p>
<p>这只是一个极为简单的场景， 如果场景变得相当复杂， 结果又会如何呢？你可能想说： 我自己写的函数我怎么会不知道呢？<strong>很多时候这个不确定的函数来源于它人之手，甚至来源于完全无法核实的第三方代码。我们把这种不确定的情况稍微变得夸张一些： 这个函数中传入的回调， 有99%的几率被异步调用， 有1%的几率被同步调用。</strong></p>
<h6 id="2-调用次数过多"><a href="#2-调用次数过多" class="headerlink" title="2.调用次数过多"></a>2.调用次数过多</h6><p>这里取《你不知道的javascript（中卷）》的例子给大家看一看：</p>
<p>作为一个公司的员工，你需要开发一个网上商城， payWithYourMoney是你在确认购买后执行的扣费的函数， 由于公司需要对购买的数据做追踪分析， 这里需要用到一个做数据分析的第三方公司提供的analytics对象中的purchase函数。 代码看起来像这样</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">analytics.purchase( purchaseData, <span class="function"><span class="keyword">function</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">      payWithYourMoney ()</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>在这情况下，可能我们会忽略的一个事实是： 我们已经把payWithYourMoney 的控制权完全交给了analytics.purchase函数了，这让我们的回调“任人宰割”，这种控制权的转移， 被叫做“控制反转”。</p>
<p>然后上线后的一天， 数据分析公司的一个隐蔽的bug终于显露出来， <strong>让其中一个原本只执行一次的payWithYourMoney执行了5次</strong>， 这让那个网上商城的客户极为恼怒， 并投诉了你们公司。可你们公司也很无奈， 这个时候惊奇的发现： payWithYourMoney的控制完全不在自己的手里 ！！！！！后来， 为了保证只支付一次， 代码改成了这样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 判断是否已经分析（支付）过一次了</span></span><br><span class="line"><span class="keyword">var</span> analysisFlag  = <span class="literal">true</span></span><br><span class="line">analytics.purchase( purchaseData, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (！analysisFlag) &#123;</span><br><span class="line">           payWithYourMoney ()</span><br><span class="line">           analysisFlag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>

<p>但是， 这种方式虽然巧妙， 但却仍不够简洁优雅（后文提到的Promise将改变这一点）。而且， 在回调函数的无数“痛点”中， 它只能规避掉一个， 如果你尝试规避掉所有的“痛点”，代码将比上面更加复杂而混乱。</p>
<h6 id="3-太晚调用或根本没有调用"><a href="#3-太晚调用或根本没有调用" class="headerlink" title="3.太晚调用或根本没有调用"></a>3.太晚调用或根本没有调用</h6><p>因为你失去了对回调的控制权， 你的回调可能会出现预期之外的过晚调用或者不调用的情况（为了处理这个“痛点”你又将混入一些复杂的代码逻辑）</p>
<h6 id="4-吞掉报错"><a href="#4-吞掉报错" class="headerlink" title="4.吞掉报错"></a>4.吞掉报错</h6><p>回调内的报错是可能被包裹回调的外部函数捕捉而不报错，（为了处理这个“痛点”你又又又将混入一些复杂的代码逻辑）</p>
<h6 id="5-复杂情况下可读性差"><a href="#5-复杂情况下可读性差" class="headerlink" title="5.复杂情况下可读性差"></a>5.复杂情况下可读性差</h6><p>请问这段代码的调用顺序 ？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">doA( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    doB();</span><br><span class="line">    doC( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      doD();</span><br><span class="line">          &#125; )</span><br><span class="line">    doE();</span><br><span class="line">&#125; );</span><br><span class="line">doF();</span><br></pre></td></tr></table></figure>

<p>让人一脸蒙逼的回调函数地狱</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> catList = name + <span class="string">','</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    catList += name + <span class="string">','</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      catList += name + <span class="string">','</span>;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        catList += name + <span class="string">','</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">          catList += name;</span><br><span class="line">          <span class="built_in">console</span>.log(catList);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="string">'Lion'</span>);</span><br><span class="line">      &#125;, <span class="number">1</span>, <span class="string">'Snow Leopard'</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="string">'Lynx'</span>);</span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="string">'Jaguar'</span>);&#125;, <span class="number">1</span>, <span class="string">'Panther'</span>);</span><br></pre></td></tr></table></figure>

<h6 id="6-门"><a href="#6-门" class="headerlink" title="6.门"></a>6.门</h6><p>什么叫“门”？， 你可以大概理解成： 现在有一群人准备进屋，但只有他们所有人都到齐了，才能“进门” ，也就是： 只有所有的异步操作都完成了， 我们才认为它整体完成了，才能进行下一步操作</p>
<p>下面这个例子里， 我们试图通过两个异步请求操作，希望当a和b的取值都到达的时候才输出！！</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   a = x * <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">        baz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    b = y * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">           baz();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log( a + b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中的某个Ajax函数</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>

<p>这段代码比前面那段“链式”里的回调地狱好懂多了，但是却依然存在这一些问题：我们使用了两个 if (a &amp;&amp; b) { } 去分别保证baz是在a和b都到达后才执行的，试着思考一下：两个 if (a &amp;&amp; b) { } 的判断条件是否可以合并到一起呢，因为这两个判断条件都试图表达同一种语意： a 和 b都到达， 能合并成一条语句的话岂不是更加简洁优雅 ？ （一切都在为Promise做铺垫哦<del>~</del>啦啦啦）</p>
<h6 id="7-竞态"><a href="#7-竞态" class="headerlink" title="7.竞态"></a>7.竞态</h6><p>一组异步操作，其中一个完成了， 这组异步操作便算是整体完成了。在下面，我们希望通过异步请求的方式，取得x的值，然后执行foo或者bar，但希望只把foo或者bar其中一个函数执行一次</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        baz(x);</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">         x = x*<span class="number">2</span></span><br><span class="line">         baz(x);</span><br><span class="line">         flag = <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"> x </span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( x );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax(..)是某个库中的某个Ajax函数</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>

<p>在这里，我们设置了一个flag， 设它的初始值为true, 这时候foo或者bar在第一次执行的时候， 是可以进入if内部的代码块并且执行baz函数的， 但在if内部的代码块结束的时候， 我们把flag的值置为false,这个时候下一个函数就无法进入代码块执行了， 这就是回调对于竞态的处理。</p>
<h3 id="2-6-3-Promise"><a href="#2-6-3-Promise" class="headerlink" title="2.6.3 Promise"></a>2.6.3 Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">Stream 模式</a>是比部署Promise更好的选择。</p>
<h5 id="Promise是怎么解决问题的"><a href="#Promise是怎么解决问题的" class="headerlink" title="Promise是怎么解决问题的"></a>Promise是怎么解决问题的</h5><p>1.回调过早调用<br> 让我们回到那个回调的痛点：我们有可能会写出一个既可能同步执行， 又可能异步执行的“zalgo”函数。但Promise可以自动帮我们避免这个问题：如果对一个 Promise 调用 then(..) 的时候，即使这个 Promise是立即resolve的函数（即Promise内部没有ajax等异步操作，只有同步操作）， 提供给then(..) 的回调也是会被异步调用的，这帮助我们省了不少心</p>
<ol>
<li>回调调用次数过多<br> Promise 的内部机制决定了调用单个Promise的then方法， 回调只会被执行一次，因为Promise的状态变化是单向不可逆的，当这个Promise第一次调用resolve方法， 使得它的状态从pending（正在进行）变成fullfilled（已成功）或者rejected（被拒绝）后， 它的状态就再也不能变化了。所以你完全不必担心Promise.then( function ) 中的function会被调用多次的情况</li>
<li>回调中的报错被吞掉<br> 要说明一点的是Promise中的then方法中的error回调被调用的时机有两种情况：</li>
</ol>
<ul>
<li>a. Promise中主动调用了reject (有意识地使得Promise的状态被拒绝)， 这时error回调能够接收到reject方法传来的参数（reject(error)）</li>
<li>b. 在定义的Promise中， 运行时候报错（未预料到的错误）， 也会使得Promise的状态被拒绝，从而使得error回调能够接收到捕捉到的错误</li>
</ul>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      foo.bar(); <span class="comment">// foo未定义，所以会出错！</span></span><br><span class="line">      resolve( <span class="number">42</span> ); <span class="comment">// 永远不会到达这里 :( </span></span><br><span class="line"> &#125; );</span><br><span class="line">p.then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 永远不会到达这里 :(    </span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="comment">// err将会是一个TypeError异常对象来自foo.bar()这一行      </span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>还有一种情况是回调根本就没有被调用，这是可以用Promise的race方法解决（下文将介绍）</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于超时一个Promise的工具 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject( <span class="string">"Timeout!"</span> );</span><br><span class="line">          &#125;, delay );</span><br><span class="line">      &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置foo()超时 </span></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">   foo(), <span class="comment">// 试着开始foo()</span></span><br><span class="line">   timeoutPromise( <span class="number">3000</span> ) <span class="comment">// 给它3秒钟</span></span><br><span class="line">] ).then(</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">// foo(..)及时完成！ </span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     <span class="comment">// 或者foo()被拒绝，或者只是没能按时完成</span></span><br><span class="line">     <span class="comment">// 查看err来了解是哪种情况 </span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5.链式<br> 我们上面说了， 纯回调的一大痛点就是“金字塔回调地狱”， 这种“嵌套风格”的代码丑陋难懂，但Promise就可以把这种“嵌套”风格的代码改装成我们喜闻乐见的“链式”风格。因为then函数是可以链式调用的， 你的代码可以变成这样</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.then(</span><br><span class="line">  <span class="comment">// 第一个异步操作 </span></span><br><span class="line">).then(</span><br><span class="line">  <span class="comment">// 第二个异步操作 </span></span><br><span class="line">).then(</span><br><span class="line">  <span class="comment">// 第三个异步操作</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>6.门Promise.all，竞态Promise.race见后文</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。下面代码创造了一个Promise实例。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</strong></p>
<p>下面是一个Promise对象的简单例子。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p>
<p>下面是一个用Promise对象实现的 Ajax 操作的例子。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，<strong>resolve函数和reject函数调用时，都带有参数。</strong></p>
<h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h5><p>前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getJSON(&quot;&#x2F;post&#x2F;1.json&quot;).then(</span><br><span class="line">  post &#x3D;&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments &#x3D;&gt; console.log(&quot;resolved: &quot;, comments),</span><br><span class="line">  err &#x3D;&gt; console.log(&quot;rejected: &quot;, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h5><p><strong>Promise.prototype.catch方法是.then(null, rejection)的别名</strong>，用于指定发生错误时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))</span><br><span class="line">  .catch((err) &#x3D;&gt; console.log(&#39;rejected&#39;, err));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">p.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))</span><br><span class="line">  .then(null, (err) &#x3D;&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>

<p>下面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">finally</span>(server.stop);</span><br></pre></td></tr></table></figure>

<p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">500</span>, <span class="string">'P1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, <span class="number">600</span>, <span class="string">'P2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。</p>
<h3 id="2-6-4-生成器generator"><a href="#2-6-4-生成器generator" class="headerlink" title="2.6.4 生成器generator"></a>2.6.4 生成器generator</h3><p>生成器是一种能够暂停函数执行的函数， 使用<code>function *</code>定义, <code>yield</code>指定执行时候的暂停位置，<code>yield</code>会产出一个值作为<code>it.next()</code>的结果， <code>yield</code>能够接收参数并作为<code>yield</code>暂停处的替代值</p>
<p>比如下述代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = x * (<span class="keyword">yield</span>);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"><span class="keyword">var</span> res = it.next(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.value);</span><br></pre></td></tr></table></figure>

<p>第一个next(..)总是启动一个生成器，并运行到第一个yield处。不过，是第二个next(..)调用完成第一个被暂停的yield表达式，第三个next(..)调用完成第二个yield，以此类推。</p>
<p>通过多个生成器在共享的相同变量上的迭代交替执行，会使得程序可能产生多种不同的结果</p>
<p>比如以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  b = b * a;</span><br><span class="line">  a = (<span class="keyword">yield</span> b) + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b--;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  a = (<span class="keyword">yield</span> <span class="number">8</span>) + b;</span><br><span class="line">  b = a * (<span class="keyword">yield</span> <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以为两个生成器共享变量a和b，如果使用next()函数对两个生成器的实例进行迭代的时候的执行顺序不同会导致a和b最终的值不同,这在传统的函数中是不可能的，传统的函数是一个函数的执行必须等待上一个函数执行完毕,比如:</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  b = b * a;</span><br><span class="line">  a = b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  b--;</span><br><span class="line">  a = <span class="number">8</span> + b;</span><br><span class="line">  b = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要么foo()先执行，要么bar()先执行，不可能交替执行</span></span><br></pre></td></tr></table></figure>

<p><strong>异步迭代生成器</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, cb</span>)</span>&#123;</span><br><span class="line">  ajax(<span class="string">"http://some.url"</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">11</span>, <span class="number">31</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">     <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用生成器来表达同样的任务流程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  ajax(<span class="string">"http://some.url"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      <span class="comment">// 向*main()抛出一个错误</span></span><br><span class="line">       it.throw(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用收到的data回复*main()的执行</span></span><br><span class="line">      it.next(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">vat it = main();</span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// 生成器使用yield进行流程控制，实现了暂停/阻塞</span></span><br></pre></td></tr></table></figure>

<p><strong>同步错误处理</strong></p>
<p>生成器yield暂停的特性意味着我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误！在异步代码中实现看似同步的错误处理（通过try..catch）在可读性和合理性方面都是一个巨大的进步。</p>
<p><strong>生成器+Promise</strong></p>
<p>看似同步的异步代码（生成器）+ 可信任(Promise)是完美的搭配</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把支持Promise的foo和生成器main放在一起</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"><span class="keyword">var</span> p = it.next().value;</span><br><span class="line"><span class="comment">// 监测promise状态，在promise决议后恢复生成器执行</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  it.next(text);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  it.throw(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>封装Generator Runner</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), it;</span><br><span class="line">  <span class="comment">// 在当前上下文中初始化生成器</span></span><br><span class="line">  it = gen.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个promise用于生成器完成</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  				.then(<span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    			  <span class="comment">// 对下一个yield出的值运行</span></span><br><span class="line">     				<span class="keyword">var</span> next = it.next(value);</span><br><span class="line">    			  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">              <span class="comment">// 判断生成器是否运行完成</span></span><br><span class="line">              <span class="keyword">if</span>(next.done)&#123;</span><br><span class="line">                 <span class="keyword">return</span> next.value;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 生成器还没有运行完成，继续运行，将promise的决议值发回生成器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">                    .then(handleNext, <span class="function"><span class="keyword">function</span> <span class="title">handleErr</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                 				<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(it.throw(err)).</span><br><span class="line">                        				then(handleResult);</span><br><span class="line">                		&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)(next);</span><br><span class="line">  				&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成器中的Promise并发</strong></p>
<p>想像这样一个场景：你需要从不同的来源数据获取数据，然后把响应结合在一起以形成第三个请求，最终把最后一条响应打印出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="keyword">yield</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    request(<span class="string">"http://some.url1"</span>),</span><br><span class="line">    request(<span class="string">"http://some.url2"</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">var</span> [a,b]=result;</span><br><span class="line">  <span class="keyword">var</span> r=<span class="keyword">yield</span> request(<span class="string">"http://some.url30"</span>+a+<span class="string">","</span>+b);</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;</span><br><span class="line">run(foo);</span><br></pre></td></tr></table></figure>

<ol>
<li>使用了Promise.all()来实现了两个请求的并发。</li>
<li>[a,b]是ES6的解析赋值，把var a=…var b=…赋值语句简化为var [a,b[=result。</li>
<li>最后使用了上面定义的run()来执行生成器。</li>
</ol>
<p><strong>生成器委托</strong></p>
<p>我们可能会从一个生成器中调用另一个生成器</p>
<p>我们可以使用之前封装的自动运行生成器函数来实现生成器内调用其他生成器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     resolve(<span class="string">`<span class="subst">$&#123;url&#125;</span> request success!`</span>);</span><br><span class="line">   &#125;, <span class="number">1000</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.2"</span>);</span><br><span class="line">  <span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.3"</span>);</span><br><span class="line">  <span class="keyword">return</span> [r2, r3];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> request(<span class="string">"http://some.url.1"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1);</span><br><span class="line">  <span class="keyword">let</span> [r2,r3] = <span class="keyword">yield</span> run(foo);</span><br><span class="line">  <span class="built_in">console</span>.log(r2);</span><br><span class="line">  <span class="built_in">console</span>.log(r3);</span><br><span class="line">&#125;</span><br><span class="line">run(bar);</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>yield *</code>来实现生成器委托<code>yield *foo()</code></p>
<p>yield ＊暂停了迭代控制，而不是生成器控制。当你调用＊foo()生成器时，现在yield委托到了它的迭代器。但实际上，你可以yield委托到任意<strong>iterable</strong>, yield ＊[1,2,3]会消耗数组值[1,2,3]的默认迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">num</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = num();</span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>生成器委托可以进行双向消息传递(利用<code>next()</code>和<code>yield</code>)</p>
</li>
<li><p>异常也会被委托</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error caught inside *foo():"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"D"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> *foo();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"error caught insdie *bar():"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"E"</span>;</span><br><span class="line">    <span class="keyword">yield</span> *baz();</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"G"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next().value); <span class="comment">// outside: A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next(<span class="number">1</span>).value); <span class="comment">// outside: B</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.throw(<span class="number">2</span>).value); <span class="comment">// error caught inside *foo():2 \n outside: C</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outside:"</span>, it.next(<span class="number">3</span>).value);  <span class="comment">// error caught inside *bar(): D \n outside: E</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cconsole.log(<span class="string">"outside:"</span>, it.next(<span class="number">4</span>).value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error caught outside"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error caught outside: F</span></span><br></pre></td></tr></table></figure>

<p>(1) 调用it.throw(2)时，它会发送错误消息2到＊bar()，它又将其委托给＊foo()，后者捕获并处理它。然后，yield “C”把”C”发送回去作为it.throw(2)调用返回的value。</p>
<p>(2) 接下来从＊foo()内throw出来的值”D”传播到＊bar()，这个函数捕获并处理它。然后yield”E”把”E”发送回去作为it.next(3)调用返回的value。</p>
<p>(3) 然后，从＊baz() throw出来的异常并没有在＊bar()内被捕获——所以＊baz()和＊bar()都被设置为完成状态。这段代码之后，就再也无法通过任何后续的next(..)调用得到值”G”, next(..)调用只会给value返回undefined</p>
</li>
<li><p>并发委托</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;url&#125;</span> request success!!`</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runAllGen = (...genArr) = &#123;</span><br><span class="line">  <span class="keyword">const</span> itArr = [],</span><br><span class="line">        pArr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> gen <span class="keyword">of</span> genArr)&#123;</span><br><span class="line">    <span class="keyword">const</span> it = gen();</span><br><span class="line">    itArr.push(it);</span><br><span class="line">    <span class="keyword">const</span> p = it.next().value;</span><br><span class="line">    pArr.push(p);</span><br><span class="line">    p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      it.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Promise</span>.all([...pArr])</span><br><span class="line">		.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> it <span class="keyword">of</span> itArr)&#123;</span><br><span class="line">      it.next();</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">runAllgen(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.1"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.2"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">yield</span> request(<span class="string">"http://some.url.3"</span>);</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">  res.push(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-6-5-性能测试与调优"><a href="#2-6-5-性能测试与调优" class="headerlink" title="2.6.5 性能测试与调优"></a>2.6.5 性能测试与调优</h3><p>使用Benchmark.js和jsPerf分析代码性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> benchmark = <span class="built_in">require</span>(<span class="string">"benchmark"</span>);</span><br><span class="line"><span class="keyword">var</span> suite = <span class="keyword">new</span> benchmark.Suite;</span><br><span class="line"></span><br><span class="line">suite.add(<span class="string">'RegExp'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    /o/.test(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">'indexOf'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="string">'Hello World'</span>.indexOf(<span class="string">'o'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the fasted method is'</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.run(&#123;<span class="string">'async'</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RegExp x 33,125,825 ops/sec ±4.06% (77 runs sampled)</span></span><br><span class="line"><span class="comment">indexOf x 797,631,820 ops/sec ±1.69% (87 runs sampled)</span></span><br><span class="line"><span class="comment">the fasted method isindexOf</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>是函数式编程一个概念，是指某个函数最后一步是调用另一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</span></span><br></pre></td></tr></table></figure>

<p>以下两种情况都不属于尾调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数调用会在内存生成一个”调用记录“，又称为”调用帧(call frame)“，保存调用位置和内部变量等信息，如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="http://zh.wikipedia.org/wiki/调用栈" target="_blank" rel="noopener">“调用栈”</a>（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>尾递归</strong></p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<blockquote>
<ul>
<li><code>arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
</blockquote>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<p><strong>递归函数的改写</strong></p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">柯里化</a>（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>
<p>第二种方法就简单多了，就是采用ES6的函数默认值。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持”尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS知识点整理</title>
    <url>/2020/05/16/2020-2020-05-16-CSS%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-基础概念"><a href="#一-基础概念" class="headerlink" title="一. 基础概念"></a>一. 基础概念</h1><h2 id="1-1-什么是CSS"><a href="#1-1-什么是CSS" class="headerlink" title="1.1 什么是CSS"></a>1.1 什么是<a href="https://www.w3.org/TR/CSS2/" target="_blank" rel="noopener">CSS</a></h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。</p>
<h2 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12</span>p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-选择器"><a href="#1-3-选择器" class="headerlink" title="1.3 选择器"></a>1.3 选择器</h2><p>根据规则选取页面中的dom元素, 包含以下选择器分类:</p>
<table>
<thead>
<tr>
<th>.class</th>
<th>.intro</th>
<th>选择所有class=“intro”的元素</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>#id</td>
<td>#firstname</td>
<td>选择所有id=“firstname”的元素</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>选择所有元素</td>
<td>2</td>
</tr>
<tr>
<td>element</td>
<td>p</td>
<td>选择所有元素</td>
<td>1</td>
</tr>
<tr>
<td>element,element</td>
<td>div,p</td>
<td>选择所有元素和元素</td>
<td>1</td>
</tr>
<tr>
<td>element element</td>
<td>div p</td>
<td>选择元素内的所有元素</td>
<td>1</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>div&gt;p</td>
<td>选择所有父级是元素的元素</td>
<td>2</td>
</tr>
<tr>
<td>element+element</td>
<td>div+p</td>
<td>选择所有紧接着元素之后的元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute]</td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>[target=-blank]</td>
<td>选择所有使用target=“-blank”的元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词”flower”的所有元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute</td>
<td>=language]</td>
<td>[lang</td>
<td>=en]</td>
</tr>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问链接</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
<td>1</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择活动链接</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
<td>1</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
<td>2</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每一个元素的第一个字母</td>
<td>1</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每一个元素的第一行</td>
<td>1</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>指定只有当元素是其父级的第一个子级的样式。</td>
<td>2</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个元素之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个元素之后插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值=“it”的所有元素</td>
<td>2</td>
</tr>
<tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=“https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=“.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=“axihe”]</td>
<td>选择每一个src属性的值包含子字符串”axihe”的元素</td>
<td>3</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
<td>3</td>
</tr>
<tr>
<td>:root</td>
<td>:root</td>
<td>选择文档的根元素</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
<td>3</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
<td>3</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
<td>3</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range</td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-write</td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-only</td>
<td>:read-only</td>
<td>用于匹配设置 “readonly”（只读） 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:optional</td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:required</td>
<td>:required</td>
<td>用于匹配设置了 “required” 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid</td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
<td>3</td>
</tr>
<tr>
<td>:invalid</td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="1-4-插入样式表的方法"><a href="#1-4-插入样式表的方法" class="headerlink" title="1.4 插入样式表的方法"></a>1.4 插入样式表的方法</h2><p>插入样式表的方法有三种:</p>
<ul>
<li>外部样式表(External style sheet)</li>
<li>内部样式表(Internal style sheet)</li>
<li>内联样式(Inline style)</li>
</ul>
<h2 id="1-5-样式优先级"><a href="#1-5-样式优先级" class="headerlink" title="1.5 样式优先级"></a>1.5 样式优先级</h2><p><strong>内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p>
<p>优先级逐级增加的选择器列表:</p>
<ul>
<li>通用选择器（*）</li>
<li>元素(类型)选择器</li>
<li>类选择器</li>
<li>属性选择器</li>
<li>伪类</li>
<li>ID 选择器</li>
<li>内联样式</li>
</ul>
<p>经验法则:</p>
<ul>
<li><strong>Always</strong> 要优化考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li>
<li><strong>Only</strong> 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 <code>!important</code></li>
<li><strong>Never</strong> 永远不要在全站范围的 css 上使用<code>!important</code></li>
<li><strong>Never</strong> 永远不要在你的插件中使用 <code>!important</code></li>
</ul>
<p><strong>权重的计算</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2017/06/jc6_002_thumb.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#redP</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">             <span class="comment">/* 权值 = 100+1=101 */</span></span></span><br><span class="line"><span class="css">             <span class="selector-tag">color</span>:<span class="selector-id">#F00</span>;  <span class="comment">/* 红色 */</span></span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="css">        <span class="selector-id">#redP</span> <span class="selector-class">.red</span> <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="css">             <span class="comment">/* 权值 = 100+10+1=111 */</span></span></span><br><span class="line"><span class="css">             <span class="selector-tag">color</span>:<span class="selector-id">#00F</span>; <span class="comment">/* 蓝色 */</span></span></span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="css">        <span class="selector-id">#redP</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span> <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="css">             <span class="comment">/* 权值 = 100+1+1+1=103 */</span></span></span><br><span class="line"><span class="css">             <span class="selector-tag">color</span>:<span class="selector-id">#FF0</span>;<span class="comment">/*黄色*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"redP"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>red</span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>em red<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>red<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="二-常用属性"><a href="#二-常用属性" class="headerlink" title="二. 常用属性"></a>二. 常用属性</h1><h2 id="2-1-background"><a href="#2-1-background" class="headerlink" title="2.1 background"></a>2.1 background</h2><p>background的值的顺序是background-color，background-image，background-repeat，background-attachment，background-position,background-size。</p>
<p>如果用background-size,一定要用/分隔</p>
<p>定义背景效果</p>
<table>
<thead>
<tr>
<th><a href="https://www.axihe.com/api/css/background/css3-pr-background.html" target="_blank" rel="noopener">background</a></th>
<th>复合属性。设置对象的背景特性。</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.axihe.com/api/css/background/pr-background-attachment.html" target="_blank" rel="noopener">background-attachment</a></td>
<td>设置或检索背景图像是随对象内容滚动还是固定的。必须先指定background-image属性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/pr-background-color.html" target="_blank" rel="noopener">background-color</a></td>
<td>设置或检索对象的背景颜色。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/pr-background-image.html" target="_blank" rel="noopener">background-image</a></td>
<td>设置或检索对象的背景图像。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/pr-background-position.html" target="_blank" rel="noopener">background-position</a></td>
<td>设置或检索对象的背景图像位置。必须先指定background-image属性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/pr-background-repeat.html" target="_blank" rel="noopener">background-repeat</a></td>
<td>设置或检索对象的背景图像如何铺排填充。必须先指定background-image属性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/css3-pr-background-clip.html" target="_blank" rel="noopener">background-clip</a></td>
<td>指定对象的背景图像向外裁剪的区域。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/css3-pr-background-origin.html" target="_blank" rel="noopener">background-origin</a></td>
<td>S设置或检索对象的背景图像计算background-position时的参考原点(位置)。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/background/css3-pr-background-size.html" target="_blank" rel="noopener">background-size</a></td>
<td>检索或设置对象的背景图像的尺寸大小。</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="2-2-文本属性"><a href="#2-2-文本属性" class="headerlink" title="2.2 文本属性"></a>2.2 文本属性</h2><table>
<thead>
<tr>
<th><a href="https://www.runoob.com/cssref/pr-text-color.html" target="_blank" rel="noopener">color</a></th>
<th>设置文本颜色</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/cssref/pr-text-direction.html" target="_blank" rel="noopener">direction</a></td>
<td>设置文本方向。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-letter-spacing.html" target="_blank" rel="noopener">letter-spacing</a></td>
<td>设置字符间距</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-dim-line-height.html" target="_blank" rel="noopener">line-height</a></td>
<td>设置行高</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-align.html" target="_blank" rel="noopener">text-align</a></td>
<td>对齐元素中的文本</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-decoration.html" target="_blank" rel="noopener">text-decoration</a></td>
<td>向文本添加修饰</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-indent.html" target="_blank" rel="noopener">text-indent</a></td>
<td>缩进元素中文本的首行</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-text-shadow.html" target="_blank" rel="noopener">text-shadow</a></td>
<td>设置文本阴影</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-text-transform.html" target="_blank" rel="noopener">text-transform</a></td>
<td>控制元素中的字母</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-unicode-bidi.html" target="_blank" rel="noopener">unicode-bidi</a></td>
<td>设置或返回文本是否被重写</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-pos-vertical-align.html" target="_blank" rel="noopener">vertical-align</a></td>
<td>设置元素的垂直对齐</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-white-space.html" target="_blank" rel="noopener">white-space</a></td>
<td>设置元素中空白的处理方式</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/pr-text-word-spacing.html" target="_blank" rel="noopener">word-spacing</a></td>
<td>设置字间距</td>
</tr>
</tbody></table>
<h2 id="2-3-字体Font"><a href="#2-3-字体Font" class="headerlink" title="2.3 字体Font"></a>2.3 字体Font</h2><h3 id="2-3-1-CSS字形"><a href="#2-3-1-CSS字形" class="headerlink" title="2.3.1 CSS字形"></a>2.3.1 CSS字形</h3><p><img src="https://www.runoob.com/images/serif.gif" alt="Serif vs. Sans-serif"></p>
<p>Scans-serif: 无衬线</p>
<p>Serif: 有称线</p>
<ul>
<li><strong>通用字体系列</strong> - 拥有相似外观的字体系统组合（如 “Serif” 或 “Monospace”）</li>
<li><strong>特定字体系列</strong> - 一个特定的字体系列（如 “Times” 或 “Courier”）</li>
</ul>
<table>
<thead>
<tr>
<th>Serif</th>
<th>Times New Roman Georgia</th>
<th>Serif字体中字符在行的末端拥有额外的装饰</th>
</tr>
</thead>
<tbody><tr>
<td>Sans-serif</td>
<td>Arial Verdana</td>
<td>“Sans”是指无 - 这些字体在末端没有额外的装饰</td>
</tr>
<tr>
<td>Monospace</td>
<td>Courier New Lucida Console</td>
<td>所有的<strong>等宽字符</strong>具有相同的宽度</td>
</tr>
</tbody></table>
<h3 id="2-3-2-字体系列"><a href="#2-3-2-字体系列" class="headerlink" title="2.3.2 字体系列"></a>2.3.2 字体系列</h3><p>font-family 属性设置文本的字体系列。</p>
<p>font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。</p>
<p><strong>注意</strong>: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：”宋体”</p>
<p><code>p{font-family:&quot;Times New Roman&quot;, Times, serif;}</code></p>
<h3 id="2-3-3-字体样式"><a href="#2-3-3-字体样式" class="headerlink" title="2.3.3 字体样式"></a>2.3.3 字体样式</h3><ul>
<li>正常（normal） - 正常显示文本</li>
<li>斜体(italic) - 以斜体字显示的文字</li>
<li>倾斜的文字(oblique) - 文字向一边倾斜（和斜体非常类似，但不太支持）</li>
</ul>
<h3 id="2-3-4-字体大小"><a href="#2-3-4-字体大小" class="headerlink" title="2.3.4 字体大小"></a>2.3.4 字体大小</h3><p>绝对大小：</p>
<ul>
<li>设置一个指定大小的文本</li>
<li>不允许用户在所有浏览器中改变文本大小</li>
<li>确定了输出的物理尺寸时绝对大小很有用</li>
</ul>
<p>相对大小：</p>
<ul>
<li>相对于周围的元素来设置大小</li>
<li>允许用户在浏览器中改变文字大小</li>
</ul>
<table>
<thead>
<tr>
<th><a href="https://www.axihe.com/api/css/font/pr-font-font.html" target="_blank" rel="noopener">font</a></th>
<th>在一个声明中设置所有字体属性</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.axihe.com/api/css/font/pr-font-font-family.html" target="_blank" rel="noopener">font-family</a></td>
<td>规定文本的字体系列</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/pr-font-font-size.html" target="_blank" rel="noopener">font-size</a></td>
<td>规定文本的字体尺寸</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/pr-font-font-style.html" target="_blank" rel="noopener">font-style</a></td>
<td>规定文本的字体样式</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/pr-font-font-variant.html" target="_blank" rel="noopener">font-variant</a></td>
<td>规定文本的字体样式</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/pr-font-weight.html" target="_blank" rel="noopener">font-weight</a></td>
<td>规定字体的粗细</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/css3-pr-font-face-rule.html" target="_blank" rel="noopener">@font-face</a></td>
<td>一个规则，允许网站下载并使用其他超过”Web- safe”字体的字体</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/css3-pr-font-size-adjust.html" target="_blank" rel="noopener">font-size-adjust</a></td>
<td>为元素规定 aspect 值</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/font/css3-pr-font-stretch.html" target="_blank" rel="noopener">font-stretch</a></td>
<td>收缩或拉伸当前的字体系列</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="2-4-边框-Border-和-轮廓-Outline"><a href="#2-4-边框-Border-和-轮廓-Outline" class="headerlink" title="2.4 边框 (Border) 和 轮廓 (Outline)"></a>2.4 边框 (Border) 和 轮廓 (Outline)</h2><table>
<thead>
<tr>
<th><a href="https://www.axihe.com/api/css/border/pr-border.html" target="_blank" rel="noopener">border</a></th>
<th>复合属性。设置对象边框的特性。</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-bottom.html" target="_blank" rel="noopener">border-bottom</a></td>
<td>复合属性。设置对象底部边框的特性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-bottom-color.html" target="_blank" rel="noopener">border-bottom-color</a></td>
<td>设置或检索对象的底部边框颜色。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-bottom-style.html" target="_blank" rel="noopener">border-bottom-style</a></td>
<td>设置或检索对象的底部边框样式。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-bottom-width.html" target="_blank" rel="noopener">border-bottom-width</a></td>
<td>设置或检索对象的底部边框宽度。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-color.html" target="_blank" rel="noopener">border-color</a></td>
<td>置或检索对象的边框颜色。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-left.html" target="_blank" rel="noopener">border-left</a></td>
<td>复合属性。设置对象左边边框的特性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-left-color.html" target="_blank" rel="noopener">border-left-color</a></td>
<td>设置或检索对象的左边边框颜色。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-left-style.html" target="_blank" rel="noopener">border-left-style</a></td>
<td>设置或检索对象的左边边框样式。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-left-width.html" target="_blank" rel="noopener">border-left-width</a></td>
<td>设置或检索对象的左边边框宽度。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-righ.html" target="_blank" rel="noopener">border-rig</a>ht</td>
<td>复合属性。设置对象右边边框的特性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-right-color.html" target="_blank" rel="noopener">border-right-color</a></td>
<td>设置或检索对象的右边边框颜色。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-right-style.html" target="_blank" rel="noopener">border-right-style</a></td>
<td>设置或检索对象的右边边框样式。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-right-width.html" target="_blank" rel="noopener">border-right-width</a></td>
<td>设置或检索对象的右边边框宽度。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-style.html" target="_blank" rel="noopener">border-style</a></td>
<td>设置或检索对象的边框样式。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-top.html" target="_blank" rel="noopener">border-top</a></td>
<td>复合属性。设置对象顶部边框的特性。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-top-color.html" target="_blank" rel="noopener">border-top-color</a></td>
<td>设置或检索对象的顶部边框颜色</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-top-style.html" target="_blank" rel="noopener">border-top-style</a></td>
<td>设置或检索对象的顶部边框样式。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-top-width.html" target="_blank" rel="noopener">border-top-width</a></td>
<td>设置或检索对象的顶部边框宽度。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-border-width.html" target="_blank" rel="noopener">border-width</a></td>
<td>设置或检索对象的边框宽度。</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-outline.html" target="_blank" rel="noopener">outline</a></td>
<td>复合属性。设置或检索对象外的线条轮廓。</td>
<td>2</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-outline-color.html" target="_blank" rel="noopener">outline-color</a></td>
<td>设置或检索对象外的线条轮廓的颜色。</td>
<td>2</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-outline-style.html" target="_blank" rel="noopener">outline-style</a></td>
<td>设置或检索对象外的线条轮廓的样式。</td>
<td>2</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/pr-outline-width.html" target="_blank" rel="noopener">outline-width</a></td>
<td>设置或检索对象外的线条轮廓的宽度。</td>
<td>2</td>
</tr>
<tr>
<td>border-bottom-left-radius</td>
<td>设置或检索对象的左下角圆角边框。 提供 2 个参数，2 个参数以空格分隔， 每个参数允许设置 1 个参数值， 第 1 个参数表示水平半径，第 2 个参数表示垂直半径， 如第 2 个参数省略，则默认等于第 1 个参数</td>
<td>3</td>
</tr>
<tr>
<td>border-bottom-right-radius</td>
<td>设置或检索对象的右下角圆角边框。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image.html" target="_blank" rel="noopener">border-image</a></td>
<td>设置或检索对象的边框样式使用图像来填充。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image-outset.html" target="_blank" rel="noopener">border-image-outset</a></td>
<td>规定边框图像超过边框的量。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image-repeat.html" target="_blank" rel="noopener">border-image-repeat</a></td>
<td>规定图像边框是否应该被重复（repeated）、拉伸（stretched）或铺满（rounded）。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image-slice.html" target="_blank" rel="noopener">border-image-slice</a></td>
<td>规定图像边框的向内偏移。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image-source.html" target="_blank" rel="noopener">border-image-source</a></td>
<td>规定要使用的图像，代替 border-style 属性中设置的边框样式。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-image-width.html" target="_blank" rel="noopener">border-image-width</a></td>
<td>规定图像边框的宽度。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/border/css3-pr-border-radius.html" target="_blank" rel="noopener">border-radius</a></td>
<td>设置或检索对象使用圆角边框。</td>
<td>3</td>
</tr>
<tr>
<td>border-top-left-radius</td>
<td>定义左上角边框的形状。</td>
<td>3</td>
</tr>
<tr>
<td>border-top-right-radius</td>
<td>定义右上角边框的形状。</td>
<td>3</td>
</tr>
<tr>
<td>box-decoration-break</td>
<td>规定行内元素被折行</td>
<td>3</td>
</tr>
<tr>
<td>box-shadow</td>
<td>向方框添加一个或多个阴影。</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="2-5-动画属性"><a href="#2-5-动画属性" class="headerlink" title="2.5 动画属性"></a>2.5 动画属性</h2><table>
<thead>
<tr>
<th><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-keyframes.html" target="_blank" rel="noopener">@keyframes</a></th>
<th>定义一个动画,@keyframes定义的动画名称用来被animation-name所使用。</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation.html" target="_blank" rel="noopener">animation</a></td>
<td>复合属性。检索或设置对象所应用的动画特效。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-name.html" target="_blank" rel="noopener">animation-name</a></td>
<td>检索或设置对象所应用的动画名称 ,必须与规则@keyframes配合使用，因为动画名称由@keyframes定义</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-duration.html" target="_blank" rel="noopener">animation-duration</a></td>
<td>检索或设置对象动画的持续时间</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-timing-function.html" target="_blank" rel="noopener">animation-timing-function</a></td>
<td>检索或设置对象动画的过渡类型</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-delay.html" target="_blank" rel="noopener">animation-delay</a></td>
<td>检索或设置对象动画的延迟时间</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-iteration-count.html" target="_blank" rel="noopener">animation-iteration-count</a></td>
<td>检索或设置对象动画的循环次数</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-direction.html" target="_blank" rel="noopener">animation-direction</a></td>
<td>检索或设置对象动画在循环中是否反向运动</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/animation/css3-pr-animation-play-state.html" target="_blank" rel="noopener">animation-play-state</a></td>
<td>检索或设置对象动画的状态</td>
<td>3</td>
</tr>
</tbody></table>
<h2 id="2-6-内边距"><a href="#2-6-内边距" class="headerlink" title="2.6 内边距"></a>2.6 内边距</h2><table>
<thead>
<tr>
<th><a href="https://www.axihe.com/api/css/padding/pr-padding.html" target="_blank" rel="noopener">padding</a></th>
<th>在一个声明中设置所有填充属性</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.axihe.com/api/css/padding/pr-padding-bottom.html" target="_blank" rel="noopener">padding-bottom</a></td>
<td>设置元素的底填充</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/padding/pr-padding-left.html" target="_blank" rel="noopener">padding-left</a></td>
<td>设置元素的左填充</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/padding/pr-padding-right.html" target="_blank" rel="noopener">padding-right</a></td>
<td>设置元素的右填充</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://www.axihe.com/api/css/padding/pr-padding-top.html" target="_blank" rel="noopener">padding-top</a></td>
<td>设置元素的顶部填充</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="2-7-链接样式"><a href="#2-7-链接样式" class="headerlink" title="2.7 链接样式"></a>2.7 链接样式</h2><ul>
<li>a:link - 正常，未访问过的链接</li>
<li>a:visited - 用户已访问过的链接</li>
<li>a:hover - 当用户鼠标放在链接上时</li>
<li>a:active - 链接被点击的那一刻</li>
</ul>
<p>顺序规则：</p>
<ul>
<li>a:hover 必须跟在 a:link 和 a:visited后面</li>
<li>a:active 必须跟在 a:hover后面</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#000000</span>;&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#00FF00</span>;&#125;  <span class="comment">/* 已访问链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#FF00FF</span>;&#125;  <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#0000FF</span>;&#125;  <span class="comment">/* 鼠标点击时 */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-列表样式-ul"><a href="#2-8-列表样式-ul" class="headerlink" title="2.8 列表样式(ul)"></a>2.8 列表样式(ul)</h2><p>CSS列表属性作用如下：</p>
<ul>
<li>设置不同的列表项标记为有序列表</li>
<li>设置不同的列表项标记为无序列表</li>
<li>设置列表项标记为图像</li>
</ul>
<p>在HTML中，有两种类型的列表：</p>
<ul>
<li>无序列表 - 列表项标记用特殊图形（如小黑点、小方框等）</li>
<li>有序列表 - 列表项的标记有数字或字母</li>
</ul>
<p>使用CSS，可以列出进一步的样式，并可用图像作列表项标记。</p>
<h3 id="2-8-1-作为列表项标记的图像"><a href="#2-8-1-作为列表项标记的图像" class="headerlink" title="2.8.1 作为列表项标记的图像"></a>2.8.1 作为列表项标记的图像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">            <span class="attribute">list-style</span>: disc inside <span class="built_in">url</span>(http://img5.imgtn.bdimg.com/it/u=<span class="number">2916716554</span>,<span class="number">654971401</span>&amp;fm=<span class="number">26</span>&amp;gp=<span class="number">0</span>.jpg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-所有的CSS列表属性"><a href="#2-8-2-所有的CSS列表属性" class="headerlink" title="2.8.2 所有的CSS列表属性"></a>2.8.2 所有的CSS列表属性</h3><table>
<thead>
<tr>
<th>list-style</th>
<th>简写属性。用于把所有用于列表的属性设置于一个声明中</th>
</tr>
</thead>
<tbody><tr>
<td>list-style-image</td>
<td>将图象设置为列表项标志。</td>
</tr>
<tr>
<td>list-style-position</td>
<td>设置列表中列表项标志的位置。</td>
</tr>
<tr>
<td>list-style-type</td>
<td>设置列表项标志的类型。</td>
</tr>
</tbody></table>
<h2 id="2-9-CSS-Table-表格"><a href="#2-9-CSS-Table-表格" class="headerlink" title="2.9 CSS Table(表格)"></a>2.9 CSS Table(表格)</h2><h3 id="2-9-1-表格边框"><a href="#2-9-1-表格边框" class="headerlink" title="2.9.1 表格边框"></a>2.9.1 表格边框</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-2-折叠边框"><a href="#2-9-2-折叠边框" class="headerlink" title="2.9.2 折叠边框"></a>2.9.2 折叠边框</h3><p>border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-3-表格宽度和高度"><a href="#2-9-3-表格宽度和高度" class="headerlink" title="2.9.3  表格宽度和高度"></a>2.9.3  表格宽度和高度</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-4-表格文字对齐"><a href="#2-9-4-表格文字对齐" class="headerlink" title="2.9.4 表格文字对齐"></a>2.9.4 表格文字对齐</h3><p>表格中的文本对齐和垂直对齐属性。</p>
<p>text-align属性设置水平对齐方式，向左，右，或中心：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>:right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>垂直对齐属性设置垂直对齐，比如顶部，底部或中间：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>:bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-5-表格填充"><a href="#2-9-5-表格填充" class="headerlink" title="2.9.5 表格填充"></a>2.9.5 表格填充</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-6-表格颜色"><a href="#2-9-6-表格颜色" class="headerlink" title="2.9.6 表格颜色"></a>2.9.6 表格颜色</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span>, <span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-10-CSS-盒子模型"><a href="#2-10-CSS-盒子模型" class="headerlink" title="2.10 CSS 盒子模型"></a>2.10 CSS 盒子模型</h2><p>在HTML中的每个element(元素)都可以看作一个矩形的盒子，矩形从内到外依次由元素的内容(content)、内边距(padding)、边框(border)、外边距(margin)组成。</p>
<p>在CSS的布局中，元素的矩形被称为”Box Model”，即盒子模型。在浏览器渲染页面时，盒子模型决定了元素的大小和位置。</p>
<p><img src="https://a.axihe.com/img/css/box-model.gif" alt="CSS box-model"></p>
<ul>
<li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li>
<li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li>
<li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li>
<li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li>
</ul>
<h3 id="2-10-1-元素的宽度和高度"><a href="#2-10-1-元素的宽度和高度" class="headerlink" title="2.10.1 元素的宽度和高度"></a>2.10.1 元素的宽度和高度</h3><p><strong>CSS 框模型 (Box Model) 规定了元素框处理元素内容、<a href="https://www.w3school.com.cn/css/css_padding.asp" target="_blank" rel="noopener">内边距</a>、<a href="https://www.w3school.com.cn/css/css_border.asp" target="_blank" rel="noopener">边框</a> 和 <a href="https://www.w3school.com.cn/css/css_margin.asp" target="_blank" rel="noopener">外边距</a> 的方式。</strong></p>
<p> <img src="https://www.w3school.com.cn/i/ct_boxmodel.gif" alt=""></p>
<p>元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。</p>
<h3 id="2-10-2-浏览器的兼容性问题"><a href="#2-10-2-浏览器的兼容性问题" class="headerlink" title="2.10.2 浏览器的兼容性问题"></a>2.10.2 浏览器的兼容性问题</h3><p>内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的 margin 和 padding 设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。</p>
<p>在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>假设框的每个边上有 10 个像素的外边距和 5 个像素的内边距。如果希望这个元素框达到 100 个像素，就需要将内容的宽度设置为 70 像素，请看下图：</p>
<p><img src="https://www.w3school.com.cn/i/ct_css_boxmodel_example.gif" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-3-获取DOM元素宽高的属性"><a href="#2-10-3-获取DOM元素宽高的属性" class="headerlink" title="2.10.3 获取DOM元素宽高的属性"></a>2.10.3 获取DOM元素宽高的属性</h3><p>在DOM中，获取元素高宽有以下属性：clientWidth/clientHeight、offsetWidth/offsetHeight、scrollWidth/scrollHeight</p>
<p>clientWidth、clientHeight:</p>
<p><strong>说明</strong>：包含内边距、内容区域的宽度、高度；若含有滚动条，将会减去滚动条的宽度、高度。</p>
<p><strong>公式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.clientWidth &#x3D; padding-left + width + padding-right</span><br><span class="line">element.clientHeight &#x3D; padding-top + height + padding-bottom</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/153475/201804/153475-20180410224639868-1759907132.png" alt=""></p>
<p>offsetWidth、offsetHeight:</p>
<p><strong>说明</strong>：包含了边框、内边距、内容区域以及滚动条等范围的宽度、高度。</p>
<p><strong>公式</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.offsetWidth = border-left + padding-left + width + padding-right + border-right</span><br><span class="line">element.offsetHeight = border-top + padding-top + height + padding-bottom + border-bottom</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/153475/201804/153475-20180410225551052-1162485476.png" alt=""></p>
<p>scrollWidth、scrollHeight</p>
<p><strong>说明</strong>：与clientWidth、clientHeight类似(包含内边距、内容区域，但不包括滚动条)，不同的是scrollWidth、scrollHeight与元素的overflow样式属性息息相关：</p>
<p>当块级元素的内容超出元素大小时，其内容会根据overflow设定的值出现滚动条或内容溢出，scrollWidth、scrollHeight包含了这些不可见的内容区域。</p>
<p><img src="https://images2018.cnblogs.com/blog/153475/201804/153475-20180410231612061-1829861357.png" alt=""></p>
<h3 id="2-10-4-box-sizing"><a href="#2-10-4-box-sizing" class="headerlink" title="2.10.4 box-sizing"></a>2.10.4 box-sizing</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>属性含义</th>
</tr>
</thead>
<tbody><tr>
<td>Content-box</td>
<td><strong>说明</strong>：表示CSS中的width和height属性的值只会应用到元素的内容区域。将采用标准模式**<em>\</em>解析计算，也是默认模式</td>
</tr>
<tr>
<td>Border-box</td>
<td>表示元素的边框和内边距的范围包含在CSS中的width、height内。将采用怪异模式进行计算</td>
</tr>
</tbody></table>
<p>注意： 两种盒子模型都不将margin计算在内</p>
<h3 id="2-10-5-jQuery中元素宽度-高度"><a href="#2-10-5-jQuery中元素宽度-高度" class="headerlink" title="2.10.5 jQuery中元素宽度(高度)"></a>2.10.5 jQuery中元素宽度(高度)</h3><p><strong>$(element).width()</strong>：获取元素content(内容)区域的宽度。若元素的含有 box-sizing: border-box ，会减去相应的padding、boder。</p>
<p><strong>$(element).innerWidth()</strong>：获取元素 content区域 + padding 的宽度。</p>
<p><strong>$(element).outerWidth()</strong>：获取元素 content区域 + padding + boder 的宽度。</p>
<p><strong>$(element).outerWidth(true)</strong>：获取元素 content区域 + padding + boder + margin 的宽度。</p>
<h2 id="2-11-CSS-margin-外边距"><a href="#2-11-CSS-margin-外边距" class="headerlink" title="2.11 CSS margin(外边距)"></a>2.11 CSS margin(外边距)</h2><table>
<thead>
<tr>
<th>margin</th>
<th>简写属性。在一个声明中设置所有外边距属性。</th>
</tr>
</thead>
<tbody><tr>
<td>margin-bottom</td>
<td>设置元素的下外边距。</td>
</tr>
<tr>
<td>margin-left</td>
<td>设置元素的左外边距。</td>
</tr>
<tr>
<td>margin-right</td>
<td>设置元素的右外边距。</td>
</tr>
<tr>
<td>margin-top</td>
<td>设置元素的上外边距。</td>
</tr>
</tbody></table>
<h3 id="2-11-1-CSS-外边距合并"><a href="#2-11-1-CSS-外边距合并" class="headerlink" title="2.11.1 CSS 外边距合并"></a>2.11.1 CSS 外边距合并</h3><p><strong>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。</strong></p>
<p><strong>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</strong></p>
<p><img src="https://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif" alt=""></p>
<p>尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。</p>
<p>假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：</p>
<p><img src="https://www.w3school.com.cn/i/ct_css_margin_collapsing_example_3.gif" alt=""></p>
<p>如果这个外边距遇到另一个元素的外边距，它还会发生合并：</p>
<p><img src="https://www.w3school.com.cn/i/ct_css_margin_collapsing_example_4.gif" alt=""></p>
<p>这就是一系列的段落元素占用空间非常小的原因，因为它们的所有外边距都合并到一起，形成了一个小的外边距。外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。</p>
<p>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p>
<h3 id="2-11-2-BFC"><a href="#2-11-2-BFC" class="headerlink" title="2.11.2 BFC"></a>2.11.2 BFC</h3><p><strong>Box：</strong>CSS渲染的时候是以Box作为渲染的基本单位。Box的类型由元素的类型和display属性决定，box的类型分为block-level box 和inline-level box（不包括css3的时候）。不同类型的box参与不同类型的formatting context布局。</p>
<p>所谓的 Formatting context(格式化上下文), 它是 W3C CSS2.1 规范中的一个概念。</p>
<blockquote>
<p>它是页面中的一块渲染区域，并且有一套渲染规则.<br>它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>
</blockquote>
<p>而 Block Formatting Contexts (BFC，块级格式化上下文)，就是 一个块级元素 的渲染显示规则。通俗一点讲，可以把 BFC 理解为一个封闭的大箱子，，容器里面的子元素不会影响到外面的元素，反之也如此。</p>
<p>  1 内部的盒子会在垂直方向，一个个地放置；<br>  2 BFC是页面上的一个隔离的独立容器；<br>  3 属于<strong>同一个BFC</strong>的 两个<strong>相邻Box</strong>的 <strong>上下margin</strong>会发生重叠 ；<br>  4 计算BFC的高度时，浮动元素也参与计算<br>  5 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；<br>  6 BFC的区域不会与float重叠；</p>
<p>那么如何触发 BFC呢？只要元素满足下面任一条件即可触发 BFC 特性：</p>
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h3 id="2-11-3-BFC的特性及应用"><a href="#2-11-3-BFC的特性及应用" class="headerlink" title="2.11.3 BFC的特性及应用"></a>2.11.3 BFC的特性及应用</h3><ol>
<li>同一个 BFC下外边距 会发生折叠</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">.p &#123;  </span><br><span class="line">  width:200px;  </span><br><span class="line">  height:50px;  </span><br><span class="line">  margin:50px 0;  </span><br><span class="line">  background-color:red;  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div class&#x3D;&quot;p&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">   &lt;div class&#x3D;&quot;p&quot;&gt;&lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20170610233517221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3MjgzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>盒子垂直方向的距离由margin决定，<br>属于 同一个BFC的 + 两个相邻Box的 + 上下margin 会发生重叠<br>上文的例子 之所以发生外边距折叠，是因为他们 同属于 body这个根元素， 所以我们需要让 它们 <strong>不属于同一个BFC</strong>，就能避免外边距折叠：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wrap</span> &#123;  </span><br><span class="line">  <span class="attribute">overflow</span>:hidden;  </span><br><span class="line"></span><br><span class="line">.p &#123;  </span><br><span class="line">  <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;  </span><br><span class="line">  <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;  </span><br><span class="line">  <span class="selector-tag">margin</span><span class="selector-pseudo">:50px</span> 0;  </span><br><span class="line">  <span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20170610233600987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3MjgzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ol start="2">
<li><p>BFC可以包含浮动的元素（清除浮动）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"border: 1px solid #000;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 50px; height: 50px; background: #eee;</span></span></span><br><span class="line"><span class="tag"><span class="string">               float: left;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>外层的div会无法包含 内部浮动的div，效果见下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_hd.jpg" alt=""></p>
<p>但如果我们 触发外部容器的BFC，根据BFC规范中的第4条：<strong>计算BFC的高度时，浮动元素也参与计算</strong>，那么外部div容器就可以包裹着浮动元素，所以只要把代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;border: 1px solid #000;overflow: hidden&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>就可以完成以下效果：<br><img src="https://pic2.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.jpg" alt="tu2"></p>
<ol start="3">
<li><p>BFC可以阻止元素被浮动元素覆盖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">div &#123;  </span><br><span class="line">  width:300px;  </span><br><span class="line">&#125;  </span><br><span class="line">.aside &#123;  </span><br><span class="line">  width: 100px;  </span><br><span class="line">  height: 150px;  </span><br><span class="line">  float: left;  </span><br><span class="line">  background: black;  </span><br><span class="line">&#125;  </span><br><span class="line">.main &#123;  </span><br><span class="line">  height:200px;  </span><br><span class="line">  background-color:red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.blog.csdn.net/20170610232433253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3MjgzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
</ol>
</li>
</ol>
<p>之所以是这样，是因为上文的 规则5： <strong>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；</strong></p>
<p>所以要想改变效果，使其互补干扰，就得利用规则6 ：BFC的区域不会与float重叠，<br>让 `` 也能触发BFC的性质，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main &#123;  </span><br><span class="line">  overflow:hidden;  </span><br><span class="line">  height:200px;  </span><br><span class="line">  background-color:red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方法，就能 用来实现 两列的自适应布局。</p>
<h3 id="2-13-4-IFC"><a href="#2-13-4-IFC" class="headerlink" title="2.13.4 IFC"></a>2.13.4 IFC</h3><p>Inline Formatting Contexts，也就是“内联格式化上下文”。</p>
<h4 id="符合以下任一条件即会生成一个IFC"><a href="#符合以下任一条件即会生成一个IFC" class="headerlink" title="符合以下任一条件即会生成一个IFC"></a>符合以下任一条件即会生成一个IFC</h4><ul>
<li>块级元素中仅包含内联级别元素</li>
</ul>
<p>形成条件非常简单，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个IFC，这里不做过多介绍。</p>
<h4 id="IFC布局规则"><a href="#IFC布局规则" class="headerlink" title="IFC布局规则"></a>IFC布局规则</h4><ul>
<li>子元素水平方向横向排列，并且垂直方向起点为元素顶部。</li>
<li>子元素只会计算横向样式空间，【padding、border、margin】，垂直方向样式空间不会被计算，【padding、border、margin】。</li>
<li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li>
<li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和与其中的浮动来决定。</li>
<li>IFC中的“line box”一般左右边贴紧其包含块，但float元素会优先排列。</li>
<li>IFC中的“line box”高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。</li>
<li>当 inline-level boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。</li>
<li>当一个“inline box”超过父元素的宽度时，它会被分割成多个boxes，这些 oxes 分布在多个“line box”中。如果子元素未设置强制换行的情况下，“inline box”将不可被分割，将会溢出父元素。</li>
</ul>
<h2 id="2-12-CSS-padding（填充）"><a href="#2-12-CSS-padding（填充）" class="headerlink" title="2.12 CSS padding（填充）"></a>2.12 CSS padding（填充）</h2><table>
<thead>
<tr>
<th>padding</th>
<th>使用简写属性设置在一个声明中的所有填充属性</th>
</tr>
</thead>
<tbody><tr>
<td>padding-bottom</td>
<td>设置元素的底部填充</td>
</tr>
<tr>
<td>padding-left</td>
<td>设置元素的左部填充</td>
</tr>
<tr>
<td>padding-right</td>
<td>设置元素的右部填充</td>
</tr>
<tr>
<td>padding-top</td>
<td>设置元素的顶部填充</td>
</tr>
</tbody></table>
<h2 id="2-13-CSS-尺寸-Dimension"><a href="#2-13-CSS-尺寸-Dimension" class="headerlink" title="2.13 CSS 尺寸 (Dimension)"></a>2.13 CSS 尺寸 (Dimension)</h2><table>
<thead>
<tr>
<th>height</th>
<th>设置元素的高度。</th>
</tr>
</thead>
<tbody><tr>
<td>line-height</td>
<td>设置行高。</td>
</tr>
<tr>
<td>max-height</td>
<td>设置元素的最大高度。</td>
</tr>
<tr>
<td>max-width</td>
<td>设置元素的最大宽度。</td>
</tr>
<tr>
<td>min-height</td>
<td>设置元素的最小高度。</td>
</tr>
<tr>
<td>min-width</td>
<td>设置元素的最小宽度。</td>
</tr>
<tr>
<td>width</td>
<td>设置元素的宽度。</td>
</tr>
</tbody></table>
<h2 id="2-14-CSS-Display-显示-与-Visibility（可见性）"><a href="#2-14-CSS-Display-显示-与-Visibility（可见性）" class="headerlink" title="2.14 CSS Display(显示) 与 Visibility（可见性）"></a>2.14 CSS Display(显示) 与 Visibility（可见性）</h2><p>隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。但是请注意，这两种方法会产生不同的结果。</p>
<p>visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。</p>
<h2 id="2-15-CSS里常见的块级元素和行内元素"><a href="#2-15-CSS里常见的块级元素和行内元素" class="headerlink" title="2.15 CSS里常见的块级元素和行内元素"></a>2.15 CSS里常见的块级元素和行内元素</h2><p>根据CSS规范的规定，每一个网页元素都有一个<strong>display</strong>属性，用于确定该元素的类型，每一个元素都有默认的display属性值，比如div元素，它的默认display属性值为“block”，成为“块级”元素(block-level)；而span元素的默认display属性值为“inline”，称为“行内”元素。<br>div这样的<strong>块级元素</strong>，就会自动占据一定矩形空间，可以通过设置高度、宽度、内外边距等属性，来调整的这个矩形的样子；与之相反，像“span”“a”这样的行内元素，则没有自己的独立空间，它是依附于其他块级元素存在的，因此，对行内元素设置高度、宽度、内外边距等属性，都是无效的。</p>
<p><strong>内联元素（行内元素）内联元素(inline element)</strong></p>
<ul>
<li>a - 锚点</li>
<li>abbr - 缩写</li>
<li>acronym - 首字</li>
<li>b - 粗体(不推荐)</li>
<li>bdo - bidi override</li>
<li>big - 大字体</li>
<li>br - 换行</li>
<li>cite - 引用</li>
<li>code - 计算机代码(在引用源码的时候需要)</li>
<li>dfn - 定义字段</li>
<li>em - 强调</li>
<li>font - 字体设定(不推荐)</li>
<li>i - 斜体</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>kbd - 定义键盘文本</li>
<li>label - 表格标签</li>
<li>q - 短引用</li>
<li>s - 中划线(不推荐)</li>
<li>samp - 定义范例计算机代码</li>
<li>select - 项目选择</li>
<li>small - 小字体文本</li>
<li>span - 常用内联容器，定义文本内区块</li>
<li>strike - 中划线</li>
<li>strong - 粗体强调</li>
<li>sub - 下标</li>
<li>sup - 上标</li>
<li>textarea - 多行文本输入框</li>
<li>tt - 电传文本</li>
<li>u - 下划线</li>
<li>var - 定义变量</li>
</ul>
<p><strong>块元素(block element)</strong></p>
<ul>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>center - 举中对齐块</li>
<li>dir - 目录列表</li>
<li>div - 常用块级容易，也是css layout的主要标签</li>
<li>dl - 定义列表</li>
<li>fieldset - form控制组</li>
<li>form - 交互表单</li>
<li>h1 - 大标题</li>
<li>h2 - 副标题</li>
<li>h3 - 3级标题</li>
<li>h4 - 4级标题</li>
<li>h5 - 5级标题</li>
<li>h6 - 6级标题</li>
<li>hr - 水平分隔线</li>
<li>isindex - input prompt</li>
<li>menu - 菜单列表</li>
<li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容</li>
<li>noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）</li>
<li>ol - 排序表单</li>
<li>p - 段落</li>
<li>pre - 格式化文本</li>
<li>table - 表格</li>
<li>ul - 非排序列表</li>
</ul>
<p><strong>可变元素<br>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</strong></p>
<ul>
<li>applet - java applet</li>
<li>button - 按钮</li>
<li>del - 删除文本</li>
<li>iframe - inline frame</li>
<li>ins - 插入的文本</li>
<li>map - 图片区块(map)</li>
<li>object - object对象</li>
<li>script - 客户端脚本</li>
</ul>
<h2 id="2-16-CSS-Position-定位"><a href="#2-16-CSS-Position-定位" class="headerlink" title="2.16 CSS Position(定位)"></a>2.16 CSS Position(定位)</h2><h3 id="2-16-1-定位类型"><a href="#2-16-1-定位类型" class="headerlink" title="2.16.1 定位类型"></a>2.16.1 定位类型</h3><p>position 属性的五个值：</p>
<ul>
<li><p>static HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p>
<p>静态定位的元素不会受到 top, bottom, left, right影响。</p>
</li>
<li><p>relative   相对定位元素的定位是相对其正常位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_left</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_right</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fixed 元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动： Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。Fixed定位使元素的位置与文档流无关，因此不占据空间。Fixed定位的元素和其他元素重叠。</p>
</li>
<li><p>absolute <strong>设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</strong></p>
</li>
<li><p>sticky 粘性定位 依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。</p>
<p>它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 <strong>position:fixed;</strong>，它会固定在目标位置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>nav-item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>nav-item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>nav-item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>nav-item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">li</span>&gt;</span>nav-item5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">       main content </span><br><span class="line">   <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: disc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>元素可以使用的顶部top，底部bottom，左侧left和右侧right属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。</p>
<h3 id="2-16-2-z-index"><a href="#2-16-2-z-index" class="headerlink" title="2.16.2 z-index"></a>2.16.2 z-index</h3><p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素</p>
<p>z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）</p>
<p>一个元素可以有正数或负数的堆叠顺序</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-16-3-所有的CSS定位属性"><a href="#2-16-3-所有的CSS定位属性" class="headerlink" title="2.16.3 所有的CSS定位属性"></a>2.16.3 <strong>所有的CSS定位属性</strong></h3><table>
<thead>
<tr>
<th>bottom</th>
<th>定义了定位元素下外边距 边界与其包含块下边界之间的偏移。</th>
<th>autolength % inherit</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>clip</td>
<td>剪辑一个绝对定位的元素</td>
<td>shape autoinherit</td>
<td>2</td>
</tr>
<tr>
<td>cursor</td>
<td>显示光标移动到指定的类型</td>
<td>url auto crosshair default pointer move e-resize ne-resize nw-resize n-resize se-resize sw-resize s-resize w-resize text wait help</td>
<td>2</td>
</tr>
<tr>
<td>left</td>
<td>定义了定位元素左外边距边界 与其包含块左边界之间的偏移。</td>
<td>auto length % inherit</td>
<td>2</td>
</tr>
<tr>
<td>overflow</td>
<td>设置当元素的内容溢出 其区域时发生的事情。</td>
<td>auto hidden scroll visible inherit</td>
<td>2</td>
</tr>
<tr>
<td>overflow-y</td>
<td>指定如何处理顶部/底部 边缘的内容溢出元素的内容区域</td>
<td>auto hidden scroll visible no-display no-content</td>
<td>2</td>
</tr>
<tr>
<td>overflow-x</td>
<td>指定如何处理右边/左边 边缘的内容溢出元素的内容区域</td>
<td>auto hidden scroll visible no-display no-content</td>
<td>2</td>
</tr>
<tr>
<td>position</td>
<td>指定元素的定位类型</td>
<td>absolute fixed relative static inherit</td>
<td>2</td>
</tr>
<tr>
<td>right</td>
<td>定义了定位元素右外边距边界 与其包含块右边界之间的偏移。</td>
<td>auto length % inherit</td>
<td>2</td>
</tr>
<tr>
<td>top</td>
<td>定义了一个定位元素的上外边距 边界与其包含块上边界之间的偏移。</td>
<td>auto length % inherit</td>
<td>2</td>
</tr>
<tr>
<td>z-index</td>
<td>设置元素的堆叠顺序</td>
<td>number auto inherit</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="2-17-CSS-Overflow"><a href="#2-17-CSS-Overflow" class="headerlink" title="2.17 CSS Overflow"></a>2.17 CSS Overflow</h2><p>CSS overflow 属性用于控制内容溢出元素框时显示的方式。</p>
<p>overflow属性有以下值：</p>
<table>
<thead>
<tr>
<th>visible</th>
<th>默认值。内容不会被修剪，会呈现在元素框之外。</th>
</tr>
</thead>
<tbody><tr>
<td>hidden</td>
<td>内容会被修剪，并且其余内容是不可见的。</td>
</tr>
<tr>
<td>scroll</td>
<td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td>
</tr>
<tr>
<td>auto</td>
<td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 overflow 属性的值。</td>
</tr>
</tbody></table>
<p><strong>注意:</strong>overflow 属性只工作于指定高度的块元素上。</p>
<h2 id="2-18-CSS-Float（浮动）"><a href="#2-18-CSS-Float（浮动）" class="headerlink" title="2.18 CSS Float（浮动）"></a>2.18 CSS Float（浮动）</h2><p><strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong></p>
<p><strong>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</strong></p>
<p><strong>float语法：</strong><br>float : none | left |right</p>
<p><strong>参数值：</strong><br>none : 　对象不浮动<br><strong>left :</strong> 对象浮在左边<br><strong>right :</strong> 对象浮在右边</p>
<p>一个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"divcss5"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"divcss5_left"</span>&gt;</span>布局靠左浮动<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"divcss5_right"</span>&gt;</span>布局靠右浮动<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- html注释：清除float产生浮动 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.divcss5</span>&#123; <span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">padding</span>:<span class="number">10px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#F00</span>&#125; </span><br><span class="line"><span class="selector-class">.divcss5_left</span>&#123; <span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">150px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#00F</span>;<span class="attribute">height</span>:<span class="number">50px</span>&#125; </span><br><span class="line"><span class="selector-class">.divcss5_right</span>&#123; <span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">150px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#00F</span>;<span class="attribute">height</span>:<span class="number">50px</span>&#125; </span><br><span class="line"><span class="selector-class">.clear</span>&#123; <span class="attribute">clear</span>:both&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-18-1-清除浮动的方法（最常用的4种）"><a href="#2-18-1-清除浮动的方法（最常用的4种）" class="headerlink" title="2.18.1 清除浮动的方法（最常用的4种）"></a>2.18.1 清除浮动的方法（最常用的4种）</h3><ol>
<li>额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.fahter</span>&#123;</span></span><br><span class="line">        width: 400px;</span><br><span class="line">        border: 1px solid deeppink;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.big</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: darkorange;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.small</span>&#123;</span></span><br><span class="line">        width: 120px;</span><br><span class="line">        height: 120px;</span><br><span class="line">        background: darkmagenta;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line">        width: 900px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: darkslateblue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.clear</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fahter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span>small<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span>额外标签法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：通俗易懂，方便</p>
<p>缺点：添加无意义标签，语义化差</p>
<p>不建议使用。</p>
<ol start="2">
<li>父级添加overflow属性（父元素添加overflow:hidden）（不推荐）</li>
</ol>
<p>通过触发BFC方式，实现清除浮动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.fahter&#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    border: 1px solid deeppink;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：代码简洁</p>
<p>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素</p>
<p>不推荐使用</p>
<ol start="3">
<li>使用after伪元素清除浮动（推荐使用）</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    .clearfix:after&#123;/*伪元素是行内元素 正常浏览器清除浮动方法*/</span><br><span class="line">        content: "";</span><br><span class="line">        display: block;</span><br><span class="line">        height: 0;</span><br><span class="line">        clear:both;</span><br><span class="line">        visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix&#123;</span><br><span class="line">        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fahter clearfix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span>small<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;div class="clear"&gt;额外标签法&lt;/div&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：符合闭合浮动思想，结构语义化正确</p>
<p>缺点：ie6-7不支持伪元素：after，使用zoom:1触发hasLayout.</p>
<p>推荐使用</p>
<ol start="4">
<li><p>使用before和after双伪元素清除浮动</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    .clearfix:after,.clearfix:before&#123;</span><br><span class="line">       content: "";</span><br><span class="line">       display: table;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix:after&#123;</span><br><span class="line">       clear: both;</span><br><span class="line">   &#125;</span><br><span class="line">   .clearfix&#123;</span><br><span class="line">       *zoom: 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fahter clearfix"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"small"</span>&gt;</span>small<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：代码更简洁</p>
<p>缺点：用zoom:1触发hasLayout.</p>
<p>推荐使用</p>
</li>
</ol>
<h2 id="2-19-CSS-居中"><a href="#2-19-CSS-居中" class="headerlink" title="2.19 CSS 居中"></a>2.19 CSS 居中</h2><ol>
<li><p><strong>text-align:center方式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"center_text"</span>&gt;</span></span><br><span class="line">    123</span><br><span class="line">　　<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">center</span>&#123;</span><br><span class="line">　　<span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">center_text</span>&#123;</span><br><span class="line">　　<span class="attribute">display</span>:inline-block;</span><br><span class="line">　　<span class="attribute">width</span>:<span class="number">500px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以水平居中块级元素中的行内元素，如inline，inline-block；</p>
<p>但是如果用来居中块级元素中的块级元素时，如div中的div，一旦内层的div有自己的宽度，这种方法就会失效。只能让里面div的文字等内容居中，而div仍然是左对齐的。</p>
</li>
<li><p><strong>margin:0 auto方式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"center_text"</span>&gt;</span></span><br><span class="line">    我是块级元素，我是块级元素，我给自己设了display：block</span><br><span class="line">　　<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">center_text</span>&#123;</span><br><span class="line">　　<span class="attribute">display</span>:block;</span><br><span class="line">　　<span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">    margin：0 auto；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种对齐方式要求内部元素(.content_text)是块级元素，并且不能脱离文档流（如设置position:absolute）,否则无效。</p>
</li>
<li><p><strong>脱离文档流的居中方式</strong>。<br> 这种通常应用在自定义弹框当中，把背景层设置成透明灰色，内容居中显示在最前面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mask"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>　　　　我是要居中的板块</span><br><span class="line">　　<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mask</span>&#123;</span><br><span class="line">　　<span class="attribute">display</span>: block;</span><br><span class="line">　　<span class="attribute">position</span>: fixed;</span><br><span class="line">　　<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">　　<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">　　<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">　　<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">　　<span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">　　<span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">30</span>);</span><br><span class="line">　　<span class="attribute">-ms-filter</span>: <span class="string">"alpha(opacity=30)"</span>;</span><br><span class="line">　　<span class="attribute">opacity</span>: .<span class="number">3</span>;</span><br><span class="line">　　<span class="attribute">z-index</span>: <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">_position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">666px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">333px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">10001</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">#A0A0A0</span>, -<span class="number">2px</span> -<span class="number">2px</span> <span class="number">4px</span> <span class="number">#A0A0A0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/686372/201612/686372-20161204153957881-866313590.png" alt="">这种居中方式，把内部div设置宽高之后，再设置top、left各为50%，设置完之后，这里是按照左端居中的，接着我们使用负边距的方式调整，将margin-top设置为负的高度的一半，margin-left设置为负的宽度的一半，就可以居中了。</p>
<p>这种方式还有一种居中方法就是设置margin：-（内部div高度的一半） auto；这用就不用设置left的值了。</p>
<ol start="4">
<li><p><strong>display:table-cell</strong><br>display:table-cell配合width，text-align:center,vertical-align:middle<code>让大小不固定元素垂直居中,这个方式将要对其的元素设置成为一个td，</code>float、``absolute等属性都会影响它的实现，不响应margin属性;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="5">
<li><p><strong>垂直居中</strong><br>行内元素的垂直居中把height和line-height的值设置成一样的即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"center_text"</span>&gt;</span></span><br><span class="line">　　　　我是要居中的内容　　</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">center</span> &#123;</span><br><span class="line">　　height：40px;</span><br><span class="line">　　<span class="selector-tag">line-heigth</span>: 40<span class="selector-tag">px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用css3的translate水平垂直居中元素</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center_text"</span>&gt;</span></span><br><span class="line">　　　　我是要居中的内容　</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center_text</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式将脱离文档流的元素，设置top：50%，left：50%，然后使用transform来向左向上偏移半个内元素的宽和高。</p>
</li>
<li><p><strong>使用css3计算的方式居中元素calc</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center_text"</span>&gt;</span></span><br><span class="line">　　　　我是要居中的内容</span><br><span class="line">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center_text</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">150px</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="2-20-CSS-伪类"><a href="#2-20-CSS-伪类" class="headerlink" title="2.20 CSS 伪类"></a>2.20 CSS 伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果。</p>
<p>语法</p>
<p><code>selector:pseudo-class {property:value;}</code></p>
<p>CSS类也可以使用伪类：</p>
<p><code>selector.class:pseudo-class {property:value;}</code></p>
<h3 id="2-20-1-anchor伪类"><a href="#2-20-1-anchor伪类" class="headerlink" title="2.20.1 anchor伪类"></a>2.20.1 anchor伪类</h3><p>在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:link &#123;color:#FF0000;&#125; &#x2F;* 未访问的链接 *&#x2F;</span><br><span class="line">a:visited &#123;color:#00FF00;&#125; &#x2F;* 已访问的链接 *&#x2F;</span><br><span class="line">a:hover &#123;color:#FF00FF;&#125; &#x2F;* 鼠标划过链接 *&#x2F;</span><br><span class="line">a:active &#123;color:#0000FF;&#125; &#x2F;* 已选中的链接 *&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p>
<p><strong>注意：</strong> 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p>
<p><strong>注意：</strong>伪类的名称不区分大小写。</p>
<h3 id="2-20-2-伪类和CSS类"><a href="#2-20-2-伪类和CSS类" class="headerlink" title="2.20.2 伪类和CSS类"></a>2.20.2 伪类和CSS类</h3><p>伪类可以与 CSS 类配合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a.red:visited &#123;color:#FF0000;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"red"</span> <span class="attr">href</span>=<span class="string">"css-syntax.html"</span>&gt;</span>CSS 语法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-20-3-CSS-first-child-伪类"><a href="#2-20-3-CSS-first-child-伪类" class="headerlink" title="2.20.3 CSS :first-child 伪类"></a>2.20.3 CSS :first-child 伪类</h3><p>您可以使用 :first-child 伪类来选择父元素的第一个子元素。</p>
<blockquote>
<p>注意：在IE8的之前版本必须声明&lt;!DOCTYPE&gt; ，这样 :first-child 才能生效。</p>
</blockquote>
<p><code>匹配第一个 &lt;p&gt; 元素</code></p>
<p>在下面的例子中，选择器匹配作为任何元素的第一个子元素的 <p> 元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>匹配所有 &lt;p&gt; 元素中的第一个 &lt;i&gt; 元素</code></p>
<p>在下面的例子中，选择相匹配的所有 <p>元素的第一个 <i> 元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">i</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>匹配所有作为第一个子元素的 &lt;p&gt; 元素中的所有 &lt;i&gt; 元素</code></p>
<p>在下面的例子中，选择器匹配所有作为元素的第一个子元素的 <p> 元素中的所有 <i> 元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS - :lang 伪类</p>
<p>:lang 伪类使你有能力为不同的语言定义特殊的规则</p>
<p><strong>注意</strong>：IE8必须声明 &lt;!DOCTYPE&gt;才能支持;lang伪类。</p>
<p>在下面的例子中，:lang 类为属性值为 no 的q元素定义引号的类型：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:lang(no)</span> &#123;<span class="attribute">quotes</span>: <span class="string">"~"</span> <span class="string">"~"</span>;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>所有CSS伪类/元素</strong></p>
<table>
<thead>
<tr>
<th>:checked</th>
<th>input:checked</th>
<th>选择所有选中的表单元素</th>
</tr>
</thead>
<tbody><tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择所有禁用的表单元素</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择所有没有子元素的p元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择所有启用的表单元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择的每个 p 元素是其父元素的第一个 p 元素</td>
</tr>
<tr>
<td>:in-range</td>
<td>input:in-range</td>
<td>选择元素指定范围内的值</td>
</tr>
<tr>
<td>:invalid</td>
<td>input:invalid</td>
<td>选择所有无效的元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择所有p元素的最后一个子元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其母元素的最后一个p元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择所有p以外的元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择所有 p 元素的父元素的第二个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择所有p元素倒数的第二个子元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择所有p元素倒数的第二个为p的子元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择所有p元素第二个为p的子元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择所有仅有一个子元素为p的元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择所有仅有一个子元素的p元素</td>
</tr>
<tr>
<td>:optional</td>
<td>input:optional</td>
<td>选择没有”required”的元素属性</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>input:out-of-range</td>
<td>选择指定范围以外的值的元素属性</td>
</tr>
<tr>
<td>:read-only</td>
<td>input:read-only</td>
<td>选择只读属性的元素属性</td>
</tr>
<tr>
<td>:read-write</td>
<td>input:read-write</td>
<td>选择没有只读属性的元素属性</td>
</tr>
<tr>
<td>:required</td>
<td>input:required</td>
<td>选择有”required”属性指定的元素属性</td>
</tr>
<tr>
<td>:root</td>
<td>root</td>
<td>选择文档的根元素</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>选择当前活动#news元素(点击URL包含锚的名字)</td>
</tr>
<tr>
<td>:valid</td>
<td>input:valid</td>
<td>选择所有有效值的属性</td>
</tr>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问链接</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择正在活动链接</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>把鼠标放在链接上的状态</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择元素输入后具有焦点</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每个元素的第一个字母</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每个元素的第一行</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>选择器匹配属于任意元素的第一个子元素的元素</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个元素之前插入内容</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个元素之后插入内容</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>p:lang(it)</td>
<td>为元素的lang属性选择一个开始值</td>
</tr>
</tbody></table>
<h2 id="2-21-CSS-伪元素"><a href="#2-21-CSS-伪元素" class="headerlink" title="2.21 CSS 伪元素"></a>2.21 CSS 伪元素</h2><p>CSS伪元素是用来添加一些选择器的特殊效果。</p>
<p><strong>伪元素的语法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">:pseudo-element</span> &#123;<span class="attribute">property</span>:value;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS类也可以使用伪元素：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span><span class="selector-pseudo">:pseudo-element</span> &#123;<span class="attribute">property</span>:value;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>:first-line 伪元素</strong></p>
<p>“first-line” 伪元素用于向文本的首行设置特殊样式。</p>
<p>在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-line</span> &#123;    <span class="attribute">color</span>:<span class="number">#ff0000</span>;    <span class="attribute">font-variant</span>:small-caps;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“first-line” 伪元素只能用于块级元素。</p>
<p><strong>注意：</strong> 下面的属性可应用于 “first-line” 伪元素：</p>
<ul>
<li>font properties</li>
<li>color properties </li>
<li>background properties</li>
<li>word-spacing</li>
<li>letter-spacing</li>
<li>text-decoration</li>
<li>vertical-align</li>
<li>text-transform</li>
<li>line-height</li>
<li>clear</li>
</ul>
<p><strong>:first-letter 伪元素</strong></p>
<p>“first-letter” 伪元素用于向文本的首字母设置特殊样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123;    <span class="attribute">color</span>:<span class="number">#ff0000</span>;    <span class="attribute">font-size</span>:xx-large;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> “first-letter” 伪元素只能用于块级元素。</p>
<p><strong>注意：</strong> 下面的属性可应用于 “first-letter” 伪元素： </p>
<ul>
<li>font properties</li>
<li>color properties </li>
<li>background properties</li>
<li>margin properties</li>
<li>padding properties</li>
<li>border properties</li>
<li>text-decoration</li>
<li>vertical-align (only if “float” is “none”)</li>
<li>text-transform</li>
<li>line-height</li>
<li>float</li>
<li>clear</li>
</ul>
<p><strong>伪元素和CSS类</strong></p>
<p>伪元素可以结合CSS类： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">p.article:first-letter &#123;color:#ff0000;&#125;&lt;p class="article"&gt;文章段落&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>上面的例子会使所有 class 为 article 的段落的首字母变为红色。</p>
<p><strong>多个伪元素</strong></p>
<p>可以结合多个伪元素来使用。</p>
<p>在下面的例子中，段落的第一个字母将显示为红色，其字体大小为 xx-large。第一行中的其余文本将为蓝色，并以小型大写字母显示。</p>
<p>段落中的其余文本将以默认字体大小和颜色来显示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span>&#123;    </span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#ff0000</span>;    </span><br><span class="line">  <span class="attribute">font-size</span>:xx-large;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-line</span> &#123;    </span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#0000ff</span>;    </span><br><span class="line">  <span class="attribute">font-variant</span>:small-caps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS - :before 伪元素</strong></p>
<p>“:before” 伪元素可以在元素的内容前面插入新内容。</p>
<p>下面的例子在每个 <h1>元素前面插入一幅图片：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line"> <span class="attribute">content</span>:<span class="built_in">url</span>(smiley.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CSS - :after 伪元素</strong></p>
<p>“:after” 伪元素可以在元素的内容之后插入新内容。</p>
<p>下面的例子在每个 <h1> 元素后面插入一幅图片：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>:<span class="built_in">url</span>(smiley.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有CSS伪类/元素</strong></p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">示例</th>
<th align="left">示例说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:link</td>
<td align="left">a:link</td>
<td align="left">选择所有未访问链接</td>
</tr>
<tr>
<td align="left">:visited</td>
<td align="left">a:visited</td>
<td align="left">选择所有访问过的链接</td>
</tr>
<tr>
<td align="left">:active</td>
<td align="left">a:active</td>
<td align="left">选择正在活动链接</td>
</tr>
<tr>
<td align="left">:hover</td>
<td align="left">a:hover</td>
<td align="left">把鼠标放在链接上的状态</td>
</tr>
<tr>
<td align="left">:focus</td>
<td align="left">input:focus</td>
<td align="left">选择元素输入后具有焦点</td>
</tr>
<tr>
<td align="left">:first-letter</td>
<td align="left">p:first-letter</td>
<td align="left">选择每个元素的第一个字母</td>
</tr>
<tr>
<td align="left">:first-line</td>
<td align="left">p:first-line</td>
<td align="left">选择每个元素的第一行</td>
</tr>
<tr>
<td align="left">:first-child</td>
<td align="left">p:first-child</td>
<td align="left">选择器匹配属于任意元素的第一个子元素的 &lt;]p&gt; 元素</td>
</tr>
<tr>
<td align="left">:before</td>
<td align="left">p:before</td>
<td align="left">在每个元素之前插入内容</td>
</tr>
<tr>
<td align="left">:after</td>
<td align="left">p:after</td>
<td align="left">在每个元素之后插入内容</td>
</tr>
<tr>
<td align="left">:lang(language)</td>
<td align="left">p:lang(it)</td>
<td align="left">为元素的lang属性选择一个开始值</td>
</tr>
</tbody></table>
<h2 id="2-22-CSS-导航栏"><a href="#2-22-CSS-导航栏" class="headerlink" title="2.22  CSS 导航栏"></a>2.22  CSS 导航栏</h2><p>作为标准的HTML基础一个导航栏是必须的</p>
<p>。在我们的例子中我们将建立一个标准的HTML列表导航栏。</p>
<p>导航条基本上是一个链接列表，所以使用 <ul> 和 <li>元素非常有意义：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#home"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#news"</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#contact"</span>&gt;</span>联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#about"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，让我们从列表中删除边距和填充：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子解析：</p>
<ul>
<li>list-style-type:none - 移除列表前小标志。一个导航栏并不需要列表标记</li>
<li>移除浏览器的默认设置将边距和填充设置为0</li>
</ul>
<p>上面的例子中的代码是垂直和水平导航栏使用的标准代码。</p>
<h3 id="2-22-1-垂直导航栏"><a href="#2-22-1-垂直导航栏" class="headerlink" title="2.22.1 垂直导航栏"></a>2.22.1 垂直导航栏</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术01<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术02<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术03<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术04<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术05<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术06<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术07<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术08<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术09<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术10<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术11<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术12<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术13<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术14<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术16<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术17<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术18<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术19<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>技术20<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.vertical</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.vertical</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.vertical</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.vertical</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.vertical</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-22-2-水平导航栏"><a href="#2-22-2-水平导航栏" class="headerlink" title="2.22.2 水平导航栏"></a>2.22.2 水平导航栏</h3><p>有两种方法创建横向导航栏。使用<strong>内联(inline)</strong>或<strong>浮动(float)</strong>的列表项。</p>
<p>这两种方法都很好，但如果你想导航链接具有相同的大小，你必须使用浮动的方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        html,</span><br><span class="line">        body &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">            overflow: auto;</span><br><span class="line">        &#125;</span><br><span class="line">        ul &#123;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">            width: 100%;</span><br><span class="line">            position: fixed;</span><br><span class="line">            top: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ul li &#123;</span><br><span class="line">            float: left;</span><br><span class="line"><span class="css">            <span class="selector-tag">border-right</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#bbb</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line">            border-right: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ul li a &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            height: 60px;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            padding: 0 16px;</span><br><span class="line">            line-height: 60px;</span><br><span class="line">            color: white;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            height: 2000px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#bbb</span>;</span></span><br><span class="line">            margin-top: 60px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#4caf54</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>导航项01<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>导航项02<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>导航项03<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>导航项04<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"float: right;"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"active"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>导航项05<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-23-CSS-下拉菜单"><a href="#2-23-CSS-下拉菜单" class="headerlink" title="2.23 CSS 下拉菜单"></a>2.23 CSS 下拉菜单</h2><p>使用 CSS 创建一个鼠标移动上去后显示下拉菜单的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span> <span class="selector-class">.dropdown-content</span> &#123;</span></span><br><span class="line">            visibility: collapse;</span><br><span class="line">            position: absolute;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#f9f9f9</span>;</span></span><br><span class="line">            width: 100%;</span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 0<span class="selector-tag">px</span> 8<span class="selector-tag">px</span> 16<span class="selector-tag">px</span> 0<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.2</span>);</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            z-index: 1;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropdown-content</span> &#123;</span></span><br><span class="line">            visibility: visible;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span> <span class="selector-class">.dropdown-content</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            list-style-type: none;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span> <span class="selector-class">.dropdown-content</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.dropdown</span> <span class="selector-class">.dropdown-content</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            color: blue;</span><br><span class="line">            text-decoration: underline;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">const</span> li of lis) &#123;</span></span><br><span class="line"><span class="actionscript">                li.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span></span><br><span class="line">                    alert(li.textContent)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>悬浮我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>item6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-24-CSS-提示工具-Tooltip"><a href="#2-24-CSS-提示工具-Tooltip" class="headerlink" title="2.24 CSS 提示工具(Tooltip)"></a>2.24 CSS 提示工具(Tooltip)</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body &#123;</span><br><span class="line">            padding: 60px;</span><br><span class="line">        &#125;</span><br><span class="line">        div &#123;</span><br><span class="line">            margin: 20px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* Tooltip 容器 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            display: inline-block;</span><br><span class="line"><span class="css">            <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">dotted</span> <span class="selector-tag">black</span>; <span class="comment">/* 悬停元素上显示点线 */</span></span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line"><span class="css">        <span class="comment">/* Tooltip 文本 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            visibility: hidden;</span><br><span class="line">            width: 120px;</span><br><span class="line">            background-color: black;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            padding: 5px 0;</span><br><span class="line">            border-radius: 6px;</span><br><span class="line">         </span><br><span class="line"><span class="css">            <span class="comment">/* 定位 */</span></span></span><br><span class="line">            position: absolute;</span><br><span class="line">            z-index: 1;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line"><span class="css">        <span class="comment">/* 鼠标移动上去后显示提示框 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            visibility: visible;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.right</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            top: -5px;</span><br><span class="line">            left: 105%; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.left</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            top: -5px;</span><br><span class="line">            right: 105%; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.top</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            width: 120px;</span><br><span class="line">            bottom: 100%;</span><br><span class="line">            left: 50%; </span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span>: <span class="selector-tag">-60px</span>; <span class="comment">/* 使用一半宽度 (120/2 = 60) 来居中提示工具 */</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.bottom</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            width: 120px;</span><br><span class="line">            top: 100%;</span><br><span class="line">            left: 50%; </span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span>: <span class="selector-tag">-60px</span>; <span class="comment">/* 使用一半宽度 (120/2 = 60) 来居中提示工具 */</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 顶部提示框/底部箭头 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.top</span> <span class="selector-class">.tooltiptext</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            content: " ";</span><br><span class="line">            position: absolute;</span><br><span class="line"><span class="css">            <span class="selector-tag">top</span>: 100%; <span class="comment">/* 提示工具底部 */</span></span></span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -5px;</span><br><span class="line">            border-width: 5px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: black transparent transparent transparent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 底部提示框/顶部箭头 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.bottom</span> <span class="selector-class">.tooltiptext</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            content: " ";</span><br><span class="line">            position: absolute;</span><br><span class="line"><span class="css">            <span class="selector-tag">bottom</span>: 100%;  <span class="comment">/* 提示工具头部 */</span></span></span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -5px;</span><br><span class="line">            border-width: 5px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: transparent transparent black transparent;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* 右侧提示框/左侧箭头 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.right</span> <span class="selector-class">.tooltiptext</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            content: " ";</span><br><span class="line">            position: absolute;</span><br><span class="line">            right: 100%;</span><br><span class="line">            top: 50%;</span><br><span class="line">            margin-top: -5px;</span><br><span class="line">            border-width: 5px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: transparent black transparent transparent;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/*  左侧提示框/右侧箭头 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-class">.left</span> <span class="selector-class">.tooltiptext</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            content: " ";</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">left</span>: 100%; <span class="comment">/* 提示工具右侧 */</span></span></span><br><span class="line">            margin-top: -5px;</span><br><span class="line">            border-width: 5px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: transparent transparent transparent black;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            opacity: 0;</span><br><span class="line">            transition: opacity 1s;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.tooltiptext</span> &#123;</span></span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tooltip top"</span>&gt;</span>顶部提示框</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltiptext"</span>&gt;</span>提示文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tooltip bottom"</span>&gt;</span>底部提示框</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltiptext"</span>&gt;</span>提示文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tooltip right"</span>&gt;</span>右侧提示框</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltiptext"</span>&gt;</span>提示文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tooltip left"</span>&gt;</span>左侧提示框</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"tooltiptext"</span>&gt;</span>提示文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-25-CSS-图像透明-不透明"><a href="#2-25-CSS-图像透明-不透明" class="headerlink" title="2.25 CSS 图像透明/不透明"></a>2.25 CSS 图像透明/不透明</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        img &#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: 0<span class="selector-class">.5</span>;</span></span><br><span class="line">            filter: alpha(opacity=50); /*for ie8 and earlier*/</span><br><span class="line">            border-radius: 5px;</span><br><span class="line">            transition: ease opacity 1s;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            opacity: 1;</span><br><span class="line">            filter: alpha(opacity=100); /*for ie8 and earlier*/</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>带有透明效果的图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3252521864,872614242&amp;fm=26&amp;gp=0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-26-CSS-精灵图-雪碧图"><a href="#2-26-CSS-精灵图-雪碧图" class="headerlink" title="2.26 CSS 精灵图/雪碧图"></a>2.26 CSS 精灵图/雪碧图</h2><p>精灵图/雪碧图就是图像拼合也就是单个图像的集合。有许多图像的网页可能需要很长的时间来加载和生成多个服务器的请求。使用图像拼合会降低服务器的请求数量，并节省带宽。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#navlist</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#navlist</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">                margin: 0;</span><br><span class="line">                padding: 0;</span><br><span class="line">                list-style: none;</span><br><span class="line">                display: inline-block;</span><br><span class="line">                height: 44px;</span><br><span class="line">                line-height: 44px;</span><br><span class="line">                text-align: center;</span><br><span class="line">                cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#navlist</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line">            height: 44px;</span><br><span class="line">            width: 46px;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">            background: url('./img_navsprites.gif') 0 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            background: url('img_navsprites_hover.gif') 0 -45px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span><span class="selector-pseudo">:url('img_navsprites.gif')</span> <span class="selector-tag">-47px</span> 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"navlist"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-27-CSS-媒体类型-media-规则"><a href="#2-27-CSS-媒体类型-media-规则" class="headerlink" title="2.27 CSS 媒体类型@media 规则"></a>2.27 CSS 媒体类型@media 规则</h2><p>在下面的例子告诉我们浏览器屏幕上显示一个 14 像素的 Verdana 字体样式。但是如果页面打印，将是 10 个像素的 Times 字体。请注意，font-weight 在屏幕上和纸上设置为粗体：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.test</span> &#123;<span class="attribute">font-family</span>:verdana,sans-serif;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.test</span> &#123;<span class="attribute">font-family</span>:times,serif;<span class="attribute">font-size</span>:<span class="number">10px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen,print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">p</span><span class="selector-class">.test</span> &#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他媒体类型</p>
<table>
<thead>
<tr>
<th>all</th>
<th>用于所有的媒体设备。</th>
</tr>
</thead>
<tbody><tr>
<td>aural</td>
<td>用于语音和音频合成器。</td>
</tr>
<tr>
<td>braille</td>
<td>用于盲人用点字法触觉回馈设备。</td>
</tr>
<tr>
<td>embossed</td>
<td>用于分页的盲人用点字法打印机。</td>
</tr>
<tr>
<td>handheld</td>
<td>用于小的手持的设备。</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机。</td>
</tr>
<tr>
<td>projection</td>
<td>用于方案展示，比如幻灯片。</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑显示器。</td>
</tr>
<tr>
<td>tty</td>
<td>用于使用固定密度字母栅格的媒体，比如电传打字机和终端。</td>
</tr>
<tr>
<td>tv</td>
<td>用于电视机类型的设备。</td>
</tr>
</tbody></table>
<h1 id="三-CSS3新增特性总结"><a href="#三-CSS3新增特性总结" class="headerlink" title="三. CSS3新增特性总结"></a>三. CSS3新增特性总结</h1><h2 id="1-CSS3简介"><a href="#1-CSS3简介" class="headerlink" title="1.CSS3简介"></a>1.CSS3简介</h2><p>CSS3是<a href="https://baike.baidu.com/item/CSS/5457" target="_blank" rel="noopener">CSS</a>（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、<a href="https://baike.baidu.com/item/超链接/97857" target="_blank" rel="noopener">超链接</a>方式、语言模块、背景和边框、文字特效、多栏布局等模块</p>
<h2 id="2-过渡"><a href="#2-过渡" class="headerlink" title="2.过渡"></a>2.过渡</h2><p>过渡，是我在项目里面用得最多的一个特性了！也相信是很多人用得最多的一个例子！我平常使用就是想让一些交互效果（主要是hover动画），变得生动一些，不会显得那么生硬！好了，下面进入正文！</p>
<p>引用菜鸟教程的说法：CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容：指定要添加效果的CSS属性指定效果的持续时间。</p>
<h3 id="2-1语法"><a href="#2-1语法" class="headerlink" title="2-1语法"></a>2-1语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)复制代码</span><br></pre></td></tr></table></figure>

<p>栗子1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*&#x2F;</span><br><span class="line">transition：width,.5s,ease,.2s复制代码</span><br></pre></td></tr></table></figure>

<p>栗子2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*&#x2F;</span><br><span class="line">transition：all,.5s</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面栗子是简写模式，也可以分开写各个属性（这个在下面就不再重复了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition-property: width;</span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 文本颜色过渡 */</span></span></span><br><span class="line">        p &#123;</span><br><span class="line">            transition-property: color;</span><br><span class="line">            transition-delay: 0ms;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">cubic-bezier</span>(0<span class="selector-class">.075</span>, 0<span class="selector-class">.82</span>, 0<span class="selector-class">.165</span>, 1);</span></span><br><span class="line">            transition-duration: 1s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 导航栏下拉菜单过滤 */</span></span></span><br><span class="line">        ul &#123;</span><br><span class="line">            list-style: none;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.demo-ui</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">           float: left; </span><br><span class="line">           background-color: antiquewhite;</span><br><span class="line">           text-align: center;</span><br><span class="line">           position: relative;</span><br><span class="line">           cursor: pointer;</span><br><span class="line">           min-width: 120px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.demo-ui</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &gt;<span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            transform: scaleY(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.demo-ui</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line">            transform-origin: 0 0;</span><br><span class="line">            transform: scaleY(0);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.demo-ui</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            display: block;</span><br><span class="line">            padding: 12px 16px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">            border-width: 1px;</span><br><span class="line">            border-style: dashed;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本颜色过渡效果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            Lorem ipsum dolor sit amet consectetur adipisicing elit. Et dignissimos tempore fugiat natus ipsa</span><br><span class="line">            voluptatibus, repellendus similique. Quisquam iste, ut animi recusandae illum vero fugiat molestiae</span><br><span class="line">            voluptatem magnam culpa tenetur.Deserunt, dolorum. Facere non et consectetur modi maiores, mollitia,</span><br><span class="line">            molestias excepturi architecto tenetur laborum quae obcaecati? Placeat ratione, ipsa possimus voluptatum</span><br><span class="line">            quam sed maiores exercitationem, eius fugit sit sint voluptatem.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>下拉菜单过渡效果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"demo-ui"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                nav1</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                nav2</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                nav3</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>child-nav3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-动画"><a href="#3-动画" class="headerlink" title="3.动画"></a>3.动画</h2><p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬！</p>
<h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3-1.语法"></a>3-1.语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">animation</span>：动画名称，一个周期花费时间，运动曲线（默认<span class="selector-tag">ease</span>），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认<span class="selector-tag">normal</span>），是否暂停动画（默认<span class="selector-tag">running</span>）复制代码</span><br></pre></td></tr></table></figure>

<p>栗子1</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span>;复制代码</span><br></pre></td></tr></table></figure>

<p>栗子2</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2秒后开始执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 2<span class="selector-tag">s</span>;复制代码</span><br></pre></td></tr></table></figure>

<p>栗子3</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*无限执行logo2-line动画，每次运动时间2秒，运动曲线为 linear，并且执行反向动画*/</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">logo2-line</span> 2<span class="selector-tag">s</span> <span class="selector-tag">linear</span> <span class="selector-tag">alternate</span> <span class="selector-tag">infinite</span>;复制代码</span><br></pre></td></tr></table></figure>

<p>还有一个重要属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">animation-fill-mode : none | forwards | backwards | both;</span><br><span class="line"><span class="comment">/*none：不改变默认行为。    </span></span><br><span class="line"><span class="comment">forwards ：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。    </span></span><br><span class="line"><span class="comment">backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 </span></span><br><span class="line"><span class="comment">both：向前和向后填充模式都被应用。  */</span>      复制代码</span><br></pre></td></tr></table></figure>

<h3 id="3-2-logo展示动画"><a href="#3-2-logo展示动画" class="headerlink" title="3-2.logo展示动画"></a>3-2.logo展示动画</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf406b0855a99?imageslim" alt="img"></p>
<p>这个是我用公司logo写的动画，没那么精细</p>
<p>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"reset.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span>&#123;</span></span><br><span class="line">    width: 600px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    font-size: 0;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-class">.logo-text</span>&#123;</span></span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-class">.logo1</span>&#123;</span></span><br><span class="line">    animation: logo1 1s ease-in 2s;</span><br><span class="line"><span class="css">    <span class="selector-tag">animation-fill-mode</span><span class="selector-pseudo">:backwards</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-class">.logo-text</span>&#123;</span></span><br><span class="line">    animation: logoText 1s ease-in 3s;</span><br><span class="line"><span class="css">    <span class="selector-tag">animation-fill-mode</span><span class="selector-pseudo">:backwards</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-class">.logo2</span>&#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20px;</span><br><span class="line">    left: 20px;</span><br><span class="line">    animation: logo2-middle 2s ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.logo-box</span> <span class="selector-class">.logo2</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line">    animation: logo2-line 2s linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="keyword">@keyframes</span> logo1 &#123;</span></span><br><span class="line">    0%&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(180deg)</span>;</span></span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(0deg)</span>;</span></span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="keyword">@keyframes</span> logoText &#123;</span></span><br><span class="line">    0%&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">transform</span><span class="selector-pseudo">:translateX(30px)</span>;</span></span><br><span class="line">        opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">transform</span><span class="selector-pseudo">:translateX(0)</span>;</span></span><br><span class="line">        opacity: 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="keyword">@keyframes</span> logo2-line &#123;</span></span><br><span class="line"><span class="css">    0% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">200px</span>)&#125;</span></span><br><span class="line"><span class="css">    25% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">150px</span>)&#125;</span></span><br><span class="line"><span class="css">    50% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>)&#125;</span></span><br><span class="line"><span class="css">    75% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">50px</span>)&#125;</span></span><br><span class="line"><span class="css">    100% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>); &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="keyword">@keyframes</span> logo2-middle &#123;</span></span><br><span class="line"><span class="css">    0% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);     &#125;</span></span><br><span class="line"><span class="css">    25% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100px</span>);     &#125;</span></span><br><span class="line"><span class="css">    50% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);     &#125;</span></span><br><span class="line"><span class="css">    75% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50px</span>);     &#125;</span></span><br><span class="line"><span class="css">    100% &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>); &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo-box"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo1"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"logo1.jpg"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo2"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"logo2.jpg"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"logo-text"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"logo3.jpg"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wraper"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面让大家看一个专业级别的</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf406a3af6c0a?imageslim" alt="img"></p>
<p>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        font-family: Arial,"Helvetica Neue",Helvetica,sans-serif;</span><br><span class="line">        overflow: hidden;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">        margin: 80px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> &#123;</span></span><br><span class="line">        display: block;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 156px;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> * &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        animation-iteration-count: infinite;</span><br><span class="line"><span class="css">        <span class="selector-tag">animation-duration</span>: 3<span class="selector-class">.5s</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.name</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        font-size: 54px;</span><br><span class="line">        left: 130px;</span><br><span class="line">        top: 95px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.name</span> <span class="selector-class">.b</span> &#123;</span></span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack-box</span> &#123;</span></span><br><span class="line">        top: 100px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 56px;</span><br><span class="line">        left: 0px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#BCBBBB</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.bottom</span> &#123;</span></span><br><span class="line">        bottom: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 115px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        bottom: 11px;</span><br><span class="line">        left: 103px;</span><br><span class="line">        width: 12px;</span><br><span class="line">        height: 34px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.top</span> &#123;</span></span><br><span class="line">        top: 0px;</span><br><span class="line">        left: 0px;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> &#123;</span></span><br><span class="line">        left: 22px;</span><br><span class="line">        top: 22px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.inner-item</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#F48024</span>;</span></span><br><span class="line">        width: 71px;</span><br><span class="line">        height: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">transform</span> 0<span class="selector-class">.3s</span>;</span></span><br><span class="line">        width: 291px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">        transform: rotate(0deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">        transform: rotate(12deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">        transform: rotate(24deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span></span><br><span class="line">        transform: rotate(36deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span></span><br><span class="line">        transform: rotate(48deg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        animation-name: box;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.top</span> &#123;</span></span><br><span class="line">        animation-name: box-top;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        animation-name: box-left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        animation-name: box-right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.box</span> <span class="selector-class">.bottom</span> &#123;</span></span><br><span class="line">        animation-name: box-bottom;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack-box</span> &#123;</span></span><br><span class="line">        animation-name: stack-box;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> &#123;</span></span><br><span class="line">        animation-name: stack;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.inner-item</span> &#123;</span></span><br><span class="line">        animation-name: stack-items;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">        animation-name: stack-item-1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">        animation-name: stack-item-2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">        animation-name: stack-item-3;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span></span><br><span class="line">        animation-name: stack-item-4;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.so</span> <span class="selector-class">.inner</span> <span class="selector-class">.stack</span> <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span></span><br><span class="line">        animation-name: stack-item-5;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 52px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 22px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-item-<span class="number">1</span> &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-item-<span class="number">2</span> &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-item-<span class="number">3</span> &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-item-<span class="number">4</span> &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-item-<span class="number">5</span> &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">        10% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        54% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        92% &#123;</span><br><span class="line">            transform: rotate(12deg * 4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-items &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 12px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 71px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> box &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> box-top &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        6% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        59% &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> box-bottom &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        15% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            width: 56px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            width: 115px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> box-right &#123;</span></span><br><span class="line">        15% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            left: 44px;</span><br><span class="line">        &#125;</span><br><span class="line">        80% &#123;</span><br><span class="line">            left: 103px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> stack-box &#123;</span></span><br><span class="line">        0% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        30% &#123;</span><br><span class="line">            transform: rotate(0deg);</span><br><span class="line">        &#125;</span><br><span class="line">        40% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            transform: rotate(135deg);</span><br><span class="line">        &#125;</span><br><span class="line">        83% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            transform: rotate(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"so center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"stack-box"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"stack"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            stack<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"b"</span>&gt;</span>overflow<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-loading效果"><a href="#3-3-loading效果" class="headerlink" title="3-3.loading效果"></a>3-3.loading效果</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            margin: auto;</span><br><span class="line">            overflow: hidden;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#ddd</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span> &#123;</span></span><br><span class="line">            height: 12px;</span><br><span class="line">            width: 12px;</span><br><span class="line">            opacity: 0;</span><br><span class="line">            border-radius: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#4b9cdb</span>;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line">            margin: 0 10px;</span><br><span class="line">            animation-name: loading;</span><br><span class="line">            animation-duration: 4s;</span><br><span class="line">            animation-iteration-count: infinite;</span><br><span class="line">            animation-timing-function: ease;</span><br><span class="line">            transform: translateX(-300px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.8s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.7s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.6s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.5s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.4s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(6)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.3s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(7)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.2s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.loading-box</span> <span class="selector-class">.loading-dot</span><span class="selector-pseudo">:nth-child(8)</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">animation-delay</span>: <span class="selector-class">.1s</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> loading &#123;</span></span><br><span class="line">            40% &#123;</span><br><span class="line">                transform: translateX(0);</span><br><span class="line"><span class="css">                <span class="selector-tag">opacity</span>: <span class="selector-class">.8</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">            100% &#123;</span><br><span class="line">                transform: translateX(300px);</span><br><span class="line">                opacity: 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loading-dot"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.html5tricks.com/demo/css3-loading-cool-styles/index.html" target="_blank" rel="noopener">css3-loading</a></p>
<h3 id="3-4-音乐震动条"><a href="#3-4-音乐震动条" class="headerlink" title="3-4.音乐震动条"></a>3-4.音乐震动条</h3><p>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>纯CSS3模拟跳动的音符效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    *&#123;<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span>&#123;<span class="attribute">background-color</span>: <span class="number">#efefef</span>;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> &#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 200px;</span><br><span class="line">      top: 120px;</span><br><span class="line"><span class="css">      <span class="selector-tag">zoom</span>: 1<span class="selector-class">.5</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-class">.music</span> &#123;</span></span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      -webkit-transform: translate(-40px, -25px);</span><br><span class="line">      transform: translate(-40px, -25px);</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> &#123;</span></span><br><span class="line">      width: 80px;</span><br><span class="line">      height: 50px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 12px;</span><br><span class="line">      left: 12px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">      position: relative;</span><br><span class="line">      float: left;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 12%;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      margin-right: 1px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      display: block;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#09f</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li1</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li2</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.9s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.9s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li3</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line">      animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">      -webkit-animation: waves 1s linear 0s infinite alternate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li4</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li5</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.7s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.7s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-music</span> <span class="selector-id">#waves</span> <span class="selector-class">.li6</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">-webkit-animation</span>: <span class="selector-tag">waves</span> 0<span class="selector-class">.8s</span> <span class="selector-tag">linear</span> 0<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@-webkit-keyframes</span> waves &#123;</span></span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> waves &#123;</span></span><br><span class="line">      10% &#123;</span><br><span class="line">        height: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      20% &#123;</span><br><span class="line">        height: 60%;</span><br><span class="line">      &#125;</span><br><span class="line">      40% &#123;</span><br><span class="line">        height: 40%;</span><br><span class="line">      &#125;</span><br><span class="line">      50% &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line">        height: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-music"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"music"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"waves"</span> <span class="attr">class</span>=<span class="string">"movement"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li1"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li2"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li3"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li4"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li5"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"li6"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"ani-li"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"music-state"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-形状转换"><a href="#4-形状转换" class="headerlink" title="4.形状转换"></a>4.形状转换</h2><p>这一部分，分2d转换和3d转换。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/436120/2012083014431464.jpg" alt=""></p>
<p>rotate判断：</p>
<p>　　<strong>正向轴对着眼睛，顺时针则旋转角度为正，逆时针则旋转角度为负。</strong></p>
<p>　　或者用左手法则也行：<strong>伸出左手，大拇指指向正轴方向，四个手指的指向即是旋转正向，但务必记住是左手！</strong></p>
<p><strong>注：rotate后三维坐标轴也会跟着改变</strong></p>
<p>旋转的动画效果</p>
<p><a href="http://www.100sucai.com/demos.php?id=1551760986" target="_blank" rel="noopener">http://www.100sucai.com/demos.php?id=1551760986</a></p>
<h3 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4-1.语法"></a>4-1.语法</h3><p>transform:适用于2D或3D转换的元素<br>transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)</p>
<h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4-2.实例"></a>4-2.实例</h3><p>transform:rotate(30deg);  旋转30弧度</p>
<p>transform:translate(30px,30px);  平移x: 30px ,y: 30px</p>
<p>transform:scale(.8); 缩放0.8倍</p>
<p>transform: skew(10deg,10deg); 倾斜x轴方向: 10弧度， y方向10弧度</p>
<p>transform:rotateX(180deg); 沿x方向旋转180弧度</p>
<p>transform:rotateY(180deg); 沿y轴方向旋转180弧度</p>
<p>transform:rotate3d(10,10,10,90deg); 使元素在这三个纬度中移动,也可以分开写，如：translateX(length),translateY(length), translateZ(length)。注意z轴的值只能为px</p>
<p>画一个立方体</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="css"><span class="selector-class">.main</span>&#123;</span></span><br><span class="line">	height: 500px;</span><br><span class="line">	width: 500px;</span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;</span><br><span class="line">	top: 50%;</span><br><span class="line"><span class="css">	<span class="selector-tag">border</span><span class="selector-pseudo">:0px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span></span><br><span class="line">	transform: translate(-50%,-50%) rotateX(45deg) rotateY(45deg);</span><br><span class="line">	transform-style: preserve-3d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.main</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;</span><br><span class="line">	top: 50%;</span><br><span class="line">	height: 250px;</span><br><span class="line">	width: 250px;</span><br><span class="line">	display: flex;</span><br><span class="line">	justify-content: center;</span><br><span class="line">	align-items: center;</span><br><span class="line">	font-size: 60px;</span><br><span class="line">	font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.main</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">	transform: translate(-50%,-50%)  rotateX(145deg) rotateY(45deg) rotateZ(105deg);</span><br><span class="line">	transition: all 5s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face1</span>&#123;</span></span><br><span class="line">	background-color: pink;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateY</span>(<span class="selector-tag">-125px</span>) <span class="selector-tag">rotateX</span>(90<span class="selector-tag">deg</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face2</span>&#123;</span></span><br><span class="line">	background-color: red;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateX</span>(<span class="selector-tag">-125px</span>) <span class="selector-tag">rotateY</span>(90<span class="selector-tag">deg</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face3</span>&#123;</span></span><br><span class="line">	background-color: blue;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateZ</span>(<span class="selector-tag">-125px</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face4</span>&#123;</span></span><br><span class="line">	background-color: yellow;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateY</span>(125<span class="selector-tag">px</span>) <span class="selector-tag">rotateX</span>(90<span class="selector-tag">deg</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face5</span>&#123;</span></span><br><span class="line">	background-color: green;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateX</span>(125<span class="selector-tag">px</span>) <span class="selector-tag">rotateY</span>(90<span class="selector-tag">deg</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.face6</span>&#123;</span></span><br><span class="line">	background-color: orange;</span><br><span class="line"><span class="css">	<span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%) <span class="selector-tag">translateZ</span>(125<span class="selector-tag">px</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"face6"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述效果更复杂的例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#ul</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            margin: 100px auto;</span><br><span class="line">            position: relative;</span><br><span class="line">            transform-style: preserve-3d;</span><br><span class="line">            -webkit-</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            font-size: 80px;</span><br><span class="line">            font-weight: bold;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">            background: rgba(255, 0, 0, 1);</span><br><span class="line">            -webkit-transform: rotateX(90deg) translateZ(100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">            background: rgba(0, 255, 255, 1);</span><br><span class="line">            -webkit-transform: rotateX(270deg) translateZ(100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">            background: rgba(255, 0, 255, 1);</span><br><span class="line">            -webkit-transform: rotateY(90deg) translateZ(100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span></span><br><span class="line">            background: rgba(0, 255, 0, 1);</span><br><span class="line">            -webkit-transform: rotateY(270deg) translateZ(100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span></span><br><span class="line">            background: rgba(200, 200, 0, 1);</span><br><span class="line">            -webkit-transform: translateZ(-100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(6)</span> &#123;</span></span><br><span class="line">            background: rgba(0, 0, 255, 1);</span><br><span class="line">            -webkit-transform: translateZ(100px);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.button</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            margin: 20px auto;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input &#123;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 30px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">            left: 100px;</span><br><span class="line">            top: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">            left: 200px;</span><br><span class="line">            top: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">            left: 0px;</span><br><span class="line">            top: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:nth-child(4)</span> &#123;</span></span><br><span class="line">            left: 100px;</span><br><span class="line">            top: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:nth-child(5)</span> &#123;</span></span><br><span class="line">            left: 100px;</span><br><span class="line">            top: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> run &#123;</span></span><br><span class="line">            0% &#123;</span><br><span class="line">                -webkit-transform: rotateX(0deg) rotateY(0deg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            100% &#123;</span><br><span class="line">                -webkit-transform: rotateX(360deg) rotateY(360deg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"上"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"右"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"左"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"下"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            ul.style.webkitTransition = <span class="string">'-webkit-transform 3s linear'</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (inputs[<span class="number">0</span>] == <span class="keyword">this</span>) &#123;</span></span><br><span class="line">                x += 90;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (inputs[<span class="number">1</span>] == <span class="keyword">this</span>) &#123;</span></span><br><span class="line">                y += 90;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (inputs[<span class="number">2</span>] == <span class="keyword">this</span>) &#123;</span></span><br><span class="line">                y -= 90;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (inputs[<span class="number">3</span>] == <span class="keyword">this</span>) &#123;</span></span><br><span class="line">                x -= 90;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (inputs[<span class="number">4</span>] == <span class="keyword">this</span>) &#123;</span></span><br><span class="line">                x = 0;</span><br><span class="line">                y = 0;</span><br><span class="line"><span class="actionscript">                ul.style.webkitTransition = <span class="string">'-webkit-transform 0.1s linear'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            ul.style.webkitTransform = <span class="string">"rotateX("</span> + x + <span class="string">"deg) rotateY("</span> + y + <span class="string">"deg)"</span>; <span class="comment">//变换效果（沿X轴和Y轴旋转）</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; inputs.length; i++) &#123;</span></span><br><span class="line">            inputs[i].onclick = run;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            ul.style.webkitTransition = <span class="string">'-webkit-transform 3s linear'</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">switch</span> (e.keyCode) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">case</span> <span class="number">37</span>: y -= <span class="number">90</span>;    <span class="comment">//左箭头</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">case</span> <span class="number">38</span>: x += <span class="number">90</span>;    <span class="comment">//上箭头</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">case</span> <span class="number">39</span>: y += <span class="number">90</span>;    <span class="comment">//下箭头</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">case</span> <span class="number">40</span>: x -= <span class="number">90</span>;    <span class="comment">//右箭头</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">case</span> <span class="number">13</span>: x = <span class="number">0</span>; y = <span class="number">0</span>;    <span class="comment">//回车 （当回车时，迅速转回初始状态）</span></span></span><br><span class="line"><span class="actionscript">                    ul.style.webkitTransition = <span class="string">'-webkit-transform 0.1s linear'</span>;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            ul.style.webkitTransform = <span class="string">"rotateX("</span> + x + <span class="string">"deg) rotateY("</span> + y + <span class="string">"deg)"</span>; <span class="comment">//变换效果（沿X轴和Y轴旋转）</span></span></span><br><span class="line"><span class="actionscript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-三维透视距离perspective属性"><a href="#4-3-三维透视距离perspective属性" class="headerlink" title="4.3 三维透视距离perspective属性"></a>4.3 三维透视距离perspective属性</h3><p>perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。</p>
<p>当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</p>
<p>perspective CSS属性确定了z=0平面与用户之间的距离，以便为3d定位的元素提供一些透视图。每个带有z&gt;0的三维元素变得更大;每个z&lt;0的3d元素变得更小。效果的强度由该属性的值决定。</p>
<p><strong>注释：</strong>perspective 属性只影响 3D 转换元素。</p>
<p><strong>提示：</strong>请与 <a href="https://www.w3school.com.cn/cssref/pr_perspective-origin.asp" target="_blank" rel="noopener">perspective-origin</a> 属性一同使用该属性，这样您就能够改变 3D 元素的底部位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perspective: number|none;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>number</em></td>
<td align="left">元素距离视图的距离，以像素计。</td>
</tr>
<tr>
<td align="left">none</td>
<td align="left">默认值。与 0 相同。不设置透视。</td>
</tr>
</tbody></table>
<h2 id="5-选择器"><a href="#5-选择器" class="headerlink" title="5.选择器"></a>5.选择器</h2><p>css3提供的选择器可以让我们的开发，更加方便！</p>
<p>参见1.3节或者<a href="https://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/cssref/css_selectors.asp</a></p>
<h2 id="6-阴影"><a href="#6-阴影" class="headerlink" title="6.阴影"></a>6.阴影</h2><p>以前没有css3的时候，或者需要兼容低版本浏览器的时候，阴影只能用图片实现，但是现在不需要，css3就提供了！</p>
<h3 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6-1.语法"></a>6-1.语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置<span class="selector-tag">inset</span>就是从外往里）;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-栗子"><a href="#6-1-栗子" class="headerlink" title="6-1.栗子"></a>6-1.栗子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#09f</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-id">#888888</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-边框"><a href="#7-边框" class="headerlink" title="7.边框"></a>7.边框</h2><h3 id="7-1-边框图片"><a href="#7-1-边框图片" class="headerlink" title="7-1.边框图片"></a>7-1.边框图片</h3><h4 id="7-1-1-语法"><a href="#7-1-1-语法" class="headerlink" title="7-1-1.语法"></a>7-1-1.语法</h4><p>border-image 属性是一个简写属性，用于设置以下属性：</p>
<ul>
<li>border-image-source</li>
<li>border-image-slice</li>
<li>border-image-width</li>
<li>border-image-outset</li>
<li>border-image-repeat</li>
</ul>
<table>
<thead>
<tr>
<th><em>border-image-source</em></th>
<th>用在边框的图片的路径。</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em>border-image-slice</em></td>
<td>图片边框向内偏移。</td>
<td></td>
</tr>
<tr>
<td><em>border-image-width</em></td>
<td>图片边框的宽度。</td>
<td></td>
</tr>
<tr>
<td><em>border-image-outset</em></td>
<td>边框图像区域超出边框的量。</td>
<td></td>
</tr>
<tr>
<td><em>border-image-repeat</em></td>
<td>图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* source | slice */</span></span><br><span class="line"><span class="selector-tag">border-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">blue</span>) 27;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source | slice | repeat */</span></span><br><span class="line">border-image: url("/images/border.png") 27 space;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source | slice | width */</span></span><br><span class="line">border-image: linear-gradient(red, blue) 27 / 35px;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source | slice | width | outset | repeat */</span></span><br><span class="line">border-image: url("/images/border.png") 27 23 / 50px 30px / 1rem round space;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-栗子"><a href="#7-1-2-栗子" class="headerlink" title="7-1-2.栗子"></a>7-1-2.栗子</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            border: 15px solid transparent;</span><br><span class="line">            border-image: url(https://www.runoob.com/images/border.png) 27 round;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="7-2-边框圆角"><a href="#7-2-边框圆角" class="headerlink" title="7-2.边框圆角"></a>7-2.边框圆角</h3><h4 id="7-2-1-语法"><a href="#7-2-1-语法" class="headerlink" title="7-2-1.语法"></a>7-2-1.语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-radius: n1,n2,n3,n4;</span><br><span class="line">border-radius: n1,n2,n3,n4&#x2F;n1,n2,n3,n4;</span><br><span class="line">&#x2F;*n1-n4四个值的顺序是：左上角，右上角，右下角，左下角。*&#x2F;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-栗子"><a href="#7-2-2-栗子" class="headerlink" title="7-2-2.栗子"></a>7-2-2.栗子</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span><span class="selector-pseudo">:2px</span> <span class="selector-tag">solid</span> <span class="selector-id">#a1a1a1</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:10px</span> 40<span class="selector-tag">px</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#dddddd</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">border-radius</span><span class="selector-pseudo">:25px</span> 0 25<span class="selector-tag">px</span> 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>border-radius<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-背景"><a href="#8-背景" class="headerlink" title="8.背景"></a>8.背景</h2><p>这一块主要讲css3提供背景的三个属性</p>
<h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h3><p>background-clip CSS属性设置元素的背景是否扩展到其边框框、填充框或内容框之下。</p>
<p>border-box<br>背景延伸到边界的外部边缘(但在z顺序中是在边界下面)。<br>padding-box<br>背景延伸到填充的外部边缘。边界下面没有背景。<br>Content-box<br>背景是在内容框内绘制的。<br>text<br>背景是在前景文本中绘制的。</p>
<h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h3><p>background-origin CSS属性设置背景的原点:从边框开始，在边框内，或在填充内</p>
<p>border-box<br>背景位置相对于边框框。<br>padding-box<br>背景位置相对于填充框。<br>content-box<br>背景位置相对于内容框。</p>
<h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><p>background-size CSS属性设置元素背景图像的大小。图像可以保留其自然大小、拉伸或约束以适应可用空间。</p>
<p><strong>contain</strong><br>在不裁剪或拉伸图像的情况下，使图像尽可能大。<br><strong>cover</strong><br>在不拉伸图像的情况下，将图像缩放到尽可能大的尺寸。如果图像的比例与元素不同，它会被垂直或水平裁剪，这样就不会留下空白。<br><strong>auto</strong><br>将背景图像按相应的方向缩放，以保持其固有比例。<br><length><br>将相应维度中的图像拉伸到指定的长度。不允许有负值。<br>&lt; percentage&gt;百分比<br>将相应尺寸的图像拉伸到背景定位区域的指定百分比。背景定位区域由background-origin的值(默认情况下，填充框)决定。但是，如果背景的background-attachment值是固定的，那么定位区域就是整个视口。不允许有负值。</p>
<h3 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h3><p>栗子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#box</span> &#123;</span></span><br><span class="line">            width: 600px;</span><br><span class="line">            height: 600px;</span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 15<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(0,0,0,<span class="selector-class">.3</span>);</span></span><br><span class="line">            padding: 20px;</span><br><span class="line">            background: top / contain no-repeat url(https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3252521864,872614242&amp;fm=26&amp;gp=0.jpg),</span><br><span class="line">            bottom / contain no-repeat url(https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2853553659,1775735885&amp;fm=26&amp;gp=0.jpg);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-倒影box-reflect"><a href="#9-倒影box-reflect" class="headerlink" title="9.倒影box-reflect"></a>9.倒影box-reflect</h2><p>比如我们要实现下述效果</p>
<p><img src="https://www.w3cplus.com/sites/default/files/styles/print_image/public/blogs/2014/1405/box-reflect-1.jpg" alt=""></p>
<p>在早前要实现这样的效果我们都必须借助于类似于Photoshop这样的制作图软件来实现，然后通过引入一张image。那么除了图片，我们有没有别的方法能实现呢？值得庆幸的是，到目前为之，CSS3有一个属性<code>box-reflect</code>可以实现。那么今天我们要给大家介绍的就是这个属性的应用。</p>
<h3 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9.1 语法"></a>9.1 语法</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">box-reflect：none | &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?</span><br></pre></td></tr></table></figure>

<p>由于此属性并不是W3C标准属性，在具体使用之时，还是需要添加浏览器的私有属性，根据浏览器的兼容性，使用<code>box-reflect</code>时需要添加<code>-webkit</code>和前缀：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-webkit-box-reflect：none | &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?</span><br><span class="line">box-reflect：none | &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;?</span><br></pre></td></tr></table></figure>

<p>可惜的是在Firefox下并不支持这个属性，不过值得庆幸的是，在Firefox下可以通过<a href="https://developer.mozilla.org/en/CSS/-moz-element" target="_blank" rel="noopener"><code>-moz-element()</code></a>来模拟实现</p>
<p>其主要包括以下几个属性值：</p>
<ul>
<li><p><strong><code>none</code>:</strong>此值为<code>box-reflect</code>默认值，表示无倒影效果；</p>
</li>
<li><direction>

<p>此值表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">box-reflect</span><br></pre></td></tr></table></figure>

<p>生成倒影的方向，主要包括以下几个值：</p>
<ul>
<li><strong><code>above</code>:</strong>表示生成的倒影在对象（原图）的上方；</li>
<li><strong><code>below</code>:</strong>表示生成的倒影在对象（原图）的下方；</li>
<li><strong><code>left</code>:</strong>表示生成的倒影在对象(原图)的左侧；</li>
<li><strong><code>right</code>:</strong>表示生成的倒影在对象(原图)的右侧；</li>
</ul>
</li>
<li><p><offset> 用来设置生成倒影与对象（原图）之间的间距，其取值可以是固定的像素值，也可以是百分比值，如：</p>
<ul>
<li><strong>:</strong>使用长度值来设置生成的倒影与原图之间的间距，只要是CSS中的长度单位都可以，此值可以使用负值；</li>
<li><strong>:</strong>使用百分比来设置生成的倒影与原图之间的间距，此值也可以使用负值</li>
</ul>
</li>
<li><p><strong><mask-box-image></strong>用来设置倒影的遮罩效果，可以是背景图片，也可以是渐变生成的背景图像。</p>
</li>
</ul>
<h3 id="9-2-倒影的方向"><a href="#9-2-倒影的方向" class="headerlink" title="9.2 倒影的方向"></a>9.2 倒影的方向</h3><p><code>box-reflect</code>倒影方向跟我们CSS中的<code>margin</code>和<code>padding</code>类似，包括上、右、下、和左四个方向，每个方向都可以使用关键词来定义。下面我们能过简单的示例向大家演示这样的效果</p>
<p><strong>倒影在对象的上方</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box-reflect</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box-reflect</span> <span class="selector-tag">img</span> &#123; <span class="attribute">-webkit-box-reflect</span>: above; <span class="attribute">box-reflect</span>: above; &#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-reflect"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://img4.imgtn.bdimg.com/it/u=2853553659,1775735885&amp;fm=26&amp;gp=0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">"200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>倒影使用图片遮罩</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box-reflect</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box-reflect</span> <span class="selector-tag">img</span> &#123; </span></span><br><span class="line">            -webkit-box-reflect: above 0 url(https://user-gold-cdn.xitu.io/2017/11/15/15fbf409f492ec3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-reflect"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://img4.imgtn.bdimg.com/it/u=2853553659,1775735885&amp;fm=26&amp;gp=0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">"200"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="10-文字"><a href="#10-文字" class="headerlink" title="10.文字"></a>10.文字</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p><strong>word-break</strong></p>
<p>word-break CSS属性设置换行符是否出现在文本会溢出其内容框的地方。</p>
<p><strong>normal</strong><br>使用默认的换行规则。<br><strong>break-all</strong><br>为了防止溢出，应该在任何两个字符之间插入断字(不包括中文/日文/韩文文本)。<br><strong>keep-all</strong><br>中文/日文/韩文(CJK)文本不应使用断字。非cjk文本行为与正常情况相同。<br><strong>break-word</strong><br>与word-break: normal和overflow-wrap: anywhere具有相同的效果，而与overflow-wrap属性的实际值无关。</p>
<h3 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h3><p>这个其实有三行代码，禁止换行，超出隐藏，超出省略号<br>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;This is some long text that will not fit in the box&lt;&#x2F;div&gt;复制代码</span><br></pre></td></tr></table></figure>

<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000000</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">white-space</span>:nowrap; </span><br><span class="line">    <span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多行超出省略号"><a href="#多行超出省略号" class="headerlink" title="多行超出省略号"></a>多行超出省略号</h3><p>超出省略号。这个对于大家来说，不难！但是以前如果是多行超出省略号，就只能用js模拟！现在css3提供了多行省略号的方法！遗憾就是这个暂时只支持webkit浏览器！</p>
<p>代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:400px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">    overflow : hidden;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    -webkit-line-clamp: 2;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏这里将会超出隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样发现边框贴着难看，要撑开一点，但是撑开上下边框不要使用padding</p>
<p>正确姿势是这样写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        p &#123;</span><br><span class="line">            display: -webkit-box;</span><br><span class="line">            -webkit-line-clamp: 5;</span><br><span class="line">            -webkit-box-orient: vertical;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            text-overflow: ellipsis;</span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.3</span>);</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#555</span>;</span></span><br><span class="line">            padding: 0 20px;</span><br><span class="line">            line-height: 30px;</span><br><span class="line">            height: 150px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor, sit amet consectetur adipisicing elit. Laudantium, nam minima? Adipisci laboriosam accusantium molestias numquam necessitatibus ullam vero dolorem excepturi reiciendis voluptate veniam, animi tempora, at blanditiis autem perferendis?</span><br><span class="line">        Odio natus accusantium at obcaecati sequi dolor reiciendis minus quisquam pariatur, enim magnam explicabo, alias ratione aliquid minima ea doloribus quae repellendus excepturi perspiciatis id expedita iusto mollitia! Magni, labore?</span><br><span class="line">        Mollitia sed magnam, minus facere veritatis praesentium quia error animi rerum perferendis dolores cupiditate et voluptates dolore nostrum maiores a sequi repudiandae cumque earum veniam vero soluta. Nisi, quae vitae!</span><br><span class="line">        Mollitia placeat quod enim quia aperiam ab hic iste incidunt nostrum velit pariatur, inventore doloremque. Sit explicabo quaerat perferendis dolorum rem. Vel alias possimus laboriosam quidem distinctio natus commodi molestias.</span><br><span class="line">        Assumenda, rem alias maiores quidem dolore ratione aliquid aspernatur at! Inventore deserunt corrupti quo repellendus laboriosam sit aliquam nulla non magni cum ipsum, voluptatibus officia ab commodi assumenda asperiores fuga.</span><br><span class="line">        Voluptates, velit dolor? Ut debitis perferendis ducimus natus eligendi molestiae dolores porro facere eveniet, nisi sunt quo! Rem eum ad eius, deleniti hic pariatur earum mollitia animi maiores rerum perferendis!</span><br><span class="line">        Excepturi eaque illum at quibusdam dolore voluptatum recusandae ducimus accusantium corrupti, vero quos atque nam suscipit, officiis perspiciatis quaerat a. Et rerum nulla quod expedita id est libero officiis voluptate?</span><br><span class="line">        Doloremque consequuntur sit tempore, ratione commodi praesentium magnam magni ex a, facere quae, et assumenda eligendi culpa aperiam! Officiis soluta iure aspernatur libero esse voluptas provident quod consequatur nulla impedit.</span><br><span class="line">        Quo non, veniam nemo labore corrupti voluptas adipisci laboriosam nisi obcaecati eaque laborum facere sed accusantium? Vitae, quidem reiciendis. Maxime amet dicta iusto quisquam alias assumenda ullam labore quibusdam deleniti!</span><br><span class="line">        Odit dolores, enim et libero quo magni, reprehenderit eos quidem esse similique explicabo! Possimus ex, harum, quod temporibus numquam itaque perspiciatis quia inventore perferendis adipisci voluptatem rem quae alias sunt!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>语法：text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。<br>栗子：<code>text-shadow: 0 0 10px #f00;</code></p>
<h2 id="11-颜色"><a href="#11-颜色" class="headerlink" title="11.颜色"></a>11.颜色</h2><p>这个其实就是css3提供了新的颜色表示方法。</p>
<h3 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h3><p>一个是rgba（rgb为颜色值，a为透明度）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">rgba</span>(255,00,00,1);</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(00,00,00,<span class="selector-class">.5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h3><p>h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color: hsla( 112, 72%, 33%, 0.68);</span><br><span class="line">background-color: hsla( 49, 65%, 60%, 0.68);复制代码</span><br></pre></td></tr></table></figure>

<h2 id="12-渐变"><a href="#12-渐变" class="headerlink" title="12.渐变"></a>12.渐变</h2><p>css3的渐变可以说是一大亮点，提供了<strong>线性渐变</strong>，<strong>径向渐变</strong><br>渐变这一部分，由于用法灵活，功能也强大，这个写起来很长，写一点又感觉没什么意思，我这里贴几个链接教程给大家，在文章我不多说了，毕竟我也是从那几个地方学的，他们写得也是比我好，比我详细！</p>
<p><a href="http://dev.w3.org/csswg/css3-images/" target="_blank" rel="noopener">CSS3 Gradient</a>分为<a href="http://lists.w3.org/Archives/Public/www-style/2011Apr/0083.html" target="_blank" rel="noopener">linear-gradient</a>(线性渐变)和<a href="http://lists.w3.org/Archives/Public/www-style/2011Feb/0537.html" target="_blank" rel="noopener">radial-gradient</a>(径向渐变)。而我们今天主要是针对线性渐变来剖析其具体的用法。为了更好的应用<a href="http://dev.w3.org/csswg/css3-images/" target="_blank" rel="noopener">CSS3 Gradient</a>,我们需要先了解一下目前的几种现代浏览器的内核，主流内容主要有<a href="http://www.mozilla.org/" target="_blank" rel="noopener">Mozilla</a>（Gecko）（熟悉的有Firefox，Flock等浏览器）、<a href="http://www.webkit.org/" target="_blank" rel="noopener">WebKit</a>（熟悉的有Safari、Chrome等浏览器）、<a href="http://www.opera.com/" target="_blank" rel="noopener">Opera</a>(presto)（Opera浏览器）、Trident（讨厌的IE浏览器）。本文照常忽略IE不管，我们主要看看在Mozilla、Webkit、Opera下的应用，当然在IE下也可以实现，他需要通过IE特有的滤镜来实现。</p>
<h3 id="12-1-线性渐变在Mozilla下的应用"><a href="#12-1-线性渐变在Mozilla下的应用" class="headerlink" title="12.1 线性渐变在Mozilla下的应用"></a>12.1 <strong>线性渐变在Mozilla下的应用</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-moz-linear-gradient</span>( <span class="selector-attr">[&lt;point&gt; || &lt;angle&gt;,]</span>? &lt;<span class="selector-tag">stop</span>&gt;, &lt;<span class="selector-tag">stop</span>&gt; <span class="selector-attr">[, &lt;stop&gt;]</span>* )</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong>其共有三个参数，第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。如图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/moz-gradient.png" alt="img"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.linear-box</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: -moz-linear-gradient(left top, red, green);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"linear-box"</span>&gt;</span></span><br><span class="line">        linear-gradient</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-2-线性渐变在Webkit下的应用"><a href="#12-2-线性渐变在Webkit下的应用" class="headerlink" title="12.2 线性渐变在Webkit下的应用"></a>12.2 <strong>线性渐变在Webkit下的应用</strong></h3><p><strong>语法：</strong></p>
<p><img src="http://www.w3cplus.com/sites/default/files/webkit-gradient.png" alt="img"></p>
<p><img src="http://www.w3cplus.com/sites/default/files/wekit-gradient-new.png" alt="img"></p>
<p>参数：**-webkit-gradient是webkit引擎对渐变的实现参数，一共有五个。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（径向渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如 left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">-webkit-gradient</span>(<span class="selector-tag">linear</span>,<span class="selector-tag">center</span> <span class="selector-tag">top</span>,<span class="selector-tag">center</span> <span class="selector-tag">bottom</span>,<span class="selector-tag">from</span>(<span class="selector-id">#ccc</span>), <span class="selector-tag">to</span>(<span class="selector-id">#000</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-linear-gradient</span>(<span class="selector-tag">top</span>,<span class="selector-id">#ccc</span>,<span class="selector-id">#000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="12-3-线性渐变在Opera下的应用"><a href="#12-3-线性渐变在Opera下的应用" class="headerlink" title="12.3 线性渐变在Opera下的应用"></a>12.3 <strong>线性渐变在Opera下的应用</strong></h3><p>参数：-o-linear-gradient有三个参数。第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。（注：Opera支持的版本有限，本例测试都是在Opera11.1版本下，后面不在提示），如图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/opera-gradient.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">-o-linear-gradient</span>(<span class="selector-tag">top</span>,<span class="selector-id">#ccc</span>, <span class="selector-id">#000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="12-4-线性渐变在Trident-IE-下的应用"><a href="#12-4-线性渐变在Trident-IE-下的应用" class="headerlink" title="12.4 线性渐变在Trident (IE)下的应用"></a>12.4 <strong>线性渐变在Trident (IE)下的应用</strong></h3><p><strong>语法：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0, startColorstr=#1471da, endColorstr=#1C85FB);/*IE&lt;9&gt;*/</span><br><span class="line">-ms-filter: "progid:DXImageTransform.Microsoft.gradient (GradientType=0, startColorstr=#1471da, endColorstr=#1C85FB)";/*IE8+*/</span><br></pre></td></tr></table></figure>

<p>IE依靠滤镜实现渐变。startColorstr表示起点的颜色，endColorstr表示终点颜色。GradientType表示渐变类型，0为缺省值，表示垂直渐变，1表示水平渐变。如图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/ie-gradient-filter.png" alt="img"></p>
<h3 id="12-5-重复线性渐变"><a href="#12-5-重复线性渐变" class="headerlink" title="12.5 重复线性渐变"></a>12.5 重复线性渐变</h3><p>使用repeating-linear-gradient来实现重复线性渐变</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line">      transparent,</span><br><span class="line">      transparent <span class="number">20px</span>,</span><br><span class="line">      black <span class="number">20px</span>,</span><br><span class="line">      black <span class="number">40px</span>);</span><br><span class="line">  <span class="comment">/* with multiple color stop lengths */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>, </span><br><span class="line">      transparent <span class="number">0</span> <span class="number">20px</span>, </span><br><span class="line">      black <span class="number">20px</span> <span class="number">40px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-6-径向渐变"><a href="#12-6-径向渐变" class="headerlink" title="12.6 径向渐变"></a>12.6 径向渐变</h3><p>CSS3径向渐变是圆形或椭圆形渐变。颜色不再沿着一条直线轴变化，而是从一个起点朝所有方向混合。</p>
<p>radial-gradient() 参数的组成部分主要包括五大部分：<strong>形状、大小、圆心位置、颜色和颜色位置</strong>。</p>
<p>接下来我将以具体实例对这五大部分逐一进行讲解。首先，定义一个200*150的矩形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width: 200px; height: 150px;</span><br></pre></td></tr></table></figure>

<h4 id="一、传入两个或多个颜色参数"><a href="#一、传入两个或多个颜色参数" class="headerlink" title="一、传入两个或多个颜色参数"></a>一、传入两个或多个颜色参数</h4><p>同样以红色到黄色渐变为例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-id">#f00</span>,<span class="selector-id">#ff0</span>);</span><br></pre></td></tr></table></figure>

<p>显示效果很简单，就是一个以矩形中心点为圆心、矩形宽高为横纵向直径、颜色由红到黄向外的渐变</p>
<p>当然，与线性渐变类似的，同样可以传入更多的颜色参数，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-id">#f00</span>,<span class="selector-id">#ff0</span>,<span class="selector-id">#0f0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="二、传入颜色位置参数"><a href="#二、传入颜色位置参数" class="headerlink" title="二、传入颜色位置参数"></a>二、传入颜色位置参数</h4><p>该参数紧跟与颜色值之后，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">radial-gradient</span>(<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>以上效果同图一，同样可以类比线性渐变，具体不再赘述。</p>
<h4 id="三、传入渐变形状参数"><a href="#三、传入渐变形状参数" class="headerlink" title="三、传入渐变形状参数"></a>三、传入渐变形状参数</h4><p>渐变形状有两种：圆（<code>cicle</code>）和椭圆（<code>ellipse</code>）。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>显示效果是一个圆形状的渐变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">ellipse</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>显示效果是一个椭圆形状的渐变：</p>
<h4 id="四、传入渐变大小参数"><a href="#四、传入渐变大小参数" class="headerlink" title="四、传入渐变大小参数"></a>四、传入渐变大小参数</h4><h5 id="1-具体数值（或百分比）"><a href="#1-具体数值（或百分比）" class="headerlink" title="1. 具体数值（或百分比）"></a>1. 具体数值（或百分比）</h5><p>除了可以像上述显式地声明渐变形状，我们也可以通过传入渐变大小参数来确定形状，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(60<span class="selector-tag">px</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>此处只传入一个大小参数，则表示该渐变形状为圆，并且<strong>半径</strong>大小为60px</p>
<p>若传入两个大小不同的参数，则表示该渐变形状为椭圆，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(50% 60<span class="selector-tag">px</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>效果为长半轴为100px（元素宽度的50%）、短半轴为60px的椭圆形渐变</p>
<p>我们也可以在声明渐变形状的同时在其后紧跟渐变大小，中间用空格隔开</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> 60<span class="selector-tag">px</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">ellipse</span> 50% 60<span class="selector-tag">px</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，<strong>若渐变形状为圆形，则该渐变大小不能为百分数，而椭圆既可以为具体数值也可以为百分数</strong>，个人认为或许是因为圆形半径若为百分数的话就无法确定是以元素的宽为标准还是以高为标准了。</p>
<h5 id="2-大小声明"><a href="#2-大小声明" class="headerlink" title="2. 大小声明"></a>2. 大小声明</h5><p>一共有以下四种：</p>
<blockquote>
<p>closest-side （指定径向渐变的半径长度为从圆心到离圆心最近的边）<br> closest-corner （指定径向渐变的半径长度为从圆心到离圆心最近的角）<br> farthest-side （指定径向渐变的半径长度为从圆心到离圆心最远的边）<br> farthest-corner （指定径向渐变的半径长度为从圆心到离圆心最远的角）</p>
</blockquote>
<p>以 <code>closest-side</code> 为例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">closest-side</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<h4 id="五、传入渐变圆心位置参数"><a href="#五、传入渐变圆心位置参数" class="headerlink" title="五、传入渐变圆心位置参数"></a>五、传入渐变圆心位置参数</h4><h5 id="1-具体数值（或百分数）"><a href="#1-具体数值（或百分数）" class="headerlink" title="1. 具体数值（或百分数）"></a>1. 具体数值（或百分数）</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">farthest-side</span> <span class="selector-tag">at</span> 0 0,<span class="selector-id">#f00</span> 0%,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p>效果为圆心位置位于元素左上角，半径为元素宽度的圆形渐变</p>
<h5 id="2-方位名称"><a href="#2-方位名称" class="headerlink" title="2. 方位名称"></a>2. 方位名称</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">closest-side</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">farthest-side</span> <span class="selector-tag">at</span> <span class="selector-tag">top</span> <span class="selector-tag">left</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#ff0</span> 100%);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 圆心位置参数一定要置于<code>radial-gradient()</code>第一个参数的末尾，顺序千万不能放反了哦~~</p>
<h4 id="六、重复渐变"><a href="#六、重复渐变" class="headerlink" title="六、重复渐变"></a>六、重复渐变</h4><p>虽然上面已经讲完径向渐变的五大组成部分，但是，与线性渐变一样，径向渐变也同样还存在着重复渐变，我们可以用<code>repeating-radial-gradient()</code>来实现。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">repeating-radial-gradient</span>(<span class="selector-tag">circle</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>,<span class="selector-id">#f00</span> 0,<span class="selector-id">#f00</span> 10%,<span class="selector-id">#ff0</span> 10%,<span class="selector-id">#ff0</span> 20%);</span><br></pre></td></tr></table></figure>

<h2 id="13-Filter（滤镜）"><a href="#13-Filter（滤镜）" class="headerlink" title="13.Filter（滤镜）"></a>13.Filter（滤镜）</h2><p>css3的滤镜filter属性，可以对网页中的图片进行类似Photoshop图片处理的效果。</p>
<p>浏览器支持情况：只有IE浏览器不支持filter（滤镜）属性，为了兼容低版本的safari和google浏览器，需要加上前缀-webkit-</p>
<p><strong>filter（滤镜）属性现在规范中支持的效果有：</strong></p>
<ol>
<li>grayscale 灰度（值为0-1之间的小数）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:grayscale(1)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:grayscale(1)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示灰度为0%，显示原图，1 表示灰度为100%灰色。</p>
<ol start="2">
<li>sepia 褐色（值为0-1之间的小数）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:sepia(1)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:sepia(1)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示褐色度为0%，显示原图，1 表示褐色度为100%显示褐色。</p>
<ol start="3">
<li>saturate 饱和度（值为num）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:saturate(1.8)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:saturate(1.8)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示饱和为0，图片显示黑白色，0.5表示饱和度为原图的一半，1表示饱和度等于原图，数值大于1表示饱和度加强。</p>
<ol start="4">
<li>hue-rotate 色相旋转（值为angle）角度deg</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:hue-rotate(60deg)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:hue-rotate(60deg)</span>;</span><br></pre></td></tr></table></figure>

<p>表示色相旋转的具体角度。</p>
<ol start="5">
<li>invert 反色（值为0-1之间的小数）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:invert(1)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:invert(1)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示不反色显示原图，1表示100%完全反色。</p>
<ol start="6">
<li>opacity 透明度（值为0-1之间的小数）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:opacity(0.5)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:opacity(0.5)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示完全透明，0.5表示半透明，1表示100%完全不透明。</p>
<ol start="7">
<li>brightness 亮度（值为num）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:brightness(2)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:brightness(2)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示亮度为0，显示黑色，0.5表示亮度为原图的一半，1表示原图亮度，数值大于1表示亮度加强。</p>
<ol start="8">
<li>contrast 对比度（值为num）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:contrast(1.8)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:contrast(1.8)</span>;</span><br></pre></td></tr></table></figure>

<p>0表示对比度为0，为纯色，0.5表示对比度为原图的一半，1为原图对比度，数值大于1，值越大，对比度越强。</p>
<ol start="9">
<li>blur 模糊（值为length）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:blur(5px)</span>; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:blur(5px)</span>;</span><br></pre></td></tr></table></figure>

<p>表示虚化程度像素值。</p>
<ol start="10">
<li>drop-shadow 阴影</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:drop-shadow(0</span> 0 10<span class="selector-tag">px</span> <span class="selector-id">#000</span>);</span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:drop-shadow(0</span> 0 10<span class="selector-tag">px</span> <span class="selector-id">#000</span>);</span><br></pre></td></tr></table></figure>

<p>和css3 box-shadow属性值一致。多个属性值可以写一起，用空格隔开，类似transform多属性写法</p>
<h2 id="14-弹性布局-FlexBox"><a href="#14-弹性布局-FlexBox" class="headerlink" title="14.弹性布局(FlexBox)"></a>14.弹性布局(FlexBox)</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>行内元素也可以使用 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<h3 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<h3 id="14-2-容器的属性"><a href="#14-2-容器的属性" class="headerlink" title="14.2 容器的属性"></a>14.2 容器的属性</h3><p>以下6个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h4 id="14-2-1-flex-direction设置主轴方向"><a href="#14-2-1-flex-direction设置主轴方向" class="headerlink" title="14.2.1 flex-direction设置主轴方向"></a>14.2.1 flex-direction设置主轴方向</h4><p>它可能有4个值。</p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p>
<h4 id="14-2-3-flex-wrap设置flex布局的换行方式"><a href="#14-2-3-flex-wrap设置flex布局的换行方式" class="headerlink" title="14.2.3 flex-wrap设置flex布局的换行方式"></a>14.2.3 flex-wrap设置flex布局的换行方式</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可能取三个值。</p>
<p>（1）<code>nowrap</code>（默认）：不换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p>
<h4 id="14-2-4-flex-flow简写flex-direction和flex-wrap"><a href="#14-2-4-flex-flow简写flex-direction和flex-wrap" class="headerlink" title="14.2.4 flex-flow简写flex-direction和flex-wrap"></a>14.2.4 flex-flow简写flex-direction和flex-wrap</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<h4 id="14-2-5-justify-content属性"><a href="#14-2-5-justify-content属性" class="headerlink" title="14.2.5 justify-content属性"></a>14.2.5 justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h4 id="14-2-6-align-items属性"><a href="#14-2-6-align-items属性" class="headerlink" title="14.2.6 align-items属性"></a>14.2.6 align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h4 id="14-2-7-align-content属性"><a href="#14-2-7-align-content属性" class="headerlink" title="14.2.7 align-content属性"></a>14.2.7 align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p>
<p>该属性可能取6个值。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<p>多轴我的理解为：flex-flow 中有一个属性，nowrap 和 wrap 这表示当主轴一次性不能排下这么多元素的时候，采取的排序方法，wrap的意思就是一行排不下了，换到下一行来展示，如果下一行还是展示不下，就再换到下一行。</p>
<p>如果flex-flow设置为row的话，采用wrap方法展示了3行。那么就有3个主轴平行的，那么就属于多轴了。</p>
<h3 id="14-3-项目的属性"><a href="#14-3-项目的属性" class="headerlink" title="14.3 项目的属性"></a>14.3 项目的属性</h3><p>以下6个属性设置在项目上。</p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h5 id="14-3-1-order"><a href="#14-3-1-order" class="headerlink" title="14.3.1 order"></a>14.3.1 order</h5><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p>
<h5 id="14-3-2-fle-grow"><a href="#14-3-2-fle-grow" class="headerlink" title="14.3.2 fle-grow"></a>14.3.2 fle-grow</h5><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h5 id="14-3-3-flex-shrink"><a href="#14-3-3-flex-shrink" class="headerlink" title="14.3.3 flex-shrink"></a>14.3.3 flex-shrink</h5><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h5 id="14-3-4-flex-basis"><a href="#14-3-4-flex-basis" class="headerlink" title="14.3.4 flex-basis"></a>14.3.4 flex-basis</h5><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<h5 id="14-3-5-flex属性"><a href="#14-3-5-flex属性" class="headerlink" title="14.3.5 flex属性"></a>14.3.5 flex属性</h5><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h5 id="14-3-6-align-self"><a href="#14-3-6-align-self" class="headerlink" title="14.3.6 align-self"></a>14.3.6 align-self</h5><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h2 id="15-网格布局-GridLayout"><a href="#15-网格布局-GridLayout" class="headerlink" title="15.网格布局(GridLayout)"></a>15.网格布局(GridLayout)</h2><p>CSS网格布局（又称“网格”），是一种<strong>二维网格布局系统</strong>。CSS在处理网页布局方面一直做的不是很好。一开始我们用的是table（表格）布局，然后用float(浮动)，position（定位）和inline-block（行内块）布局，但是这些方法本质上是hack，遗漏了很多功能，例如垂直居中。后来出了<a href="http://peale.cn/2016/11/30/2016_11_30_flex/#more" target="_blank" rel="noopener">flexbox(盒子布局)</a>，解决了很多布局问题，但是它仅仅是一维布局，而不是复杂的二维布局，实际上它们（flexbox与grid）能很好的配合使用。Grid布局是第一个专门为解决布局问题而创建的CSS模块,2012年11月06日成立<a href="https://www.w3.org/TR/css3-grid-layout/" target="_blank" rel="noopener">草案</a>。</p>
<p>目前浏览器还不支持Grid布局，IE10和IE11支持老的语法。如果你想体验Grid布局的强大，推荐使用开通过“体验新功能”的Chrome, Opera 或 Firefox， Chrome:打开浏览器，输入<a href="chrome://flags">chrome://flags</a>，找到”experimental web platform features”，启用并重启浏览器；Opera：输入<a href="opera://flags">opera://flags</a>，与Chrome一样；Firefox:输入layout.css.grid.enabled。</p>
<h3 id="15-1-重要术语"><a href="#15-1-重要术语" class="headerlink" title="15.1 重要术语"></a>15.1 重要术语</h3><p>1.<strong>网格容器（Grid Container）</strong></p>
<p>元素应用display:grid，它是其所有网格项的父元素。下面例子container就是网格容器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2<strong>.网格项（Grid Item）</strong><br>网格容器的子元素，下面的item元素是网格项，但sub-item不是。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sub-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>网格线（Grid Line）</strong></p>
<p>组成网格线的分界线。它们可以是列网格线（column grid lines），也可以是行网格线（row grid lines）并且居于行或列的任意一侧<br>![image-20200527115221947](/Users/liwei/Library/Application Support/typora-user-images/image-20200527115221947.png)</p>
<p>4.<strong>网格轨道（Grid Track）</strong><br>两个相邻的网格线之间为网格轨道。你可以认为它们是网格的列或行，下面在第二个和第三个网格线之间的黄色部分为网格轨道。</p>
<p>![image-20200527115203607](/Users/liwei/Library/Application Support/typora-user-images/image-20200527115203607.png)</p>
<ol start="5">
<li><p><strong>网格单元（Grid Cell）</strong><br> 两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。下面行网格线1（row grid lines 1）、行网格线2（row grid lines 2）和列网格线2（column grid lines 2）、列网格线3（column grid lines 3）组成的黄色区域为网格单元。</p>
</li>
<li><p><strong>网格区（Grid Area）</strong><br> 网格区是由任意数量网格单元组成，下面行网格线1（row grid lines 1）、行网格线3（row grid lines 3）和列网格线1（column grid lines 1）、列网格线3（column grid lines3）组成的黄色区域为网格区。</p>
</li>
</ol>
<h3 id="15-2-容器属性"><a href="#15-2-容器属性" class="headerlink" title="15.2 容器属性"></a>15.2 容器属性</h3><p><strong>设置在网格容器上的属性</strong></p>
<ul>
<li>display</li>
<li>grid-template-columns</li>
<li>grid-template-rows</li>
<li>grid-template-areas</li>
<li>grid-column-gap</li>
<li>grid-row-gap</li>
<li>grid-gap</li>
<li>justify-items</li>
<li>align-items</li>
<li>justify-content</li>
<li>align-content</li>
<li>grid-auto-columns</li>
<li>grid-auto-rows</li>
<li>grid-auto-flow</li>
<li>grid</li>
</ul>
<h4 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h4><p>grid | inline-grid | subgrid;</p>
<p>属性值：</p>
<p> grid: 生成块级网格<br> inline-grid: 生成行内网格<br> subgrid: 如果网格容器本身是网格项（嵌套网格容器），此属性用来继承其父网格容器的列、行大小。</p>
<p>注：当元素设置了网格布局，<strong>column</strong>、<strong>float</strong>、<strong>clear</strong>、<strong>vertical-align</strong>属性无效。</p>
<h4 id="2-grid-template-columns和grid-template-rows"><a href="#2-grid-template-columns和grid-template-rows" class="headerlink" title="2. grid-template-columns和grid-template-rows"></a>2. grid-template-columns和grid-template-rows</h4><p> grid-template-rows: <track-size> … | <line-name> <track-size> … ;</p>
<p>设置行和列的大小，在行轨道或列轨道两边是网格线。</p>
<p>属性值：<br> track-size: 轨道大小，可以使用css长度，百分比或用分数（用fr单位）。<br> line-name: 网格线名字，你可以选择任何名字。</p>
<p>例子：<br> 当你设置行或列大小为auto时，网格会自动分配空间和网格线名称。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">25%</span> <span class="number">100px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-grid-numbers"><a href="#3-grid-numbers" class="headerlink" title="3. grid-numbers"></a>3. grid-numbers</h4><p>你也可以给网格线定义名字，注意名字需要写在[]里面。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: [first] <span class="number">40px</span> [line2] <span class="number">50px</span> [line3] auto [col4-start] <span class="number">50px</span> [five] <span class="number">40px</span> [end];</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end] <span class="number">100px</span> [third-line] auto [last-line];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-grid-names"><a href="#4-grid-names" class="headerlink" title="4.grid-names"></a>4.grid-names</h4><p>每条网格线可以有多个名字，例如上面行的第二条线有两个名字，分别是row1-end和row2-start。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end row2-start] <span class="number">25%</span> [row2-end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你定义包含重复部分，可以使用repeat()简化。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">20px</span> [col-start]) <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面等同于下面：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用fr单位可以将容器分为几等份，例如下面分成三等份。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果fr单位和实际值一起使用，设置fr的行或列将分(除了实际值)剩余部分。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-grid-template-areas"><a href="#5-grid-template-areas" class="headerlink" title="5.grid-template-areas"></a>5.grid-template-areas</h4><p>通过获取网格项中的grid-area属性值（名称），来定义网格模版。重复网格区（grid-area）名称将跨越网格单元格，‘.’代表空网格单元。</p>
<p>属性值：<br> grid-area-name: 网格项的grid-area属性值（名字）<br> ‘.’ : 空网格单元<br> none: 不定义网格区域</p>
<p>实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">            height: calc(100vh);</span><br><span class="line">            display: grid;</span><br><span class="line">            grid-gap: 15px;</span><br><span class="line">            justify-items: stretch;</span><br><span class="line">            align-items: center;</span><br><span class="line">            grid-template-rows: auto;</span><br><span class="line">            grid-template-columns: 240px auto auto;</span><br><span class="line">            grid-template-rows: 64px auto auto;</span><br><span class="line">            grid-template-areas: "header header header"</span><br><span class="line">                                "aside main main"</span><br><span class="line">                                "aside main main"</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-class">.header</span> &#123;</span></span><br><span class="line">            grid-area: header;</span><br><span class="line">            text-align: center;</span><br><span class="line">            height: 64px;</span><br><span class="line">            line-height: 64px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-tag">-webkit-linear-gradient</span>(<span class="selector-tag">right</span>, <span class="selector-tag">rgb</span>(0, 162, 255), <span class="selector-id">#03A9F4</span>);</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            font-size: 24px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> &#123;</span></span><br><span class="line">            grid-area: aside;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> &#123;</span></span><br><span class="line">            overflow: auto;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            list-style: none;</span><br><span class="line">            padding-top: 10px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            padding: 12px 16px;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#555</span>;</span></span><br><span class="line">            cursor: pointer;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span>: <span class="selector-tag">ease</span> <span class="selector-tag">all</span> <span class="selector-class">.3s</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#eee</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line">            border-bottom: none;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">aside</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#03A9F4</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">main</span> &#123;</span></span><br><span class="line">            grid-area: main;</span><br><span class="line">            overflow: auto;</span><br><span class="line">            padding: 10px 20px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">main</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line">            cursor: pointer;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">main</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span><span class="selector-pseudo">:cornflowerblue</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> <span class="selector-tag">main</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#555</span>;</span></span><br><span class="line">            font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">            word-spacing: 3px;</span><br><span class="line">            line-height: 22px;</span><br><span class="line">            text-align: justify;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">            网格布局练习实例</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块04<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块05<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块06<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块07<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块08<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块09<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块11<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块12<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块13<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块14<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块15<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块16<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块17<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块18<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块19<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>功能模块20<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>article1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    Lorem ipsum dolor sit amet consectetur adipisicing elit. Libero alias molestias aliquid minima amet sapiente ut eos? Commodi quos placeat neque ad voluptatum voluptatibus, suscipit inventore dignissimos, tempore reprehenderit doloribus.</span><br><span class="line">                    Rem quibusdam dolore sint corrupti exercitationem, fugiat, distinctio earum reprehenderit sit laudantium totam beatae necessitatibus voluptates quasi obcaecati tempora rerum ullam vel, eaque officiis minima ipsum id modi. Modi, est!</span><br><span class="line">                    Nam doloremque voluptatum laboriosam quod autem labore ut a cupiditate quia beatae minus, rerum quo eius, nobis illo totam laudantium? Reprehenderit et accusantium quae deleniti quod tempora eos dolorum similique!</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>article2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    Lorem ipsum dolor sit amet consectetur adipisicing elit. Sit, facilis animi asperiores architecto magni reiciendis recusandae accusantium maiores aperiam quis porro! Dolores nam ex reiciendis quos autem facere ullam tempora.</span><br><span class="line">                    Reiciendis eum eligendi quia perferendis saepe aperiam tempora consectetur dignissimos! Sint asperiores sunt ab, nulla eius rem perferendis culpa eos? Nesciunt, nihil labore cumque nemo minima ipsa magni unde in.</span><br><span class="line">                    Atque aperiam consequuntur eius illum nulla perferendis omnis consequatur maxime, cupiditate quia aspernatur architecto repudiandae, id adipisci debitis? Illo quasi quidem fuga ex nesciunt quas qui magni assumenda officia porro.</span><br><span class="line">                    Distinctio exercitationem officiis quae dolor quaerat amet molestias error quod atque ipsa nesciunt libero, praesentium minus ut magnam natus, sint, repudiandae laboriosam? Eius dicta pariatur modi recusandae numquam exercitationem illo.</span><br><span class="line">                    Officia optio tempore asperiores iure. Ab in itaque accusantium quasi explicabo harum sed impedit ipsa eveniet fugit aperiam neque labore, nostrum consectetur voluptatem est totam rem asperiores alias commodi debitis.</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-grid-column-gap和-grid-row-gap"><a href="#6-grid-column-gap和-grid-row-gap" class="headerlink" title="6. grid-column-gap和 grid-row-gap ;"></a>6. grid-column-gap和 grid-row-gap ;</h4><p>网格单元间距。</p>
<p>属性值：<br> line-size: 网格线间距,设置单位值。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">grid-column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">grid-row-gap</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：间隔仅仅作用在网格单元之间，不作用在容器边缘。</p>
<h4 id="7-grid-gap"><a href="#7-grid-gap" class="headerlink" title="7.grid-gap"></a>7.grid-gap</h4><p>是grid-column-gap 和 grid-row-gap简写。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">10px</span> <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：如果只设置一个值，那么grid-column-gap 和 grid-row-gap都为那个值。</p>
<h4 id="8-justify-items"><a href="#8-justify-items" class="headerlink" title="8. justify-items"></a>8. justify-items</h4><p>start | end | center | stretch（默认） ;</p>
<p>垂直于列网格线对齐，适用于网格容器里的所有网格项。</p>
<p>属性值：<br> start:   左对齐。<br> end:     右对齐。<br> center:  居中对齐。<br> stretch: 填满（默认）。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-align-items"><a href="#9-align-items" class="headerlink" title="9. align-items"></a>9. align-items</h4><p>start | end | center | stretch ;</p>
<p>垂直于行网格线对齐，适用于网格容器里的所有网格项。</p>
<p>属性值：<br> start：  顶部对齐。<br> end：    底部对齐。<br> center： 居中对齐。<br> stretch：填满（默认）。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-items</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-items</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-justify-content"><a href="#10-justify-content" class="headerlink" title="10. justify-content"></a>10. justify-content</h4><p>start | end | center | stretch | space-around | space-between | space-evenly ;</p>
<p>如果用像px非弹性单位定义的话，总网格区域大小有可能小于网格容器，这时候你可以设置网格的对齐方式（垂直于列网格线对齐）。</p>
<p>属性值：<br> start: 左对齐。<br> end: 右对齐。<br> center: 居中对齐。<br> stretch: 填满网格容器。<br> space-around: 网格项两边间距相等，网格项之间间隔是单侧的2倍。<br> space-between: 两边对齐，网格项之间间隔相等。<br> space-evenly: 网格项间隔相等。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-align-content"><a href="#11-align-content" class="headerlink" title="11. align-content"></a>11. align-content</h4><p> start | end | center | stretch | space-around | space-between | space-evenly ;</p>
<p>如果用像px非弹性单位定义的话，总网格区域大小有可能小于网格容器，这时候你可以设置网格的对齐方式（垂直于行网格线对齐）。</p>
<p>属性值：<br> start: 顶部对齐。<br> end: 底部对齐。<br> center: 居中对齐。<br> stretch: 填满网格容器。<br> space-around: 网格项两边间距相等，网格项之间间隔是单侧的2倍。<br> space-between: 两边对齐，网格项之间间隔相等。<br> space-evenly: 网格项间隔相等。</p>
<p>例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: start; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: end; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: center; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: stretch; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: space-around; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: space-between; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">align-content</span>: space-evenly; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-grid-auto-columns和-grid-auto-rows"><a href="#12-grid-auto-columns和-grid-auto-rows" class="headerlink" title="12.grid-auto-columns和 grid-auto-rows"></a>12.grid-auto-columns和 grid-auto-rows</h4><p>自动生成隐式网格轨道（列和行），当你定位网格项超出网格容器范围时，将自动创建隐式网格轨道。</p>
<p>属性值：<br> track-size: 网格轨道大小,可以是固定值，百分比或者是分数（fr单位）。</p>
<p>为了说明隐式网格轨道是怎么创建的，我们先看下面列子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">90px</span> <span class="number">90px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>grid-auto</p>
<p>这是2✖️2的网格，但是我们来用grid-column 和 grid-row给网格项定位如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">5</span> / <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>implicit-tracks</p>
<p>我们可以看出，网格项item-b定位在第五根列网格线（column line 5 ）和第六根列网格线（column line 6 ）之间。但是我们网格容器根本不存在这两条网格线，所以就用两个0宽度来填充。在这里我们可以用网格自动行（grid-auto-rows）和网格自动列（grid-auto-columns）来定义这些隐式轨道宽度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-grid-auto-flow"><a href="#13-grid-auto-flow" class="headerlink" title="13. grid-auto-flow"></a>13. grid-auto-flow</h4><p>row（默认） | column | dense ;</p>
<p>在没有设置网格项的位置时，这个属性控制网格项怎样排列。</p>
<p>属性值：<br> row: 按照行依次从左到右排列。<br> column: 按照列依次从上到下排列。<br> dense: 按先后顺序排列。</p>
<p>来看看下面结构：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-a"</span>&gt;item-a&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="item-b"&gt;item-b&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-c"</span>&gt;item-c&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="item-d"&gt;item-d&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-e"</span>&gt;item-e&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br></pre></td></tr></table></figure>

<p>下面定义5列2行网格，同时定义grid-auto-flow：row。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像下面布局网格项。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-e</span>&#123;</span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们设置了grid-auto-flow：row，item-b、item-c和item-d在行上是从左到右排列</p>
<h4 id="14-grid-template"><a href="#14-grid-template" class="headerlink" title="14. grid-template"></a>14. grid-template</h4><p>该属性是grid-template-columns, grid-template-rows和grid-template-areas的简写属性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template</span>: </span><br><span class="line">            "<span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span>" 40<span class="selector-tag">px</span></span><br><span class="line">            "<span class="selector-tag">b</span> <span class="selector-tag">c</span> <span class="selector-tag">c</span>" 40<span class="selector-tag">px</span></span><br><span class="line">            "b c c" 40px / 1fr 1fr 1fr;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">grid-template</span>: </span><br><span class="line">            "<span class="selector-tag">b</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span>" <span class="selector-tag">auto</span></span><br><span class="line">            "<span class="selector-tag">b</span> <span class="selector-tag">b</span> <span class="selector-tag">c</span>" 2<span class="selector-tag">ch</span></span><br><span class="line">            "b b c" 1em / 20% 20px 1fr;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">grid-template</span>: </span><br><span class="line">            "<span class="selector-tag">a</span> <span class="selector-tag">a</span> ." <span class="selector-tag">minmax</span>(50<span class="selector-tag">px</span>, <span class="selector-tag">auto</span>)</span><br><span class="line">            "<span class="selector-tag">a</span> <span class="selector-tag">a</span> ." 80<span class="selector-tag">px</span></span><br><span class="line">            "b b c" auto / 2em 3em auto;</span><br></pre></td></tr></table></figure>

<h4 id="15-grid"><a href="#15-grid" class="headerlink" title="15. grid"></a>15. grid</h4><p>grid: none | <grid-template-rows> / <grid-template-columns> | <grid-auto-flow> [<grid-auto-rows> [ / <grid-auto-columns>] ];</p>
<p>是一种简写形式，设置网格容器所有属性。</p>
<p>属性值：<br> none: 设置为所有属性的默认值。<br> <grid-template-rows> / <grid-template-columns>: 设置行和列的值，其他属性为默认值。<br> <grid-auto-flow> [ <grid-auto-rows> [ / <grid-auto-columns>] ] : 设置网格自动流、网格自动行、网格自动列的值，其他未设置则为默认值。</p>
<p>例子1：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid</span>: <span class="number">200px</span> auto / <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">200px</span> auto;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid</span>: column <span class="number">1</span>fr / auto;</span><br><span class="line">&#125;</span><br><span class="line">等同于</span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-auto-columns</span>: auto;</span><br></pre></td></tr></table></figure>

<p>grid属性更多的书写方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;'grid-template'&gt; values */</span></span><br><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: "<span class="selector-tag">a</span>" 100<span class="selector-tag">px</span> "<span class="selector-tag">b</span>" 1<span class="selector-tag">fr</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: <span class="selector-attr">[linename1]</span> "<span class="selector-tag">a</span>" 100<span class="selector-tag">px</span> <span class="selector-attr">[linename2]</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: "<span class="selector-tag">a</span>" 200<span class="selector-tag">px</span> "<span class="selector-tag">b</span>" <span class="selector-tag">min-content</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: "<span class="selector-tag">a</span>" <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, <span class="selector-tag">max-content</span>) "<span class="selector-tag">b</span>" 20%;</span><br><span class="line">grid: 100px / 200px;</span><br><span class="line">grid: minmax(400px, min-content) / repeat(auto-fill, 50px);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;'grid-template-rows'&gt; /</span></span><br><span class="line"><span class="comment">   [ auto-flow &amp;&amp; dense? ] &lt;'grid-auto-columns'&gt;? values */</span></span><br><span class="line">grid: 200px / auto-flow;</span><br><span class="line">grid: 30% / auto-flow dense;</span><br><span class="line">grid: repeat(3, [line1 line2 line3] 200px) / auto-flow 300px;</span><br><span class="line">grid: [line1] minmax(20em, max-content) / auto-flow dense 40%;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* [ auto-flow &amp;&amp; dense? ] &lt;'grid-auto-rows'&gt;? /</span></span><br><span class="line"><span class="comment">   &lt;'grid-template-columns'&gt; values */</span></span><br><span class="line">grid: auto-flow / 200px;</span><br><span class="line">grid: auto-flow dense / 30%;</span><br><span class="line">grid: auto-flow 300px / repeat(3, [line1 line2 line3] 200px);</span><br><span class="line">grid: auto-flow dense 40% / [line1] minmax(20em, max-content);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">grid</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>

<h4 id="16-使用-supports来判断浏览器是否支持grid布局"><a href="#16-使用-supports来判断浏览器是否支持grid布局" class="headerlink" title="16.使用@supports来判断浏览器是否支持grid布局"></a>16.使用@supports来判断浏览器是否支持grid布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@supports(display: grid) &#123;</span><br><span class="line">            <span class="selector-class">.container</span> &#123;</span><br><span class="line">                <span class="attribute">display</span>: grid;</span><br><span class="line">                <span class="attribute">grid</span>: <span class="string">"a a a"</span> <span class="number">100px</span> <span class="string">"b c c"</span> <span class="number">200px</span> <span class="string">"b c c"</span> <span class="built_in">minmax</span>(<span class="number">20em</span>, max-content) / <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.container</span> <span class="selector-class">.item-a</span> &#123;</span><br><span class="line">                <span class="attribute">grid-area</span>: a;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="selector-class">.container</span> <span class="selector-class">.item-b</span> &#123;</span><br><span class="line">                <span class="attribute">grid-area</span>: c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-win-8开始菜单效果"><a href="#17-win-8开始菜单效果" class="headerlink" title="17. win-8开始菜单效果"></a>17. win-8开始菜单效果</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> &#123;</span></span><br><span class="line">            display: grid;</span><br><span class="line">            grid-template-columns: 1fr 1fr 1fr;</span><br><span class="line">            grid-template-rows: 200px 200px 200px;</span><br><span class="line">            grid-template-areas: "a a b"</span><br><span class="line">                                 "a a c"</span><br><span class="line">                                 "d e c";</span><br><span class="line">            grid-gap: 6px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> <span class="selector-class">.red</span> &#123;</span></span><br><span class="line">            grid-area: a;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> <span class="selector-class">.light-green</span> &#123;</span></span><br><span class="line">            grid-area: b;</span><br><span class="line">            background-color: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> <span class="selector-class">.dark-green</span> &#123;</span></span><br><span class="line">            grid-area: d;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> <span class="selector-class">.orange</span> &#123;</span></span><br><span class="line">            grid-area: e;</span><br><span class="line">            background-color: orange;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.win-8</span> <span class="selector-class">.purple</span> &#123;</span></span><br><span class="line">            grid-area: c;</span><br><span class="line">            background-color: purple;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"win-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"light-green"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dark-green"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"purple"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="16-多列布局"><a href="#16-多列布局" class="headerlink" title="16.多列布局"></a>16.多列布局</h2><table>
<thead>
<tr>
<th><a href="https://www.w3school.com.cn/cssref/pr_column-count.asp" target="_blank" rel="noopener">column-count</a></th>
<th>规定元素应该被分隔的列数。</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-fill.asp" target="_blank" rel="noopener">column-fill</a></td>
<td>规定如何填充列。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-gap.asp" target="_blank" rel="noopener">column-gap</a></td>
<td>规定列之间的间隔。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-rule.asp" target="_blank" rel="noopener">column-rule</a></td>
<td>设置所有 column-rule-* 属性的简写属性。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-color.asp" target="_blank" rel="noopener">column-rule-color</a></td>
<td>规定列之间分割线的颜色。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-style.asp" target="_blank" rel="noopener">column-rule-style</a></td>
<td>规定列之间分割线的样式。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-width.asp" target="_blank" rel="noopener">column-rule-width</a></td>
<td>规定列之间分线的宽度。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-span.asp" target="_blank" rel="noopener">column-span</a></td>
<td>规定元素应该横跨的列数。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_column-width.asp" target="_blank" rel="noopener">column-width</a></td>
<td>规定列的宽度</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_columns.asp" target="_blank" rel="noopener">columns</a></td>
<td>规定设置 column-width 和 column-count 的简写属性。  当column-count和column-width同时设置时，有时候并不能同时满足。比如column-count为3，column-width为200px，而总宽度为500px，显然不能同时并存，此时就只有2行，并且宽度也可能超过200px。</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        p &#123;</span><br><span class="line">            column-gap: 20px;</span><br><span class="line"><span class="css">            <span class="selector-tag">column-rule-width</span><span class="selector-pseudo">:1px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">column-rule-color</span>:<span class="selector-id">#ff0000</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">column-rule-style</span><span class="selector-pseudo">:dotted</span>;</span></span><br><span class="line">            columns: 200px 3;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Lorem ipsum dolor sit amet consectetur adipisicing elit. Saepe dolorum, dolorem voluptatum ea sequi enim quas excepturi ratione, eius esse nulla nobis iste voluptas fugiat corporis doloribus veniam molestias reiciendis.</span><br><span class="line">        Consequuntur illum ab, corporis aliquam tempora eaque eos, excepturi provident, nobis doloribus perspiciatis dolor. Necessitatibus aliquid nostrum odio ex, dolore eius dolorem delectus quam? Quis reprehenderit ut saepe modi aut?</span><br><span class="line">        Soluta tenetur totam iure delectus cumque. Magni repellendus earum corrupti voluptatum, non voluptas harum sequi voluptatibus asperiores, reiciendis exercitationem quas. Et sunt quos officiis deleniti recusandae sapiente omnis incidunt suscipit!</span><br><span class="line">        Illo nostrum sapiente sequi dolores rerum ipsa esse repellat reiciendis, quia veniam, ipsam, quidem nulla accusamus nisi consequuntur soluta quos error. Sint voluptatum dignissimos blanditiis unde optio! Alias, iusto deserunt.</span><br><span class="line">        Deserunt itaque quis nemo repellendus amet consequatur quisquam culpa, quos, provident animi quasi. Alias, cupiditate, minus id eveniet, cum sint delectus inventore doloremque itaque facilis voluptatum impedit animi! Nemo, molestias.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="17-媒体查询"><a href="#17-媒体查询" class="headerlink" title="17.媒体查询"></a>17.媒体查询</h2><p>所谓媒体查询就是通过监测页面尺寸变化，不同媒体类型，设置不同间断点达到布局调整的一种特性</p>
<p>比如</p>
<p>如果文档宽度小于 300 像素则修改背景颜色(background-color):</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">300px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>:lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>浏览器兼容性</strong></p>
<table>
<thead>
<tr>
<th align="left">Rule</th>
<th>Chrome</th>
<th>Ie</th>
<th>Firefox</th>
<th>Safari</th>
<th>Opera</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@media</td>
<td>21</td>
<td>9</td>
<td>3.5</td>
<td>4.0</td>
<td>9</td>
</tr>
</tbody></table>
<p>可以使用内联样式来定义媒体查询样式， 也可以针对媒体查询间断点通过link标签引入不同的外部样式表</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br><span class="line">你也可以针对不同的媒体使用不同 <span class="selector-tag">stylesheets</span> :</span><br><span class="line"></span><br><span class="line">&lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-可用的媒体类型"><a href="#17-2-可用的媒体类型" class="headerlink" title="17.2 可用的媒体类型"></a>17.2 <strong>可用的媒体类型</strong></h3><table>
<thead>
<tr>
<th>all</th>
<th>用于所有设备</th>
</tr>
</thead>
<tbody><tr>
<td>aural</td>
<td>已废弃。用于语音和声音合成器</td>
</tr>
<tr>
<td>braille</td>
<td>已废弃。 应用于盲文触摸式反馈设备</td>
</tr>
<tr>
<td>embossed</td>
<td>已废弃。 用于打印的盲人印刷设备</td>
</tr>
<tr>
<td>handheld</td>
<td>已废弃。 用于掌上设备或更小的装置，如PDA和小型电话</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td>projection</td>
<td>已废弃。 用于投影设备</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕，平板电脑，智能手机等。</td>
</tr>
<tr>
<td>speech</td>
<td>应用于屏幕阅读器等发声设备</td>
</tr>
<tr>
<td>tty</td>
<td>已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备</td>
</tr>
<tr>
<td>tv</td>
<td>已废弃。 用于电视和网络电视</td>
</tr>
</tbody></table>
<h3 id="17-3-可用的媒体查询功能"><a href="#17-3-可用的媒体查询功能" class="headerlink" title="17.3 可用的媒体查询功能"></a>17.3 可用的媒体查询功能</h3><table>
<thead>
<tr>
<th>aspect-ratio</th>
<th>定义输出设备中的页面可见区域宽度与高度的比率</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0</td>
</tr>
<tr>
<td>color-index</td>
<td>定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的比率。</td>
</tr>
<tr>
<td>device-height</td>
<td>定义输出设备的屏幕可见高度。</td>
</tr>
<tr>
<td>device-width</td>
<td>定义输出设备的屏幕可见宽度。</td>
</tr>
<tr>
<td>grid</td>
<td>用来查询输出设备是否使用栅格或点阵。</td>
</tr>
<tr>
<td>height</td>
<td>定义输出设备中的页面可见区域高度。</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>
</tr>
<tr>
<td>max-color</td>
<td>定义输出设备每一组彩色原件的最大个数。</td>
</tr>
<tr>
<td>max-color-index</td>
<td>定义在输出设备的彩色查询表中的最大条目数。</td>
</tr>
<tr>
<td>max-device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>
</tr>
<tr>
<td>max-device-height</td>
<td>定义输出设备的屏幕可见的最大高度。</td>
</tr>
<tr>
<td>max-device-width</td>
<td>定义输出设备的屏幕最大可见宽度。</td>
</tr>
<tr>
<td>max-height</td>
<td>定义输出设备中的页面最大可见区域高度。</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。</td>
</tr>
<tr>
<td>max-resolution</td>
<td>定义设备的最大分辨率。</td>
</tr>
<tr>
<td>max-width</td>
<td>定义输出设备中的页面最大可见区域宽度。</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>定义输出设备中的页面可见区域宽度与高度的最小比率。</td>
</tr>
<tr>
<td>min-color</td>
<td>定义输出设备每一组彩色原件的最小个数。</td>
</tr>
<tr>
<td>min-color-index</td>
<td>定义在输出设备的彩色查询表中的最小条目数。</td>
</tr>
<tr>
<td>min-device-aspect-ratio</td>
<td>定义输出设备的屏幕可见宽度与高度的最小比率。</td>
</tr>
<tr>
<td>min-device-width</td>
<td>定义输出设备的屏幕最小可见宽度。</td>
</tr>
<tr>
<td>min-device-height</td>
<td>定义输出设备的屏幕的最小可见高度。</td>
</tr>
<tr>
<td>min-height</td>
<td>定义输出设备中的页面最小可见区域高度。</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的最小单色原件个数</td>
</tr>
<tr>
<td>min-resolution</td>
<td>定义设备的最小分辨率。</td>
</tr>
<tr>
<td>min-width</td>
<td>定义输出设备中的页面最小可见区域宽度。</td>
</tr>
<tr>
<td>monochrome</td>
<td>定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td>
</tr>
<tr>
<td>orientation</td>
<td>定义输出设备中的页面可见区域高度是否大于或等于宽度。</td>
</tr>
<tr>
<td>resolution</td>
<td>定义设备的分辨率。如：96dpi, 300dpi, 118dpcm</td>
</tr>
<tr>
<td>scan</td>
<td>定义电视类设备的扫描工序。</td>
</tr>
<tr>
<td>width</td>
<td>定义输出设备中的页面可见区域宽度。</td>
</tr>
</tbody></table>
<h2 id="19-混合模式"><a href="#19-混合模式" class="headerlink" title="19.混合模式"></a>19.混合模式</h2><p>blend-mode是CSS的一种值类型。它用于描述<strong>当元素重叠时颜色该如何展示</strong>。可以用于background-blend-mode和mix-blend-mode这两个属性。</p>
<p>当应用了混合模式后，这一属性会根据特定的算法将重叠的前景（顶）色和背景（底）色生成一个新的颜色值。</p>
<ul>
<li>mix-blend-mode属性用来定义元素与背景的混合模式，可以是元素与背景图片的混合，也可以是元素与背景色的混合</li>
<li>background-blend-mode属性用来定义背景的混合模式，可以是背景图片与背景图片的混合，也可以是背景图片和背景色的混合</li>
</ul>
<p>一个小例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        body &#123;</span><br><span class="line">            height: 100vh;</span><br><span class="line">            width: 100vw;</span><br><span class="line">            background-image: -webkit-linear-gradient(left, white 0%, white 50%, black 50%);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        h1 &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">            mix-blend-mode: difference;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引题的小例子就是用的mix-blend-mode属性，实现的是文本和背景图的混合。下面介绍一下混合模式的取值情况，我们首先学习3个术语：<strong>基色</strong>，<strong>混合色</strong>和<strong>结果色</strong>。</p>
<ul>
<li>基色：指当前图层之下的图层颜色。</li>
<li>混合色：指当前图层的颜色。</li>
<li>结果色：指混合后得到的颜色。</li>
</ul>
<h3 id="19-1-可用的混合模式值"><a href="#19-1-可用的混合模式值" class="headerlink" title="19.1 可用的混合模式值"></a>19.1 <strong>可用的混合模式值</strong></h3><ul>
<li>normal    <strong>正常</strong>    直接返回结果色</li>
<li>multiply    <strong>正片叠底</strong>    查看每个通道中的颜色信息，并将基色与混合色复合</li>
<li>screen    <strong>滤色</strong>    与“正片叠底”相反，查看每个通道的颜色信息，将图像的基色与混合色结合起来产生比两种颜色都浅的第三种颜色</li>
<li>overlay    <strong>叠加</strong>    把图像的基色与混合色相混合产生一种中间色。</li>
<li>darken    <strong>变暗</strong>    查看每个通道中的颜色信息，并选择基色或混合色中较暗的颜色作为结果色</li>
<li>lighten    <strong>变亮</strong>    查看每个通道中的颜色信息，并选择基色或混合色中较亮的颜色作为结果色</li>
<li>color-dodge    <strong>颜色减淡</strong>    查看每个通道中的颜色信息，并通过减小对比度使基色变亮以反映混合色。与黑色混合则不发生变化</li>
<li>color-burn    <strong>颜色加深</strong>    查看每个通道中的颜色信息，并通过增加对比度使基色变暗以反映混合色，如果与白色混合的话将不会产生变化</li>
<li>hard-light    <strong>强光</strong>    产生一种强光照射的效果。如果混合色比基色更亮一些，那么结果色将更亮；如果混合色比基色更暗一些，那么结果色将更暗</li>
<li>soft-light    <strong>柔光</strong>    产生一种柔光照射的效果。如果混合色比基色更亮一些，那么结果色将更亮；如果混合色比基色更暗一些，那么结果色将更暗，使图像的亮度反差增大</li>
<li>difference    <strong>差值</strong>    查看每个通道中的颜色信息，从图像中基色的亮度值减去混合色的亮度值，如果结果为负，则取正值，产生反相效果</li>
<li>exclusion    <strong>排除</strong>    与“差值”模式相似，但是具有高对比度和低饱和度的特点。比用“差值”模式获得的颜色要柔和、更明亮一些</li>
<li>hue    色相    选择基色的亮度和饱和度值与混合色进行混合而创建的效果，混合后的亮度及饱和度取决于基色，但色相取决于混合色</li>
<li>saturation    <strong>饱和度</strong>    在保持基色色相和亮度值的前提下，只用混合色的饱和度值进行着色。基色与混合色的饱和度值不同时，才使用混合色进行着色处理。若饱和度为0，则与任何混合色叠加均无变化。当基色不变的情况下，混合色图像饱和度越低，结果色饱和度越低；混合色图像饱和度越高，结果色饱和度越高</li>
<li>color    <strong>颜色</strong>    引用基色的明度和混合色的色相与饱和度创建结果色。它能够使用混合色的饱和度和色相同时进行着色，这样可以保护图像的灰色色调，但结果色的颜色由混合色决定。颜色模式可以看作是饱和度模式和色相模式的综合效果，一般用于为图像添加单色效果</li>
<li>luminosity    <strong>亮度</strong>    能够使用混合色的亮度值进行着色，而保持基色的饱和度和色相数值不变。其实就是用基色中的“色相”和“饱和度”以及混合色的亮度创建结果色</li>
</ul>
<p>如下我们可以将15中混合模式分为5类：</p>
<ol>
<li>变暗：multiply，darken，color-burn</li>
<li>变亮：screen，lighten，color-dodge</li>
<li>调整对比度：overlay，hard-light，soft-light</li>
<li>反差：difference，exclusion</li>
<li>颜色组成：hue，saturation，color，luminosity</li>
</ol>
<h3 id="19-2-isolation的使用"><a href="#19-2-isolation的使用" class="headerlink" title="19.2 isolation的使用"></a>19.2 isolation的使用</h3><p>隔离isolation的作用是创建一个堆叠上下文stacking context，主要用于与mix-blend-mode属性一起使用时，将混合模式只应用于某一个元素或某一组元素</p>
<p><strong>isolation</strong></p>
<p>初始值: auto</p>
<p>应用于: 所有元素</p>
<p>继承性: 无</p>
<p>值: auto | isolate(创建新的堆叠上下文) | initial | inherit | unset</p>
<p>实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.a</span> &#123;</span></span><br><span class="line">        background-color: rgb(0, 255, 0);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#b</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 210px;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.c</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">        padding: 2px;</span><br><span class="line">        mix-blend-mode: difference;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#d</span> &#123;</span></span><br><span class="line">        isolation: auto;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#e</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">isolation</span>: <span class="selector-tag">isolate</span>; <span class="comment">/* ID为e的div中的类c的dom元素不与父元素进行混合 */</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"a c"</span>&gt;</span>auto<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"e"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"a c"</span>&gt;</span>isolate<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="19-3-实例"><a href="#19-3-实例" class="headerlink" title="19.3 实例"></a>19.3 实例</h3><p><strong>让阴天的天空变蓝</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">            width: 600px;</span><br><span class="line">            height: 480px;</span><br><span class="line">            float: left;</span><br><span class="line">            background: url("http://p9.qhimg.com/t012932e87662183569.jpg") no-repeat fixed center/100% 100%;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">            width: 600px;</span><br><span class="line">            height: 480px;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-left: 20px;</span><br><span class="line">            background: url(http://p6.qhimg.com/t0110da9f699fc645b4.png) no-repeat top/ 160px 50px,</span><br><span class="line"></span><br><span class="line">                        url(http://p0.qhimg.com/t01628bd068d6f37961.png) no-repeat 30px 50px/ 160px 50px,</span><br><span class="line"></span><br><span class="line">                        url(http://p2.qhimg.com/t0160c558d31f4d5202.png) no-repeat 380px 60px/160px 50px,</span><br><span class="line"></span><br><span class="line">                        url(http://p9.qhimg.com/t012932e87662183569.jpg) no-repeat,</span><br><span class="line"></span><br><span class="line"><span class="css">                        <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#0aa0fe</span> 0%, <span class="selector-id">#baf5ff</span> 55%, <span class="selector-id">#85c1cb</span> 55%);</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#09a8e0</span>;</span></span><br><span class="line">            background-blend-mode: lighten, lighten, lighten, multiply, darken;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，我们通过多背景的混合实现了更好看点图像，效果图如下（左侧为未应用混合模式的效果）。我们通过渐变实现了天的渐变蓝与水的绿，并且额外增加了三朵漂浮的云朵。</p>
<p>image</p>
<p>注意，当存在多背景时，background-blend-mode混合模式的顺序与background-img属性一致。如果混合模式的值长度小于背景图的值长度，则会重复混合模式的值，循环匹配。如果大于背景图的值长度，则会被截取。</p>
<p>上述例子改造为多元素混合，基于mix-blend-mode属性来实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line"></span><br><span class="line">        margin-right: 5px;</span><br><span class="line"></span><br><span class="line">        width: 300px;</span><br><span class="line"></span><br><span class="line">        height: 200px;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-id">#0aa0fe</span> 0%, <span class="selector-id">#baf5ff</span> 55%, <span class="selector-id">#85c1cb</span> 55%);</span></span><br><span class="line"></span><br><span class="line">        background-size: 100%;</span><br><span class="line"></span><br><span class="line">        background-position: center center;</span><br><span class="line"></span><br><span class="line">        background-repeat: no-repeat;</span><br><span class="line"></span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.img</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line"></span><br><span class="line">        height: 100%;</span><br><span class="line"></span><br><span class="line">        background: url(http://p9.qhimg.com/t012932e87662183569.jpg);</span><br><span class="line"></span><br><span class="line">        background-size: 100%;</span><br><span class="line"></span><br><span class="line">        background-position: center center;</span><br><span class="line"></span><br><span class="line">        background-repeat: no-repeat;</span><br><span class="line"></span><br><span class="line">        mix-blend-mode: multiply;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cloud</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line"></span><br><span class="line">        background-size: 100%;</span><br><span class="line"></span><br><span class="line">        background-position: center center;</span><br><span class="line"></span><br><span class="line">        background-repeat: no-repeat;</span><br><span class="line"></span><br><span class="line">        mix-blend-mode: lighten;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cloud1</span> &#123;</span></span><br><span class="line">        background-image: url(http://p6.qhimg.com/t0110da9f699fc645b4.png);</span><br><span class="line"></span><br><span class="line">        left: 30px;</span><br><span class="line"></span><br><span class="line">        top: 50px;</span><br><span class="line"></span><br><span class="line">        width: 60px;</span><br><span class="line"></span><br><span class="line">        height: 20px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cloud2</span> &#123;</span></span><br><span class="line">        background-image: url(http://p0.qhimg.com/t01628bd068d6f37961.png);</span><br><span class="line"></span><br><span class="line">        left: 230px;</span><br><span class="line"></span><br><span class="line">        top: 50px;</span><br><span class="line"></span><br><span class="line">        width: 80px;</span><br><span class="line"></span><br><span class="line">        height: 30px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cloud3</span> &#123;</span></span><br><span class="line">        background-image: url(http://p2.qhimg.com/t0160c558d31f4d5202.png);</span><br><span class="line"></span><br><span class="line">        left: 130px;</span><br><span class="line"></span><br><span class="line">        top: 25px;</span><br><span class="line"></span><br><span class="line">        width: 100px;</span><br><span class="line"></span><br><span class="line">        height: 30px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cloud cloud1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cloud cloud2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cloud cloud3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>![image-20200528164121760](/Users/liwei/Library/Application Support/typora-user-images/image-20200528164121760.png)</p>
<p>在canvas和svg中也可以使用混合模式</p>
<h1 id="四-CSS响应式设计"><a href="#四-CSS响应式设计" class="headerlink" title="四. CSS响应式设计"></a>四. CSS响应式设计</h1><h2 id="3-1-CSS-Viewport"><a href="#3-1-CSS-Viewport" class="headerlink" title="3.1 CSS Viewport"></a>3.1 CSS Viewport</h2><h3 id="3-1-1-viewport的概念"><a href="#3-1-1-viewport的概念" class="headerlink" title="3.1.1 viewport的概念"></a>3.1.1 viewport的概念</h3><p>在 PC 端，视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。在 CSS 标准文档中，视口也被称为初始包含块，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度。</p>
<p>而移动端则较为复杂，它涉及到三个视口：<strong>布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）</strong>。</p>
<p>在 PC 端，视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。在 CSS 标准文档中，视口也被称为初始包含块，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度。</p>
<p>而移动端则较为复杂，它涉及到三个视口：布局视口（Layout Viewport）、视觉视口（Visual Viewport）和理想视口（Ideal Viewport）。</p>
<p>本文主要讨论移动端中的视口。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="1-1-两种像素"><a href="#1-1-两种像素" class="headerlink" title="1.1 两种像素"></a>1.1 两种像素</h4><p>像素是计算机屏幕中显示特定颜色的最小区域。屏幕中的像素越多，同一范围内能看到的内容就越多。或者说，当设备尺寸相同时，像素越密集，画面就越精细。</p>
<p>那么，当我们在 CSS 中为一个元素设置属性 <code>width: 250px;</code> 时，会发生什么？这个元素的宽度究竟是多少像素呢？</p>
<p>事实上，这里已经涉及了两种不同的像素：物理像素和 CSS 像素。</p>
<h5 id="物理像素（设备像素，device-pixels）"><a href="#物理像素（设备像素，device-pixels）" class="headerlink" title="物理像素（设备像素，device pixels）"></a>物理像素（设备像素，device pixels）</h5><p>指的是设备屏幕的物理像素，任何设备的物理像素数量都是固定的。</p>
<h5 id="CSS-像素（CSS-pixels）"><a href="#CSS-像素（CSS-pixels）" class="headerlink" title="CSS 像素（CSS pixels）"></a>CSS 像素（CSS pixels）</h5><p>是 CSS 和 JS 中使用的一个抽象概念。它和物理像素之间的比例取决于屏幕的特性（是否为高密度）以及用户进行的缩放，由浏览器自行换算。</p>
<p>在 Apple 的视网膜屏（Retina）中，每 4 个像素为一组，渲染出普通屏幕中一个像素显示区域内的图像，从而实现更为精细的显示效果。此时， 250px 的元素跨越了 500 个物理像素的宽度。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166435cbbd90a175?w=515&h=286&f=jpeg&s=24159" alt="img"></p>
<p>如果用户进行了放大，那么一个 CSS 像素还将跨越更多的物理像素。</p>
<h4 id="1-2-三种视口"><a href="#1-2-三种视口" class="headerlink" title="1.2  三种视口"></a>1.2  三种视口</h4><p>移动端浏览器通常宽度是 240px~640px，而大多数为 PC 端设计的网站宽度至少为 800px，如果仍以浏览器窗口作为视口的话，网站内容在手机上看起来会非常窄。</p>
<p>因此，引入了布局视口、视觉视口和理想视口三个概念，使得移动端中的视口与浏览器宽度不再相关联。</p>
<h5 id="布局视口（layout-viewport）"><a href="#布局视口（layout-viewport）" class="headerlink" title="布局视口（layout viewport）"></a>布局视口（layout viewport）</h5><p>一般移动设备的浏览器都默认设置了一个 viewport 元标签，定义一个虚拟的布局视口（layout viewport），用于解决早期的页面在手机上显示的问题。iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页基本能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166437dad52855dc?w=336&h=285&f=png&s=51213" alt="img"></p>
<p>布局视口的宽度/高度可以通过 <code>document.documentElement.clientWidth / Height</code> 获取。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/166438178a342bba?w=1090&h=413&f=png&s=29912" alt="img"></p>
<p>可以看到，默认的布局视口宽度为 980px。如果要显式设置布局视口，可以使用 HTML 中的 meta 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=400"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664385fa84fc26d?w=1307&h=511&f=png&s=79210" alt="img"></p>
<p>布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。</p>
<h5 id="视觉视口（visual-viewport）"><a href="#视觉视口（visual-viewport）" class="headerlink" title="视觉视口（visual viewport）"></a>视觉视口（visual viewport）</h5><p>视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16643994a5a962cf?w=323&h=292&f=png&s=50158" alt="img"></p>
<p>视觉视口和缩放比例的关系为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前缩放值 &#x3D; 理想视口宽度  &#x2F; 视觉视口宽度</span><br></pre></td></tr></table></figure>

<p>所以，当用户放大时，视觉视口将会变小，CSS 像素将跨越更多的物理像素。</p>
<h5 id="理想视口（ideal-viewport）"><a href="#理想视口（ideal-viewport）" class="headerlink" title="理想视口（ideal viewport）"></a>理想视口（ideal viewport）</h5><p>布局视口的默认宽度并不是一个理想的宽度，于是 Apple 和其他浏览器厂商引入了理想视口的概念，它对设备而言是最理想的布局视口尺寸。显示在理想视口中的网站具有最理想的宽度，用户无需进行缩放。</p>
<p>理想视口的值其实就是屏幕分辨率的值，它对应的像素叫做设备逻辑像素（device independent pixel, dip）。dip 和设备的物理像素无关，一个 dip 在任意像素密度的设备屏幕上都占据相同的空间。如果用户没有进行缩放，那么一个 CSS 像素就等于一个 dip。</p>
<p>用下面的方法可以使布局视口与理想视口的宽度一致：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上，这就是响应式布局的基础。</p>
<h3 id="2-视口的设置"><a href="#2-视口的设置" class="headerlink" title="2. 视口的设置"></a>2. 视口的设置</h3><p>我们可以使用视口元标签（viewport meta 标签）来进行布局视口的设置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是每个属性的详细说明：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>正整数或device-width</td>
<td>定义视口的宽度，单位为像素</td>
</tr>
<tr>
<td>height</td>
<td>正整数或device-height</td>
<td>定义视口的高度，单位为像素，一般不用</td>
</tr>
<tr>
<td>initial-scale</td>
<td>[0.0-10.0]</td>
<td>定义初始缩放值</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>[0.0-10.0]</td>
<td>定义放大最大比例，它必须小于或等于maximum-scale设置</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>[0.0-10.0]</td>
<td>定义缩小最小比例，它必须大于或等于minimum-scale设置</td>
</tr>
<tr>
<td>user-scalable</td>
<td>yes / no</td>
<td>定义是否允许用户手动缩放页面，默认值 yes</td>
</tr>
</tbody></table>
<p>有几点值得注意：</p>
<ul>
<li>viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的</li>
<li>当缩放比例为 100% 时，dip 宽度 = CSS 像素宽度 = 理想视口的宽度 = 布局视口的宽度</li>
<li>单独设置 initial-scale 或 width 都会有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性</li>
<li>即使设置了 user-scalable = no，在 Android Chrome 浏览器中也可以强制启用手动缩放</li>
</ul>
<h3 id="3-一倍图、二倍图、三倍图"><a href="#3-一倍图、二倍图、三倍图" class="headerlink" title="3. 一倍图、二倍图、三倍图"></a>3. 一倍图、二倍图、三倍图</h3><p>MacBook Pro 视网膜屏（Retina）显示器硬件像素是 2880px * 1800px。当设置屏幕分辨率为 1920px * 1200px 的时候，理想视口的宽度值是 1920px， 那么 dip 的宽度值就是 1920px。其与理想视口宽度的比值为1.5（2880/1920），这个比值叫做设备像素比：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逻辑像素宽度 * 设备像素比 &#x3D; 物理像素宽度</span><br></pre></td></tr></table></figure>

<p>设备像素比可以通过 <code>window.devicePixelRatio</code> 来获取，或者使用 CSS 中的 <code>device-pixel-ratio</code>。</p>
<p>下面是常见的设备像素比：</p>
<ul>
<li>普通密度桌面显示屏：<code>devicePixelRatio = 1</code></li>
<li>高密度桌面显示屏(Mac Retina)：<code>devicePixelRatio = 2</code></li>
<li>主流手机显示屏：<code>devicePixelRatio = 2 or 3</code></li>
</ul>
<p>对于一张 100px * 100px 的图片，通过 CSS 设置其宽高：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在普通显示屏的电脑中打开是正常的，但假设在手机或 Retina 屏中打开，按照逻辑分辨率来渲染，他们的 <code>devicePixelRatio = 2</code>，那么就相当于拿 4 个物理像素来描绘 1 个电子像素。这等于拿一个2倍的放大镜去看图片，图片就会变得模糊。</p>
<p>这时，就需要使用 @2x 甚至 @3x 图来避免图片的失真。</p>
<h2 id="3-2-栅格布局"><a href="#3-2-栅格布局" class="headerlink" title="3.2 栅格布局"></a>3.2 栅格布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.col-1</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 8<span class="selector-class">.33</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-2</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 16<span class="selector-class">.66</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-3</span> &#123;</span></span><br><span class="line">            width: 25%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-4</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 33<span class="selector-class">.33</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-5</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 41<span class="selector-class">.66</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-6</span> &#123;</span></span><br><span class="line">            width: 50%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-7</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 58<span class="selector-class">.33</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-8</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 66<span class="selector-class">.66</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-9</span> &#123;</span></span><br><span class="line">            width: 75%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-10</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 83<span class="selector-class">.33</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-11</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span>: 91<span class="selector-class">.66</span>%;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.col-12</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-attr">[class*=<span class="string">"col-"</span>]</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            padding: 15px;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">            content: "";</span><br><span class="line">            clear: both;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;</span><br><span class="line">        html &#123;</span><br><span class="line">            font-family: "Lucida Sans", sans-serif;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#9933cc</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">            padding: 15px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            list-style-type: none;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            padding: 8px;</span><br><span class="line">            margin-bottom: 7px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#33b5e5</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 0 1<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.12</span>), 0 1<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.24</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#0099cc</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line">            width: 25%;</span><br><span class="line">            float: left;</span><br><span class="line"><span class="css">            <span class="selector-tag">border-right</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#333</span>;</span></span><br><span class="line">            height: 100vh;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">            width: 75%;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        header</span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">menu</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span>menu<span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span></span><br><span class="line">                col-3</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-9"</span>&gt;</span></span><br><span class="line">                col-9</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box01<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box02<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box03<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box04<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-CSS-媒体查询"><a href="#3-3-CSS-媒体查询" class="headerlink" title="3.3  CSS 媒体查询"></a>3.3  CSS 媒体查询</h2><h3 id="3-3-1-使用媒体查询完善栅格系统（添加断点）"><a href="#3-3-1-使用媒体查询完善栅格系统（添加断点）" class="headerlink" title="3.3.1 使用媒体查询完善栅格系统（添加断点）"></a>3.3.1 使用媒体查询完善栅格系统（添加断点）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/* For tablets: */</span></span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-1</span> &#123;<span class="attribute">width</span>: <span class="number">8.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-2</span> &#123;<span class="attribute">width</span>: <span class="number">16.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-3</span> &#123;<span class="attribute">width</span>: <span class="number">25%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-4</span> &#123;<span class="attribute">width</span>: <span class="number">33.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-5</span> &#123;<span class="attribute">width</span>: <span class="number">41.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-6</span> &#123;<span class="attribute">width</span>: <span class="number">50%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-7</span> &#123;<span class="attribute">width</span>: <span class="number">58.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-8</span> &#123;<span class="attribute">width</span>: <span class="number">66.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-9</span> &#123;<span class="attribute">width</span>: <span class="number">75%</span>;&#125;  </span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-10</span> &#123;<span class="attribute">width</span>: <span class="number">83.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-11</span> &#123;<span class="attribute">width</span>: <span class="number">91.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-m-12</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/* For desktop: */</span></span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-1</span> &#123;<span class="attribute">width</span>: <span class="number">8.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-2</span> &#123;<span class="attribute">width</span>: <span class="number">16.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-3</span> &#123;<span class="attribute">width</span>: <span class="number">25%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-4</span> &#123;<span class="attribute">width</span>: <span class="number">33.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-5</span> &#123;<span class="attribute">width</span>: <span class="number">41.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-6</span> &#123;<span class="attribute">width</span>: <span class="number">50%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-7</span> &#123;<span class="attribute">width</span>: <span class="number">58.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-8</span> &#123;<span class="attribute">width</span>: <span class="number">66.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-9</span> &#123;<span class="attribute">width</span>: <span class="number">75%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-10</span> &#123;<span class="attribute">width</span>: <span class="number">83.33%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-11</span> &#123;<span class="attribute">width</span>: <span class="number">91.66%</span>;&#125;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.col-12</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>;&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-attr">[class*=<span class="string">"col-"</span>]</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            padding: 15px;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">            content: "";</span><br><span class="line">            clear: both;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/* For mobile phones: */</span></span></span><br><span class="line"><span class="css">            <span class="selector-attr">[class*=<span class="string">"col-"</span>]</span> &#123;</span></span><br><span class="line">                width: 100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">        &#125;</span><br><span class="line">        html &#123;</span><br><span class="line">            font-family: "Lucida Sans", sans-serif;</span><br><span class="line">            orientation: landscape;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#9933cc</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">            padding: 15px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line">            list-style-type: none;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">            padding: 8px;</span><br><span class="line">            margin-bottom: 7px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#33b5e5</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">box-shadow</span>: 0 1<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.12</span>), 0 1<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.24</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#0099cc</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line">            width: 25%;</span><br><span class="line">            float: left;</span><br><span class="line"><span class="css">            <span class="selector-tag">border-right</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#333</span>;</span></span><br><span class="line">            height: 100vh;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">            width: 75%;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        header</span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">menu</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span>menu<span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span></span><br><span class="line">                col-3</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-9"</span>&gt;</span></span><br><span class="line">                col-9</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box01<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box02<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box03<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span>box04<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-2-针对屏幕方向的媒体查询"><a href="#3-3-2-针对屏幕方向的媒体查询" class="headerlink" title="3.3.2 针对屏幕方向的媒体查询"></a>3.3.2 针对屏幕方向的媒体查询</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation:</span> landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation:</span> portrait) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript6教程</title>
    <url>/2020/06/22/2020-2020-06-22-ES6%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-let-const"><a href="#1-let-const" class="headerlink" title="1. let, const"></a>1. let, const</h1><h2 id="1-1-块级作用域"><a href="#1-1-块级作用域" class="headerlink" title="1.1 块级作用域"></a>1.1 块级作用域</h2><p>在ES5中只存在全局作用域和函数作用域，这会导致函数作用域覆盖了全局作用域，亦或者循环中的变量泄露为全局变量。</p>
<p>如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10 循环变量泄露为全局变量</span></span><br></pre></td></tr></table></figure>

<p>ES6新增了块级作用域，块级作用域外无法访问块级作用域内的变量，且存在暂时性死区(TPD)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a is not defined</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-块级作用域中的函数声明"><a href="#1-2-块级作用域中的函数声明" class="headerlink" title="1.2 块级作用域中的函数声明"></a>1.2 块级作用域中的函数声明</h2><p>ES6块级作用域具有以下特点：</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>内层作用域声明的函数不干扰外层作用域的函数。</li>
</ul>
<p>以下是块级作用域的几个实例:</p>
<p>a.允许块级作用域内声明函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//handle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.存在函数变量提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    testFn(); <span class="comment">//这里正常输出“hehehe”，表明testFn函数变量产生提升</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hehehe'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.内层作用域声明的同名函数不干扰外层作用域的同名函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    testFn(); <span class="comment">//I am outside.</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        testFn(); <span class="comment">//I am inside.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'I am inside.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I am outside.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    testFn(); <span class="comment">//I am outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>d.由于 <code>ES6</code> 规定“块级作用域内的函数声明类似于 <code>var</code> 声明的变量，默认支持变量提升”，因此，下列案例直接在支持 <code>ES6</code> 的浏览器中运行会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'outside'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="comment">// 发生函数声明提升，声明提升，但是定义不提升，因此testFn的值为undefined</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'inside'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    testFn(); <span class="comment">//Error: testFn is not a function</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="1-3-let"><a href="#1-3-let" class="headerlink" title="1.3 let"></a>1.3 let</h2><p>let 声明的变量有如下特点:</p>
<ul>
<li>只在 let 命令所在的代码块内有效</li>
<li>不能重复声明</li>
<li>不存在变量提升</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for 循环计数器很适合用 let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 0123456789</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-const"><a href="#1-4-const" class="headerlink" title="1.4 const"></a>1.4 const</h2><p>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</p>
<p>本质: 其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> b = [];</span><br><span class="line">b.push(a);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-顶层对象的属性"><a href="#1-5-顶层对象的属性" class="headerlink" title="1.5 顶层对象的属性"></a>1.5 顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象，ES5中顶层对象和全局变量是等价的，顶层对象到处可写，很容易出现不小心定义了全局变量的问题。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h2 id="1-6-globalThis对象"><a href="#1-6-globalThis对象" class="headerlink" title="1.6 globalThis对象"></a>1.6 globalThis对象</h2><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
<p>ES5中通用获取顶层对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES2020引入<code>globalThis</code>作为顶层对象，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。垫片库<code>global-this</code>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>
<h1 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h1><h2 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [d,[[e],f],g] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [x1,y1,...z] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 对于Set结构，也可以使用数组的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x2,y2,z2] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line"><span class="comment">//结构赋值允许指定默认值</span></span><br><span class="line"><span class="keyword">let</span> [i,j,k=<span class="number">30</span>] = [<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>如果解构不成功，结果为<code>undefined</code></p>
<h2 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name,age, hobby&#125; = &#123;<span class="attr">name</span>: <span class="string">"david"</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;;</span><br><span class="line"><span class="comment">// 如果解构失败值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(hobby);</span><br><span class="line"><span class="comment">// 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line"><span class="comment">// 可以用于嵌套结构的对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'hello'</span>,</span><br><span class="line">    [y: <span class="string">'World'</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [str1, &#123;<span class="attr">y</span>: str2&#125;]&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;str1&#125;</span> <span class="subst">$&#123;str2&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;p, <span class="attr">p</span>:[str1, &#123;<span class="attr">y</span>: str2&#125;]&#125; = obj;</span><br><span class="line"><span class="comment">// 对象的解构赋值也可以指定默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</span></span><br><span class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;b&#125;</span> <span class="subst">$&#123;c&#125;</span> <span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-数值和布尔值的解构赋值"><a href="#2-4-数值和布尔值的解构赋值" class="headerlink" title="2.4 数值和布尔值的解构赋值"></a>2.4 数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-函数参数的解构赋值"><a href="#2-5-函数参数的解构赋值" class="headerlink" title="2.5 函数参数的解构赋值"></a>2.5 函数参数的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数解构赋值也可以使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-解构赋值的典型应用"><a href="#2-6-解构赋值的典型应用" class="headerlink" title="2.6 解构赋值的典型应用"></a>2.6 解构赋值的典型应用</h2><p><strong>（1）交换变量的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<p><strong>（2）从函数返回多个值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>（4）提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）函数参数的默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<p><strong>（6）遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-1-对Unicode字符的更好处理"><a href="#3-1-对Unicode字符的更好处理" class="headerlink" title="3.1 对Unicode字符的更好处理"></a>3.1 对Unicode字符的更好处理</h2><p>ES5允许用<code>&quot;\u0061&quot;</code>作为字符的uncode表示形式，但是这种表示法的表示范围为<code>\u0000</code>-<code>\uFFFF</code>之间，超出这个范围的字符必须用两个双字节进行表示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript 会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// 大括号的形式和四字节的UTF-16编码是等价的</span></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-增加字符串的遍历接口"><a href="#3-2-增加字符串的遍历接口" class="headerlink" title="3.2 增加字符串的遍历接口"></a>3.2 增加字符串的遍历接口</h2><p>ES6 为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-JSON-stringify-的改造"><a href="#3-3-JSON-stringify-的改造" class="headerlink" title="3.3 JSON.stringify()的改造"></a>3.3 JSON.stringify()的改造</h2><p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的<code>JSON.stringify()</code>方法有可能返回不符合 UTF-8 标准的字符串。</p>
<p>具体来说，UTF-8 标准规定，<code>0xD800</code>到<code>0xDFFF</code>之间的码点，不能单独使用，必须配对使用。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符<code>𝌆</code>。这是为了表示码点大于<code>0xFFFF</code>的字符的一种变通方法。单独使用<code>\uD834</code>和<code>\uDFO6</code>这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p>
<p><code>JSON.stringify()</code>的问题在于，它可能返回<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// "\u&#123;D834&#125;"</span></span><br></pre></td></tr></table></figure>

<p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify" target="_blank" rel="noopener">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// ""\\uD834""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uDF06\uD834'</span>) <span class="comment">// ""\\udf06\\ud834""</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-模板字符串"><a href="#3-4-模板字符串" class="headerlink" title="3.4 模板字符串"></a>3.4 模板字符串</h2><p>用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'world'</span>;</span><br><span class="line"><span class="string">`hello <span class="subst">$&#123;str&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-标签模板"><a href="#3-5-标签模板" class="headerlink" title="3.5 标签模板"></a>3.5 标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-新增的方法"><a href="#3-6-新增的方法" class="headerlink" title="3.6 新增的方法"></a>3.6 新增的方法</h2><ul>
<li><p><strong>String.fromCodePoint</strong><br>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "ஷ"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>String.fromCharCode()</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>
</li>
<li><p><strong>String.raw</strong><br>ES6 还为原生的 String 对象，提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// 实际返回 "Hi\\n5!"，显示的是转义后的结果 "Hi\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 "Hi\\u000A!"，显示的是转义后的结果 "Hi\u000A!"</span></span><br></pre></td></tr></table></figure>

<p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></span><br><span class="line"><span class="comment">// 返回 "Hi\\\\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span> === <span class="string">"Hi\\\\n"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `foo$&#123;1 + 2&#125;bar`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>] &#125;, <span class="number">1</span> + <span class="number">2</span>) <span class="comment">// "foo3bar"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p>
<p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CodePointAt</strong><br>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>

<p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p>
<p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p>
<p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// "20bb7"</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// "61"</span></span><br></pre></td></tr></table></figure>

<p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>

<p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...<span class="string">'𠮷a'</span>]; <span class="comment">// arr.length === 2</span></span><br><span class="line">arr.forEach(</span><br><span class="line">  ch =&gt; <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>

<p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法: normalize许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<ul>
<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li>
<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>
</li>
<li><p>实例方法: <strong>includes</strong>, <strong>startsWith</strong>, <strong>endsWith</strong>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
</li>
<li><p>repeat<code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<p>参数如果是小数，会被取整。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></span><br></pre></td></tr></table></figure>

<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>

<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<p>参数<code>NaN</code>等同于 0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法，padStart,padEndES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></span><br></pre></td></tr></table></figure>

<p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</span><br><span class="line"><span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure>

<p>如果省略第二个参数，默认使用空格补全长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure>

<p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></span><br></pre></td></tr></table></figure>

<p>另一个用途是提示字符串格式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法:trimStart, trimEnd<a href="https://github.com/tc39/proposal-string-left-right-trim" target="_blank" rel="noopener">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">'  abc  '</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="comment">// "abc"</span></span><br><span class="line">s.trimStart() <span class="comment">// "abc  "</span></span><br><span class="line">s.trimEnd() <span class="comment">// "  abc"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p>
<p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>
<p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</p>
</li>
</ul>
<h1 id="4-正则的扩展"><a href="#4-正则的扩展" class="headerlink" title="4. 正则的扩展"></a>4. 正则的扩展</h1><h2 id="4-1-RegExp构造函数"><a href="#4-1-RegExp构造函数" class="headerlink" title="4.1 RegExp构造函数"></a>4.1 RegExp构造函数</h2><p>在ES5中，RegExp构造函数有以下两种用法：</p>
<ol>
<li><p>参数是字符串，这时第二个参数表示正则表达式的修饰符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个参数为一个正则表达式，这时会返回一个原有正则表达式的拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>ES5不允许此时使用第二个参数添加修饰符，否则会报错，但是ES6开始可以在这种情况下使用第二参数来添加修饰符，此时返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<h2 id="4-2-字符串的正则方法"><a href="#4-2-字符串的正则方法" class="headerlink" title="4.2 字符串的正则方法"></a>4.2 字符串的正则方法</h2><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
<h2 id="4-3-u修饰符"><a href="#4-3-u修饰符" class="headerlink" title="4.3 u修饰符"></a>4.3 u修饰符</h2><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>
<h2 id="4-4-y修饰符"><a href="#4-4-y修饰符" class="headerlink" title="4.4 y修饰符"></a>4.4 y修饰符</h2><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>
<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// ["aaa_"]</span></span><br><span class="line">r.exec(s) <span class="comment">// ["aa_"]</span></span><br></pre></td></tr></table></figure>

<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<h2 id="4-5-RegExp-prototype-flags属性"><a href="#4-5-RegExp-prototype-flags属性" class="headerlink" title="4.5 RegExp.prototype.flags属性"></a>4.5 RegExp.prototype.flags属性</h2><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>
<h2 id="4-6-dotAll模式"><a href="#4-6-dotAll模式" class="headerlink" title="4.6 dotAll模式"></a>4.6 dotAll模式</h2><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<ul>
<li>U+000A 换行符（<code>\n</code>）</li>
<li>U+000D 回车符（<code>\r</code>）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<p>ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener">引入</a><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<p>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>
<h2 id="4-7-后行断言"><a href="#4-7-后行断言" class="headerlink" title="4.7 后行断言"></a>4.7 后行断言</h2><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">'100% of US presidents have been male'</span>)  <span class="comment">// ["100"]</span></span><br><span class="line">/\d+(?!%)/.exec(<span class="string">'that’s all 44 of them'</span>)                 <span class="comment">// ["44"]</span></span><br></pre></td></tr></table></figure>

<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?。比如，只匹配不在美元符号后面的数字，要写成</code>/(?。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec('Benjamin Franklin is on the $100 bill')  /</span><span class="regexp">/ ["100"]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec('it’s is worth about €90')                /</span><span class="regexp">/ ["90"]</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。</p>
<h2 id="4-8-RegExp-Unicode属性转义"><a href="#4-8-RegExp-Unicode属性转义" class="headerlink" title="4.8 RegExp Unicode属性转义"></a>4.8 RegExp Unicode属性转义</h2><p>ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">引入</a>了一种新的类的写法<code>\p{...}</code>和<code>\P{...}</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<p>下面是几个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="regexp">/^\p&#123;White_Space&#125;+$/u</span>.test(<span class="string">'\t \n\r'</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="regexp">/^\p&#123;Script=Greek&#125;+$/u</span>.test(<span class="string">'μετά'</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如您所见，属性转义的好处之一是它们使正则表达式更具有自描述性。</p>
<h2 id="4-9-具名组匹配"><a href="#4-9-具名组匹配" class="headerlink" title="4.9 具名组匹配"></a>4.9 具名组匹配</h2><p>正则表达式使用圆括号进行组匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank" rel="noopener">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?</code>），然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">'foo:bar'</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">'2015-01-02'</span>.replace(re, <span class="string">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>数字引用（<code>\1</code>）依然有效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这两种引用语法还可以同时使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="4-10-正则匹配索引"><a href="#4-10-正则匹配索引" class="headerlink" title="4.10 正则匹配索引"></a>4.10 正则匹配索引</h2><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-regexp-match-Indices" target="_blank" rel="noopener">第三阶段提案</a>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.index <span class="comment">// 1</span></span><br><span class="line">result.indices <span class="comment">// [ [1, 3] ]</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>
<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>
<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p>
<p>下面是多个组匹配的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd(ef))/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices <span class="comment">// [ [1, 8], [4, 8], [6, 8] ]</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p>
<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices.groups <span class="comment">// &#123; Z: [ 4, 6 ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p>
<p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'zabbcdef'</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;ce)?/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">result.indices.groups[<span class="string">'Z'</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p>
<h2 id="4-11-String-prototype-matchAll"><a href="#4-11-String-prototype-matchAll" class="headerlink" title="4.11 String.prototype.matchAll"></a>4.11 String.prototype.matchAll</h2><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],</span></span><br><span class="line"><span class="comment">//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p>
<p><a href="https://github.com/tc39/proposal-string-matchall" target="_blank" rel="noopener">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'test1test2test3'</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]</span></span><br><span class="line"><span class="comment">// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.matchAll(regex)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(string.matchAll(regex))</span><br></pre></td></tr></table></figure>

<h1 id="5-数值的扩展"><a href="#5-数值的扩展" class="headerlink" title="5. 数值的扩展"></a>5. 数值的扩展</h1><h2 id="5-1-二进制和八进制表示方法"><a href="#5-1-二进制和八进制表示方法" class="headerlink" title="5.1 二进制和八进制表示方法"></a>5.1 二进制和八进制表示方法</h2><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0o10'</span>)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-Number-isFinite-Number-isNaN"><a href="#5-2-Number-isFinite-Number-isNaN" class="headerlink" title="5.2 Number.isFinite(), Number.isNaN()"></a>5.2 Number.isFinite(), Number.isNaN()</h2><p>ES6 在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。</p>
<p>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<h2 id="5-3-Number-parseInt-Number-parseFloat"><a href="#5-3-Number-parseInt-Number-parseFloat" class="headerlink" title="5.3 Number.parseInt(), Number.parseFloat()"></a>5.3 Number.parseInt(), Number.parseFloat()</h2><p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>
<h2 id="5-4-Number-isInteger"><a href="#5-4-Number-isInteger" class="headerlink" title="5.4 Number.isInteger()"></a>5.4 Number.isInteger()</h2><p><code>Number.isInteger()</code>用来判断一个数值是否为整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="5-5-Number-EPSILON"><a href="#5-5-Number-EPSILON" class="headerlink" title="5.5 Number.EPSILON"></a>5.5 Number.EPSILON</h2><p>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// "0.00000000000000022204"</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// '0.00000000000000005551'</span></span><br></pre></td></tr></table></figure>

<p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h2 id="5-6-安全整数和-Number-isSafeInteger"><a href="#5-6-安全整数和-Number-isSafeInteger" class="headerlink" title="5.6 安全整数和 Number.isSafeInteger()"></a>5.6 安全整数和 Number.isSafeInteger()</h2><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">-9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Math</span>.round(n) === n &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>9007199254740993</code>不是一个安全整数，但是<code>Number.isSafeInteger</code>会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以<code>9007199254740992</code>的形式储存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740993</span> === <span class="number">9007199254740992</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trusty</span> (<span class="params">left, right, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(<span class="number">9007199254740993</span>, <span class="number">990</span>, <span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// RangeError: Operation cannot be trusted!</span></span><br><span class="line"></span><br><span class="line">trusty(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="5-7-Math-对象的扩展"><a href="#5-7-Math-对象的扩展" class="headerlink" title="5.7 Math 对象的扩展"></a>5.7 Math 对象的扩展</h2><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<ol>
<li><p><code>Math.trunc</code><br>用于去除一个数的小数部分，返回整数部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br><span class="line"></span><br><span class="line">对于没有部署这个方法的环境，可以用下面的代码模拟。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.trunc = <span class="built_in">Math</span>.trunc || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.sign()</code><br>用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
</li>
<li><p><code>Math.cbrt()</code><br>用于计算一个数的立方根。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">-1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948732</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.clz32()``Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.imul()</code><br><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-2</span>, <span class="number">-2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.fround()</code>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> - <span class="number">1</span>)   <span class="comment">// 16777215</span></span><br></pre></td></tr></table></figure>

<p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span>)       <span class="comment">// 16777216</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> + <span class="number">1</span>)   <span class="comment">// 16777216</span></span><br></pre></td></tr></table></figure>

<p><code>Math.fround</code>方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未丢失有效精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.125</span>) <span class="comment">// 1.125</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">7.25</span>)  <span class="comment">// 7.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.3</span>)   <span class="comment">// 0.30000001192092896</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.7</span>)   <span class="comment">// 0.699999988079071</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.0000000123</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>NaN</code> 和 <code>Infinity</code>，此方法返回原值。对于其它类型的非数值，<code>Math.fround</code> 方法会先将其转为数值，再返回单精度浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="string">'5'</span>)      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">true</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">null</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround([])       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(&#123;&#125;)       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround = <span class="built_in">Math</span>.fround || <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Float32Array</span>([x])[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Math.hypot()``Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'foo'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'5'</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">-3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>
<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p>
</li>
<li><p>对数方法ES6 新增了 4 个对数相关方法。</p>
<p><strong>（1） Math.expm1()</strong></p>
<p><code>Math.expm1(x)</code>返回 ex - 1，即<code>Math.exp(x) - 1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">-1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure>

<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1 = <span class="built_in">Math</span>.expm1 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x) - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）Math.log1p()</strong></p>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-1</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p = <span class="built_in">Math</span>.log1p || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(<span class="number">1</span> + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）Math.log10()</strong></p>
<p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">-2</span>)     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10 = <span class="built_in">Math</span>.log10 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）Math.log2()</strong></p>
<p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">-2</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2 = <span class="built_in">Math</span>.log2 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双曲函数方法ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
</li>
<li><p>指数运算符ES2016 新增了一个指数运算符（<code>**</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b</span></span><br></pre></td></tr></table></figure>

<h2 id="5-8-BigInt数据类型"><a href="#5-8-BigInt数据类型" class="headerlink" title="5.8 BigInt数据类型"></a>5.8 BigInt数据类型</h2><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/tc39/proposal-bigint" target="_blank" rel="noopener">ES2020</a> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="built_in">Number</span>(a) * <span class="built_in">Number</span>(b) <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure>

<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure>

<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0b1101n</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="number">0o777n</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0xFFn</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123n</span> <span class="comment">// 'bigint'</span></span><br></pre></td></tr></table></figure>

<p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">-42n</span> <span class="comment">// 正确</span></span><br><span class="line">+<span class="number">42n</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 以前不能计算70的阶乘（即<code>70!</code>），因为超出了可以表示的精度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">70</span>; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 1.197857166996989e+100</span></span><br></pre></td></tr></table></figure>

<p>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1n</span>; i &lt;= <span class="number">70n</span>; i++) &#123;</span><br><span class="line">  p *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// 11978571...00000000n</span></span><br></pre></td></tr></table></figure>

<p><strong>BigInt对象</strong></p>
<p>JavaScript 原生提供<code>BigInt</code>对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BigInt(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="string">'123'</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="literal">false</span>) <span class="comment">// 0n</span></span><br><span class="line">BigInt(<span class="literal">true</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>

<p><code>BigInt()</code>构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BigInt() <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="literal">undefined</span>) <span class="comment">//TypeError</span></span><br><span class="line">BigInt(<span class="literal">null</span>) <span class="comment">// TypeError</span></span><br><span class="line">BigInt(<span class="string">'123n'</span>) <span class="comment">// SyntaxError</span></span><br><span class="line">BigInt(<span class="string">'abc'</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p>
<p>参数如果是小数，也会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BigInt(<span class="number">1.5</span>) <span class="comment">// RangeError</span></span><br><span class="line">BigInt(<span class="string">'1.5'</span>) <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>

<p>BigInt 对象继承了 Object 对象的两个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toString()</code></li>
<li><code>BigInt.prototype.valueOf()</code></li>
</ul>
<p>它还继承了 Number 对象的一个实例方法。</p>
<ul>
<li><code>BigInt.prototype.toLocaleString()</code></li>
</ul>
<p>此外，还提供了三个静态方法。</p>
<ul>
<li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li>
<li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li>
<li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2n</span> ** (<span class="number">64n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line">BigInt.asIntN(<span class="number">64</span>, max)</span><br><span class="line"><span class="comment">// 9223372036854775807n</span></span><br><span class="line">BigInt.asIntN(<span class="number">64</span>, max + <span class="number">1n</span>)</span><br><span class="line"><span class="comment">// -9223372036854775808n</span></span><br><span class="line">BigInt.asUintN(<span class="number">64</span>, max + <span class="number">1n</span>)</span><br><span class="line"><span class="comment">// 9223372036854775808n</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p>
<p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2n</span> ** (<span class="number">64n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line">BigInt.asIntN(<span class="number">32</span>, max) <span class="comment">// -1n</span></span><br><span class="line">BigInt.asUintN(<span class="number">32</span>, max) <span class="comment">// 4294967295n</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p>
<p>下面是<code>BigInt.parseInt()</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number.parseInt() 与 BigInt.parseInt() 的对比</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'9007199254740993'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line">BigInt.parseInt(<span class="string">'9007199254740993'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 9007199254740993n</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p>
<p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p>
<p><strong>转换规则</strong></p>
<p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1n</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">1n</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1n</span>)  <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p>
<p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="number">0n</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">1n</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>数学运算</strong></p>
<p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">9n</span> / <span class="number">5n</span></span><br><span class="line"><span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>

<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>
<ul>
<li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li>
<li>一元的求正运算符<code>+</code></li>
</ul>
<p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p>
<p>BigInt 不能与普通数值进行混合运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1n</span> + <span class="number">1.3</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>
<p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">4n</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="built_in">Number</span>(<span class="number">4n</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p>
<p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1n</span> | <span class="number">0</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h1 id="6-函数的扩展"><a href="#6-函数的扩展" class="headerlink" title="6. 函数的扩展"></a>6. 函数的扩展</h1><h2 id="6-1-函数参数默认值"><a href="#6-1-函数参数默认值" class="headerlink" title="6.1 函数参数默认值"></a>6.1 函数参数默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>与结构赋值结合使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>默认参数的位置</strong></p>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<p><strong>函数的length属性</strong></p>
<p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<p><strong>作用域</strong></p>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>
<p><strong>应用</strong></p>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-rest参数"><a href="#6-2-rest参数" class="headerlink" title="6.2 rest参数"></a>6.2 rest参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>

<p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<h2 id="6-3-严格模式"><a href="#6-3-严格模式" class="headerlink" title="6.3 严格模式"></a>6.3 严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value = <span class="number">42</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<h2 id="6-4-name属性"><a href="#6-4-name属性" class="headerlink" title="6.4 name属性"></a>6.4 name属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<figure class="highlight plain"><figcaption><span>对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。var f </span></figcaption><table><tr><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line">foo.name &#x2F;&#x2F; &quot;foo&quot;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// "f"</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span><br></pre></td></tr></table></figure>

<h2 id="6-4-箭头函数"><a href="#6-4-箭头函数" class="headerlink" title="6.4 箭头函数"></a>6.4 箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>

<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>箭头函数可以与变量解构结合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>

<p>参数与箭头函数结合的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure>

<p><strong>使用注意点</strong></p>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。<br>          箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域，而不是指向运行时所在的作用域。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p><strong>不适用场合</strong></p>
<p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<p>第二个场合是dom事件绑定的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'press'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.classList.toggle(<span class="string">'on'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<h2 id="6-5-尾调用优化"><a href="#6-5-尾调用优化" class="headerlink" title="6.5 尾调用优化"></a>6.5 尾调用优化</h2><p><strong>什么是尾调用</strong></p>
<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>
<p><strong>尾调用优化</strong></p>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p>
<p><strong>尾递归</strong></p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p><strong>递归函数的改写</strong></p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>如果使用ES6的函数默认值就比较简单了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p><strong>尾递归优化的实现</strong></p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>

<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h2 id="6-6-函数参数的尾逗号"><a href="#6-6-函数参数的尾逗号" class="headerlink" title="6.6 函数参数的尾逗号"></a>6.6 函数参数的尾逗号</h2><p>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas" target="_blank" rel="noopener">允许</a>函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<h2 id="6-7-Function-prototype-toString"><a href="#6-7-Function-prototype-toString" class="headerlink" title="6.7 Function.prototype.toString()"></a>6.7 Function.prototype.toString()</h2><p><a href="https://github.com/tc39/Function-prototype-toString-revision" target="_blank" rel="noopener">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。</p>
<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">foo</span> <span class="title">comment</span> */ <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString()</span><br><span class="line"><span class="comment">// function foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>
<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">foo</span> <span class="title">comment</span> */ <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString()</span><br><span class="line"><span class="comment">// "function /* foo comment */ foo () &#123;&#125;"</span></span><br></pre></td></tr></table></figure>

<h2 id="6-6-catch-命令的参数省略"><a href="#6-6-catch-命令的参数省略" class="headerlink" title="6.6 catch 命令的参数省略"></a>6.6 catch 命令的参数省略</h2><p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding" target="_blank" rel="noopener">ES2019</a> 做出了改变，允许<code>catch</code>语句省略参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-数组的扩展"><a href="#7-数组的扩展" class="headerlink" title="7. 数组的扩展"></a>7. 数组的扩展</h1><h2 id="7-1-扩展运算符"><a href="#7-1-扩展运算符" class="headerlink" title="7.1 扩展运算符"></a>7.1 扩展运算符</h2><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p><strong>替代函数的apply方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;<span class="built_in">console</span>.log(x,y,z);&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line">f(...[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求数组最大值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...[<span class="number">10</span>,<span class="number">5</span>,<span class="number">26</span>]));</span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符的应用</strong></p>
<p><strong>（1）复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>

<p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p>
<p><strong>（2）合并数组</strong></p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>

<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.concat(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p>
<p><strong>（3）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure>

<p>下面是另外一些例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">"foo"</span>];</span><br><span class="line">first  <span class="comment">// "foo"</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></figure>

<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p>
<p><strong>（5）实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="keyword">this</span>.valueOf();</span><br><span class="line">  <span class="keyword">while</span> (i &lt; num) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([..<span class="number">.5</span>]) <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>
<p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-Array-from"><a href="#7-2-Array-from" class="headerlink" title="7.2 Array.from()"></a>7.2 Array.from()</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).filter(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.textContent.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>
<p><code>Array.from()还可以将各种值转为真正的数组，并且还提供</code>map`功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line"><span class="comment">// ['jack', 'jack']</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\uFFFF</code>的 Unicode 字符，算作两个字符的 bug。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-Array-of"><a href="#7-3-Array-of" class="headerlink" title="7.3 Array.of"></a>7.3 Array.of</h2><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-数组实例的copyWithin"><a href="#7-4-数组实例的copyWithin" class="headerlink" title="7.4 数组实例的copyWithin()"></a>7.4 数组实例的copyWithin()</h2><p>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="keyword">this</span>.length)</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="7-5-find和findIndex"><a href="#7-5-find和findIndex" class="headerlink" title="7.5 find和findIndex"></a>7.5 find和findIndex</h2><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>上面代码找出数组中第一个小于 0 的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p>
<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到</p>
<h2 id="7-6-fill"><a href="#7-6-fill" class="headerlink" title="7.6 fill"></a>7.6 fill</h2><p><code>fill</code>方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;<span class="attr">name</span>: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line">arr[<span class="number">0</span>].push(<span class="number">5</span>);</span><br><span class="line">arr</span><br><span class="line"><span class="comment">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure>

<h2 id="7-7-数组实例的entries-keys-和values"><a href="#7-7-数组实例的entries-keys-和values" class="headerlink" title="7.7 数组实例的entries(), keys()和values()"></a>7.7 数组实例的entries(), keys()和values()</h2><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure>

<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>

<h2 id="7-8-数组实例的includes"><a href="#7-8-数组实例的includes" class="headerlink" title="7.8 数组实例的includes"></a>7.8 数组实例的includes</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。ES2016 引入了该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">    ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">    : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
<h2 id="7-9-数组实例的flat-flatMap"><a href="#7-9-数组实例的flat-flatMap" class="headerlink" title="7.9 数组实例的flat(), flatMap()"></a>7.9 数组实例的flat(), flatMap()</h2><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p>
<p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>flat()</code>的参数为2，表示要“拉平”两层的嵌套数组。</p>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>只能展开一层数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</p>
<p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>
<h2 id="7-10-数组的空位"><a href="#7-10-数组的空位" class="headerlink" title="7.10 数组的空位"></a>7.10 数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br></pre></td></tr></table></figure>

<p>ES6 则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line"><span class="comment">// [ "a", undefined, "b" ]</span></span><br></pre></td></tr></table></figure>

<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br></pre></td></tr></table></figure>

<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br></pre></td></tr></table></figure>

<p><code>for...of</code>循环也会遍历空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h1 id="8-对象的扩展"><a href="#8-对象的扩展" class="headerlink" title="8. 对象的扩展"></a>8. 对象的扩展</h1><h2 id="8-1-属性的简洁表示法"><a href="#8-1-属性的简洁表示法" class="headerlink" title="8.1 属性的简洁表示法"></a>8.1 属性的简洁表示法</h2><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>

<p>除了属性简写，方法也可以简写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意，简写的对象方法不能用作构造函数，会报错。</strong></p>
<h2 id="8-2-属性名表达式"><a href="#8-2-属性名表达式" class="headerlink" title="8.2 属性名表达式"></a>8.2 属性名表达式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-方法的name属性"><a href="#8-3-方法的name属性" class="headerlink" title="8.3 方法的name属性"></a>8.3 方法的name属性</h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   <span class="comment">// "sayName"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// "get foo"</span></span><br><span class="line">descriptor.set.name <span class="comment">// "set foo"</span></span><br></pre></td></tr></table></figure>

<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></span><br></pre></td></tr></table></figure>

<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>);</span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// "[description]"</span></span><br><span class="line">obj[key2].name <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h2 id="8-4-属性的可枚举性和遍历"><a href="#8-4-属性的可枚举性和遍历" class="headerlink" title="8.4 属性的可枚举性和遍历"></a>8.4 属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>

<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;foo() &#123;&#125;&#125;.prototype, <span class="string">'foo'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h2 id="8-5-super关键字"><a href="#8-5-super关键字" class="headerlink" title="8.5 super关键字"></a>8.5 super关键字</h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h2 id="8-6-对象的扩展运算符"><a href="#8-6-对象的扩展运算符" class="headerlink" title="8.6 对象的扩展运算符"></a>8.6 对象的扩展运算符</h2><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。ES2018 将这个运算符<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">引入</a>了对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line">上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。</span><br><span class="line"></span><br><span class="line">由于解构赋值要求等号右边是一个对象，所以如果等号右边是<span class="literal">undefined</span>或<span class="literal">null</span>，就会报错，因为它们无法转为对象。</span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符</strong></p>
<p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; ...[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>] &#125;;</span><br><span class="line">foo</span><br><span class="line"><span class="comment">// &#123;0: "a", 1: "b", 2: "c"&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class="line">&#123;..<span class="number">.1</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number{1}</code>。由于该对象没有自身属性，所以返回一个空对象。</p>
<p>下面的例子都是类似的道理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 &#123;...Object(true)&#125;</span></span><br><span class="line">&#123;...true&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 &#123;...Object(undefined)&#125;</span></span><br><span class="line">&#123;...undefined&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 &#123;...Object(null)&#125;</span></span><br><span class="line">&#123;...null&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;...<span class="string">'hello'</span>&#125;</span><br><span class="line"><span class="comment">// &#123;0: "h", 1: "e", 2: "l", 3: "l", 4: "o"&#125;</span></span><br></pre></td></tr></table></figure>

<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure>

<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> clone1 = &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>

<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<h2 id="8-7-链判断运算符"><a href="#8-7-链判断运算符" class="headerlink" title="8.7 链判断运算符"></a>8.7 链判断运算符</h2><p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span>  firstName = message.body.user.firstName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.body</span><br><span class="line">  &amp;&amp; message.body.user</span><br><span class="line">  &amp;&amp; message.body.user.firstName) || <span class="string">'default'</span>;</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>
<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooInput = myForm.querySelector(<span class="string">'input[name=foo]'</span>)</span><br><span class="line"><span class="keyword">const</span> fooValue = fooInput ? fooInput.value : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>
<p>这样的层层判断非常麻烦，因此 <a href="https://github.com/tc39/proposal-optional-chaining" target="_blank" rel="noopener">ES2020</a> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">'default'</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.querySelector(<span class="string">'input[name=foo]'</span>)?.value</span><br></pre></td></tr></table></figure>

<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iterator.return?.()</span><br></pre></td></tr></table></figure>

<p>链判断运算符有三种用法。</p>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<p>使用这个运算符，有几个注意点。</p>
<p>（1）短路机制</p>
<p><code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a?.[++x]</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[++x]</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>
<p>（2）delete 运算符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> a?.b</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : <span class="keyword">delete</span> a.b</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，会直接返回<code>undefined</code>，而不会进行<code>delete</code>运算。</p>
<p>（3）括号的影响</p>
<p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(a?.b).c</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b).c</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>
<p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p>
<p>（4）报错场合</p>
<p>以下写法是禁止的，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">new</span> a?.()</span><br><span class="line"><span class="keyword">new</span> a?.b()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链判断运算符的右侧有模板字符串</span></span><br><span class="line">a?.<span class="string">`&#123;b&#125;`</span></span><br><span class="line">a?.b<span class="string">`&#123;c&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链判断运算符的左侧是 super</span></span><br><span class="line"><span class="keyword">super</span>?.()</span><br><span class="line"><span class="keyword">super</span>?.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链运算符用于赋值运算符左侧</span></span><br><span class="line">a?.b = c</span><br></pre></td></tr></table></figure>

<p>（5）右侧不得为十进制数值</p>
<p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
<h2 id="8-8-Null判断运算符"><a href="#8-8-Null判断运算符" class="headerlink" title="8.8 Null判断运算符"></a>8.8 Null判断运算符</h2><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText || <span class="string">'Hello, world!'</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p>
<p>为了避免这种情况，<a href="https://github.com/tc39/proposal-nullish-coalescing" target="_blank" rel="noopener">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText ?? <span class="string">'Hello, world!'</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration ?? <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>
<p>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.settings?.animationDuration ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>response.settings</code>如果是<code>null</code>或<code>undefined</code>，就会返回默认值300。</p>
<p>这个运算符很适合判断函数参数是否赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> enable = props.enabled ?? <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，等同于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    enabled: enable = <span class="literal">true</span>,</span><br><span class="line">  &#125; = props;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>??</code>有一个运算优先级问题，它与<code>&amp;&amp;</code>和<code>||</code>的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">lhs &amp;&amp; middle ?? rhs</span><br><span class="line">lhs ?? middle &amp;&amp; rhs</span><br><span class="line">lhs || middle ?? rhs</span><br><span class="line">lhs ?? middle || rhs</span><br></pre></td></tr></table></figure>

<p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(lhs &amp;&amp; middle) ?? rhs;</span><br><span class="line">lhs &amp;&amp; (middle ?? rhs);</span><br><span class="line"></span><br><span class="line">(lhs ?? middle) &amp;&amp; rhs;</span><br><span class="line">lhs ?? (middle &amp;&amp; rhs);</span><br><span class="line"></span><br><span class="line">(lhs || middle) ?? rhs;</span><br><span class="line">lhs || (middle ?? rhs);</span><br><span class="line"></span><br><span class="line">(lhs ?? middle) || rhs;</span><br><span class="line">lhs ?? (middle || rhs);</span><br></pre></td></tr></table></figure>

<h2 id="8-9-对象新增的方法"><a href="#8-9-对象新增的方法" class="headerlink" title="8.9 对象新增的方法"></a>8.9 对象新增的方法</h2><p><code>Object.is()</code></p>
<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code></p>
<p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。注意点</p>
<p><strong>（1）浅拷贝</strong></p>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<p><strong>（3）数组的处理</strong></p>
<p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>（4）取值函数的处理</strong></p>
<p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<p><strong>常见用途</strong></p>
<p><code>Object.assign</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<p><strong>（3）克隆对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (...sources) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure>

<p><strong>（5）为属性指定默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  <span class="built_in">console</span>.log(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  url: &#123;</span><br><span class="line">    host: <span class="string">'example.com'</span>,</span><br><span class="line">    port: <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">processContent(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<p><code>Object.getOwnPropertyDescriptors()</code></p>
<p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> foo(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowMerge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(</span><br><span class="line">    (c, mixin) =&gt; <span class="built_in">Object</span>.create(</span><br><span class="line">      c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span><br><span class="line"></span><br><span class="line">d.c <span class="comment">// "c"</span></span><br><span class="line">d.b <span class="comment">// "b"</span></span><br><span class="line">d.a <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>

<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>
<p><code>__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</code></p>
<ul>
<li>Object.setPrototypeOf()设置一个对象的原型对象</li>
<li>Object.getPrototypeOf()读取一个对象的原型对象</li>
</ul>
<p><code>Object.keys()，Object.values()，Object.entries()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ES5 引入了<span class="built_in">Object</span>.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// ["foo", "baz"]</span></span><br><span class="line">ES2017 引入了跟<span class="built_in">Object</span>.keys配套的<span class="built_in">Object</span>.values和<span class="built_in">Object</span>.entries，作为遍历一个对象的补充手段，供<span class="keyword">for</span>...of循环使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// ['a', 1], ['b', 2], ['c', 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object.fromEntries()</code></p>
<p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'foo'</span>, <span class="literal">true</span>).set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(<span class="string">'foo=bar&amp;baz=qux'</span>))</span><br><span class="line"><span class="comment">// &#123; foo: "bar", baz: "qux" &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-Symbol"><a href="#9-Symbol" class="headerlink" title="9. Symbol"></a>9. Symbol</h1><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>Symbol<code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的</code>Symbol`函数的返回值是不相等的。</li>
<li>Symbol 值不能与其他类型的值进行运算，会报错。</li>
<li>Symbol 值也可以转为布尔值，但是不能转为数值。</li>
</ul>
<p><strong>Symbol.prototype.description</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">创建 <span class="built_in">Symbol</span> 的时候，可以添加一个描述。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure>

<p>但是，读取这个描述需要将 Symbol 显式转为字符串(String()/ toString())，即下面的写法。</p>
<p>上面的用法不是很方便。<a href="https://github.com/tc39/proposal-Symbol-description" target="_blank" rel="noopener">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">sym.description <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p><strong>作为属性名的Symbol</strong></p>
<p>使用Symbol定义属性名可以防止保证属性名独一无二</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="9-1-消除魔术字符串"><a href="#9-1-消除魔术字符串" class="headerlink" title="9.1 消除魔术字符串"></a>9.1 消除魔术字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.triangle:</span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用Symbol来定义shapeType</span></span><br><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-属性名的遍历"><a href="#9-2-属性名的遍历" class="headerlink" title="9.2 属性名的遍历"></a>9.2 属性名的遍历</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span> 作为属性名，遍历对象的时候，该属性不会出现在<span class="keyword">for</span>...in、<span class="keyword">for</span>...of循环中，也不会被<span class="built_in">Object</span>.keys()、<span class="built_in">Object</span>.getOwnPropertyNames()、<span class="built_in">JSON</span>.stringify()返回。</span><br><span class="line"></span><br><span class="line">但是，它也不是私有属性，有一个<span class="built_in">Object</span>.getOwnPropertySymbols()方法，可以获取指定对象的所有 <span class="built_in">Symbol</span> 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 <span class="built_in">Symbol</span> 值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>

<p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">    <span class="keyword">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-Symbol-for-Symbol-keyFor"><a href="#9-3-Symbol-for-Symbol-keyFor" class="headerlink" title="9.3 Symbol.for(), Symbol.keyFor()"></a>9.3 Symbol.for(), Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<h2 id="9-4-内置的Symbol"><a href="#9-4-内置的Symbol" class="headerlink" title="9.4 内置的Symbol"></a>9.4 内置的Symbol</h2><p>ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> Even = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> Even <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> Even <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', ['c','d'], 'e']</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', obj, 'e']</span></span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) <span class="comment">// ['a', 'b', 'c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.isConcatSpreadable] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>
<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，再来看前面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>
<p>再看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> T1(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T1 <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> T2(<span class="function"><span class="params">r</span> =&gt;</span> r()).then(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> T2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>
<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.replace(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">searchValue[<span class="built_in">Symbol</span>.replace](<span class="keyword">this</span>, replaceValue)</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) <span class="comment">// ["Hello", "World"]</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.search(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.search](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.split(separator, limit)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">separator[<span class="built_in">Symbol</span>.split](<span class="keyword">this</span>, limit)</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySplitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](string) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = string.indexOf(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      string.substr(<span class="number">0</span>, index),</span><br><span class="line">      string.substr(index + <span class="keyword">this</span>.value.length)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// ['', 'bar']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'bar'</span>))</span><br><span class="line"><span class="comment">// ['foo', '']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'baz'</span>))</span><br><span class="line"><span class="comment">// 'foobar'</span></span><br></pre></td></tr></table></figure>

<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// '3default'</span></span><br><span class="line">obj == <span class="string">'default'</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())</span><br><span class="line"><span class="comment">// "[object Foo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x) <span class="comment">// "[object xxx]"</span></span><br></pre></td></tr></table></figure>

<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>
<ul>
<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>
<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>
<li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   copyWithin: true,</span></span><br><span class="line"><span class="comment">//   entries: true,</span></span><br><span class="line"><span class="comment">//   fill: true,</span></span><br><span class="line"><span class="comment">//   find: true,</span></span><br><span class="line"><span class="comment">//   findIndex: true,</span></span><br><span class="line"><span class="comment">//   includes: true,</span></span><br><span class="line"><span class="comment">//   keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span><br><span class="line"><span class="comment">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys']</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>
<h1 id="10-Set和Map数据结构"><a href="#10-Set和Map数据结构" class="headerlink" title="10. Set和Map数据结构"></a>10. Set和Map数据结构</h1><h2 id="10-1-Set"><a href="#10-1-Set" class="headerlink" title="10.1 Set"></a>10.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">const <span class="keyword">set</span> = new Set(document.querySelectorAll('div'));</span><br><span class="line"><span class="keyword">set</span>.size // 56</span><br><span class="line"></span><br><span class="line">// 类似于</span><br><span class="line">const <span class="keyword">set</span> = new Set();</span><br><span class="line">document</span><br><span class="line"> .querySelectorAll('div')</span><br><span class="line"> .forEach(div =&gt; <span class="keyword">set</span>.add(div));</span><br><span class="line"><span class="keyword">set</span>.size // 56</span><br></pre></td></tr></table></figure>

<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">'ababbc'</span>)].join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>

<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line"><span class="keyword">set</span>.add(a);</span><br><span class="line"><span class="keyword">set</span>.add(b);</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p>
<p>另外，两个对象总是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 2</span><br></pre></td></tr></table></figure>

<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>
<p><strong>实例属性和方法</strong></p>
<p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure>

<p>这就提供了去除数组重复成员的另一种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>遍历操作</strong></p>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>
<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）<code>forEach()</code></strong></p>
<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 4, 9]);</span><br><span class="line"><span class="keyword">set</span>.forEach((value, key) =&gt; console.log(key + ' : ' + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure>

<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>
<p><strong>（3）遍历的应用</strong></p>
<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line">let arr = [...<span class="keyword">set</span>];</span><br><span class="line">// ['red', 'green', 'blue']</span><br></pre></td></tr></table></figure>

<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(x =&gt; x * 2));</span><br><span class="line">// 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].filter(x =&gt; (x % 2) == 0));</span><br><span class="line">// 返回Set结构：&#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(val =&gt; val * 2));</span><br><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">let <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set(Array.from(<span class="keyword">set</span>, val =&gt; val * 2));</span><br><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span><br></pre></td></tr></table></figure>

<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>
<h2 id="10-2-WeakSet"><a href="#10-2-WeakSet" class="headerlink" title="10.2 WeakSet"></a>10.2 WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>

<p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure>

<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p>
<p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.has(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>);</span><br><span class="line">ws.has(<span class="built_in">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'WeakSet has '</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<p>下面是 WeakSet 的另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>
<h2 id="10-3-Map"><a href="#10-3-Map" class="headerlink" title="10.3 Map"></a>10.3 Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">'metadata'</span>;</span><br><span class="line">data[<span class="string">'[object HTMLDivElement]'</span>] <span class="comment">// "metadata"</span></span><br></pre></td></tr></table></figure>

<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'name'</span>) <span class="comment">// "张三"</span></span><br><span class="line">map.has(<span class="string">'title'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'title'</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure>

<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>
<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span><br><span class="line">  ['foo', 1],</span><br><span class="line">  ['bar', 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(<span class="keyword">set</span>);</span><br><span class="line">m1.<span class="keyword">get</span>('foo') // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([['baz', 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.<span class="keyword">get</span>('baz') // 3</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'aaa'</span>)</span><br><span class="line">.set(<span class="number">1</span>, <span class="string">'bbb'</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">1</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>

<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>().get(<span class="string">'asfddfsasadf'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="number">-0</span>, <span class="number">123</span>);</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">'true'</span>, <span class="number">2</span>);</span><br><span class="line">map.get(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.get(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size 属性</strong></p>
<p><code>size</code>属性返回 Map 结构的成员总数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）Map.prototype.set(key, value)</strong></p>
<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">'edition'</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">'standard'</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure>

<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（3）Map.prototype.get(key)</strong></p>
<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>);&#125;;</span><br><span class="line">m.set(hello, <span class="string">'Hello ES6!'</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.get(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）Map.prototype.has(key)</strong></p>
<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">'edition'</span>, <span class="number">6</span>);</span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">'standard'</span>);</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">'edition'</span>)     <span class="comment">// true</span></span><br><span class="line">m.has(<span class="string">'years'</span>)       <span class="comment">// false</span></span><br><span class="line">m.has(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）Map.prototype.delete(key)</strong></p>
<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">'nah'</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="literal">undefined</span>)</span><br><span class="line">m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>（6）Map.prototype.clear()</strong></p>
<p><code>clear</code>方法清除所有成员，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'foo'</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.clear()</span><br><span class="line">map.size <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'F'</span>, <span class="string">'no'</span>],</span><br><span class="line">  [<span class="string">'T'</span>,  <span class="string">'yes'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F"</span></span><br><span class="line"><span class="comment">// "T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "no"</span></span><br><span class="line"><span class="comment">// "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "F" "no"</span></span><br><span class="line"><span class="comment">// "T" "yes"</span></span><br></pre></td></tr></table></figure>

<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map[<span class="built_in">Symbol</span>.iterator] === map.entries</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// ['one', 'two', 'three']</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br></pre></td></tr></table></figure>

<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].filter(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</span><br><span class="line">  [...map0].map(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></span><br></pre></td></tr></table></figure>

<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）数组 转为 Map</strong></p>
<p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）Map 转为对象</strong></p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">'yes'</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><strong>（4）对象转为 Map</strong></p>
<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>

<p>此外，也可以自己实现一个转换函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;"yes" =&gt; true, "no" =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）Map 转为 JSON</strong></p>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'yes'</span>, <span class="literal">true</span>).set(<span class="string">'no'</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap)</span><br><span class="line"><span class="comment">// '&#123;"yes":true,"no":false&#125;'</span></span><br></pre></td></tr></table></figure>

<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">'abc'</span>]);</span><br><span class="line">mapToArrayJson(myMap)</span><br><span class="line"><span class="comment">// '[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span></span><br></pre></td></tr></table></figure>

<p><strong>（6）JSON 转为 Map</strong></p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">'&#123;"yes": true, "no": false&#125;'</span>)</span><br><span class="line"><span class="comment">// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">'[[true,7],[&#123;"foo":3&#125;,["abc"]]]'</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">'foo'</span>], [k2, <span class="string">'bar'</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">'foo 元素'</span>],</span><br><span class="line">  [e2, <span class="string">'bar 元素'</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>
<h2 id="10-4-WeakMap-的语法"><a href="#10-4-WeakMap-的语法" class="headerlink" title="10.4 WeakMap 的语法"></a>10.4 WeakMap 的语法</h2><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.set(key, <span class="number">2</span>);</span><br><span class="line">wm1.get(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[k1, <span class="string">'foo'</span>], [k2, <span class="string">'bar'</span>]]);</span><br><span class="line">wm2.get(k2) <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">'foo 元素'</span>],</span><br><span class="line">  [e2, <span class="string">'bar 元素'</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>
<h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.size <span class="comment">// undefined</span></span><br><span class="line">wm.forEach <span class="comment">// undefined</span></span><br><span class="line">wm.clear <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="WeakMap-的示例"><a href="#WeakMap-的示例" class="headerlink" title="WeakMap 的示例"></a>WeakMap 的示例</h3><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>
<p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104" target="_blank" rel="noopener">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925" target="_blank" rel="noopener">vtxf</a>补充了下面的例子。</p>
<p>首先，打开 Node 命令行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --expose-gc</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>
<p>然后，执行下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></span><br><span class="line">&gt; global.gc();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">21106688</span>,</span><br><span class="line">  heapTotal: <span class="number">7376896</span>,</span><br><span class="line">  heapUsed: <span class="number">4153936</span>,</span><br><span class="line">  external: <span class="number">9059</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个变量 key，指向一个 5*1024*1024 的数组</span></span><br><span class="line">&gt; <span class="keyword">let</span> key = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 WeakMap 实例的键名，也指向 key 数组</span></span><br><span class="line"><span class="comment">// 这时，key 数组实际被引用了两次，</span></span><br><span class="line"><span class="comment">// 变量 key 引用一次，WeakMap 的键名引用了第二次</span></span><br><span class="line"><span class="comment">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1</span></span><br><span class="line">&gt; wm.set(key, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">WeakMap</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt; global.gc();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时内存占用 heapUsed 增加到 45M 了</span></span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">67538944</span>,</span><br><span class="line">  heapTotal: <span class="number">7376896</span>,</span><br><span class="line">  heapUsed: <span class="number">45782816</span>,</span><br><span class="line">  external: <span class="number">8945</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除变量 key 对数组的引用，</span></span><br><span class="line"><span class="comment">// 但没有手动清除 WeakMap 实例的键名对数组的引用</span></span><br><span class="line">&gt; key = <span class="literal">null</span>;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次执行垃圾回收</span></span><br><span class="line">&gt; global.gc();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存占用 heapUsed 变回 4M 左右，</span></span><br><span class="line"><span class="comment">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收</span></span><br><span class="line">&gt; process.memoryUsage();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">20639744</span>,</span><br><span class="line">  heapTotal: <span class="number">8425472</span>,</span><br><span class="line">  heapUsed: <span class="number">3979792</span>,</span><br><span class="line">  external: <span class="number">8956</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>
<h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>
<p>WeakMap 的另一个用处是部署私有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(counter, action) &#123;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.set(<span class="keyword">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.get(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span><br><span class="line"></span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h1 id="11-Proxy"><a href="#11-Proxy" class="headerlink" title="11. Proxy"></a>11. Proxy</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (target, propKey, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (target, propKey, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">'b'</span>;</span><br><span class="line">target.a <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>
<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure>

<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">"Hello, foo"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"Prop name \""</span> + propKey + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name <span class="comment">// "张三"</span></span><br><span class="line">proxy.age <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>
<p><code>get</code>方法可以继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propertyKey, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'GET '</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">obj.foo <span class="comment">// "GET foo"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>
<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        propKey = <span class="built_in">String</span>(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = [];</span><br><span class="line">  target.push(...elements);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">arr[<span class="number">-1</span>] <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>
<p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcStack = [];</span><br><span class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">    <span class="keyword">get</span> : function (pipeObject, fnName) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> fn(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">      <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"><span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>
<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(property);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="built_in">Object</span>.keys(attrs)) &#123;</span><br><span class="line">        el.setAttribute(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'string'</span>) &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> el = dom.div(&#123;&#125;,</span><br><span class="line">  <span class="string">'Hello, my name is '</span>,</span><br><span class="line">  dom.a(&#123;<span class="attr">href</span>: <span class="string">'//example.com'</span>&#125;, <span class="string">'Mark'</span>),</span><br><span class="line">  <span class="string">'. I like:'</span>,</span><br><span class="line">  dom.ul(&#123;&#125;,</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'The web'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'Food'</span>),</span><br><span class="line">    dom.li(&#123;&#125;, <span class="string">'…actually that\'s it'</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br></pre></td></tr></table></figure>

<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.getReceiver === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">d.a === d <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>
<p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line"><span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.age <span class="comment">// 100</span></span><br><span class="line">person.age = <span class="string">'young'</span> <span class="comment">// 报错</span></span><br><span class="line">person.age = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy._prop</span><br><span class="line"><span class="comment">// Error: Invalid attempt to get private "_prop" property</span></span><br><span class="line">proxy._prop = <span class="string">'c'</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to set private "_prop" property</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<p>下面是<code>set</code>方法第四个参数的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>;</span><br><span class="line">proxy.foo === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(myObj, proxy);</span><br><span class="line"></span><br><span class="line">myObj.foo = <span class="string">'bar'</span>;</span><br><span class="line">myObj.foo === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>
<p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="string">'bar'</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = <span class="string">'baz'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">proxy.foo = <span class="string">'baz'</span>;</span><br><span class="line">proxy.foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>
<p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value, receiver) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    <span class="comment">// 无论有没有下面这一行，都会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// TypeError: 'set' on proxy: trap returned falsish for property 'foo'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">p()</span><br><span class="line"><span class="comment">// "I am the proxy"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments) * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, twice);</span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>
<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure>

<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p>下面的例子使用<code>has</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>
<p>如果原对象不可配置或者禁止扩展，这时<code>has</code>拦截会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  has: <span class="function"><span class="keyword">function</span>(<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>
<p>值得注意的是，<code>has</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p>
<p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has</code>拦截对<code>for...in</code>循环不生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  has(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'score'</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy1</span><br><span class="line"><span class="comment">// 张三 不及格</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'score'</span> <span class="keyword">in</span> oproxy2</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>has</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>
<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> target(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>construct</code>方法可以接受三个参数。</p>
<ul>
<li><code>target</code>：目标对象</li>
<li><code>args</code>：构造函数的参数对象</li>
<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called: '</span> + args.join(<span class="string">', '</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> p(<span class="number">1</span>)).value</span><br><span class="line"><span class="comment">// "called: 1"</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><code>construct</code>方法返回的必须是一个对象，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> p() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1')</span></span><br></pre></td></tr></table></figure>

<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'delete'</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span> (<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private "<span class="subst">$&#123;key&#125;</span>" property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy._prop</span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private "_prop" property</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>
<p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo = <span class="string">'bar'</span> <span class="comment">// 不会生效</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>
<p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p>
<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="string">'tar'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'wat'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'_foo'</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">'baz'</span>)</span><br><span class="line"><span class="comment">// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p>
<ul>
<li><code>Object.prototype.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>Reflect.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>
<p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"called"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p)</span><br><span class="line"><span class="comment">// "called"</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>
<p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>
<p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isExtensible(proxy) === <span class="built_in">Object</span>.isExtensible(target)</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  isExtensible: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')</span></span><br></pre></td></tr></table></figure>

<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<ul>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.getOwnPropertySymbols()</code></li>
<li><code>Object.keys()</code></li>
<li><code>for...in</code>循环</li>
</ul>
<p>下面是拦截<code>Object.keys()</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'a'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"><span class="comment">// [ 'a' ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  _bar: <span class="string">'foo'</span>,</span><br><span class="line">  _prop: <span class="string">'bar'</span>,</span><br><span class="line">  prop: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target).filter(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">'_'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(proxy)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>

<p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为 Symbol 值</li>
<li>不可遍历（<code>enumerable</code>）的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>)]: <span class="string">'4'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">'key'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">'static'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  ownKeys(target) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="built_in">Symbol</span>.for(<span class="string">'secret'</span>), <span class="string">'key'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"><span class="comment">// ['a']</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>
<p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p)</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c' ]</span></span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>
<p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a valid property name</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>
<p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="number">10</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'b'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>
<p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  ownKeys: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>
<p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  preventExtensions: <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'called'</span>);</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"><span class="comment">// "called"</span></span><br><span class="line"><span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Changing the prototype is forbidden'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.m() <span class="comment">// false</span></span><br><span class="line">proxy.m()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>proxy</code>代理<code>target.m</code>，后者内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>
<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>
<p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = createWebService(<span class="string">'http://example.com/data'</span>);</span><br><span class="line"></span><br><span class="line">service.employees().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWebService</span>(<span class="params">baseUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> httpGet(baseUrl + <span class="string">'/'</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>
<h2 id="12-Reflect"><a href="#12-Reflect" class="headerlink" title="12. Reflect"></a>12. Reflect</h2><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">'assign'</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">'assign'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(target, name, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target, name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'property '</span> + name + <span class="string">' on '</span> + target + <span class="string">' set to '</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteProperty(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'delete'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  has(target, name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'has'</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>
<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply.call(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.floor, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有 13 个静态方法。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>
<h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> baz() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'foo'</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'bar'</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> baz() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.foo + <span class="keyword">this</span>.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  foo: <span class="number">4</span>,</span><br><span class="line">  bar: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">'baz'</span>, myReceiverObject) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(<span class="literal">false</span>, <span class="string">'foo'</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> bar(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.foo <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'foo'</span>, <span class="number">2</span>);</span><br><span class="line">myObject.foo <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">3</span>)</span><br><span class="line">myObject.foo <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">4</span>,</span><br><span class="line">  <span class="keyword">set</span> bar(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.foo = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  foo: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">'bar'</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.foo <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target, key, attribute) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target, key, attribute) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.set(<span class="number">1</span>, <span class="string">'foo'</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(<span class="literal">false</span>, <span class="string">'foo'</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">in</span> myObject <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(myObject, <span class="string">'foo'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">delete</span> myObj.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(myObj, <span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure>

<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>
<p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p>
<h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.construct 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="built_in">Reflect</span>.construct(Greeting, [<span class="string">'张三'</span>]);</span><br></pre></td></tr></table></figure>

<p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p>
<h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> FancyThing();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(myObj) === FancyThing.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(myObj) === FancyThing.prototype;</span><br></pre></td></tr></table></figure>

<p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(myObj, <span class="built_in">Array</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(myObj, <span class="built_in">Array</span>.prototype);</span><br><span class="line"></span><br><span class="line">myObj.length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="built_in">Object</span>.freeze(&#123;&#125;), <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>
<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(youngest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.min, <span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="built_in">Reflect</span>.apply(<span class="built_in">Math</span>.max, <span class="built_in">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="built_in">Reflect</span>.apply(<span class="built_in">Object</span>.prototype.toString, youngest, []);</span><br></pre></td></tr></table></figure>

<h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*…*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(MyDate, <span class="string">'now'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>
<p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  defineProperty(target, prop, descriptor) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(target, prop, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="comment">// &#123;value: "bar", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line">p.foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p>
<h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">'hidden'</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(myObject, <span class="string">'hidden'</span>);</span><br></pre></td></tr></table></figure>

<p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>
<h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(myObject) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.isExtensible(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(myObject) <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 环境</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.preventExtensions(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'baz'</span>)]: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'bing'</span>)]: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(myObject)</span><br><span class="line"><span class="comment">// ['foo', 'bar']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(myObject)</span><br><span class="line"><span class="comment">//[Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myObject)</span><br><span class="line"><span class="comment">// ['foo', 'bar', Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p>
<h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;<span class="keyword">set</span>&#125;);</span><br><span class="line"></span><br><span class="line">function <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>
<h1 id="12-Promise对象"><a href="#12-Promise对象" class="headerlink" title="12 Promise对象"></a>12 Promise对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>

<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>

<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommendations(books, user));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled" target="_blank" rel="noopener">ES2020</a> 引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/api-1'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-2'</span>),</span><br><span class="line">  fetch(<span class="string">'/api-3'</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure>

<p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p>
<p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="built_in">Promise</span>.allSettled([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: 'fulfilled', value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: 'rejected', reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p>
<p>下面是返回值用法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ fetch(<span class="string">'index.html'</span>), fetch(<span class="string">'https://does-not-exist/'</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.allSettled(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'fulfilled'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .filter(<span class="function"><span class="params">p</span> =&gt;</span> p.status === <span class="string">'rejected'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">p</span> =&gt;</span> p.reason);</span><br></pre></td></tr></table></figure>

<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* ... */</span> ];</span><br><span class="line"><span class="keyword">const</span> requests = urls.map(<span class="function"><span class="params">x</span> =&gt;</span> fetch(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requests);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'所有请求都成功。'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'至少一个请求失败，其他请求可能还没结束。'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p>
<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p><code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  fetch(<span class="string">'/endpoint-a'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'a'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-b'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'b'</span>),</span><br><span class="line">  fetch(<span class="string">'/endpoint-c'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'c'</span>),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="built_in">Promise</span>.any(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AggregateError() extends <span class="built_in">Array</span> -&gt; AggregateError</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> AggregateError();</span><br><span class="line">err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"first error"</span>));</span><br><span class="line">err.push(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"second error"</span>));</span><br><span class="line"><span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure>

<p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any(promises).then(</span><br><span class="line">  (first) =&gt; &#123;</span><br><span class="line">    <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="built_in">Promise</span>.reject(<span class="literal">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([resolved, rejected, alsoRejected]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.any([rejected, alsoRejected]).catch(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results); <span class="comment">// [-1, Infinity]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p>
<p><strong>（3）参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p>注意，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure>

<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure>

<p>第二种写法是使用<code>new Promise()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try" target="_blank" rel="noopener">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html" target="_blank" rel="noopener"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs" target="_blank" rel="noopener"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry" target="_blank" rel="noopener"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/" target="_blank" rel="noopener">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure>

<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try(<span class="function"><span class="params">()</span> =&gt;</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
<h1 id="13-Iterator-和-for…of-循环"><a href="#13-Iterator-和-for…of-循环" class="headerlink" title="13. Iterator 和 for…of 循环"></a>13. Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
<p>Iterator 的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟<code>next</code>方法返回值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>
<p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p>
<p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p>
<p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p>
<p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = idMaker();</span><br><span class="line"></span><br><span class="line">it.next().value <span class="comment">// 0</span></span><br><span class="line">it.next().value <span class="comment">// 1</span></span><br><span class="line">it.next().value <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>
<p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() : Iterator,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Iterator &#123;</span><br><span class="line">  next(value?: any) : IterationResult,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IterationResult &#123;</span><br><span class="line">  value: any,</span><br><span class="line">  done: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p>
<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'a', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'b', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 'c', done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>
<p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<p>下面是通过遍历器实现指针结构的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iterator = &#123; <span class="attr">next</span>: next &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<p>下面是另一个为对象添加 Iterator 接口的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator];</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure>

<p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p>
<p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span>,</span><br><span class="line">  c: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p>
<p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = ITERABLE[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.next();</span><br><span class="line"><span class="keyword">while</span> (!$result.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $result = $iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>
<p><strong>（1）解构赋值</strong></p>
<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x,y] = <span class="keyword">set</span>;</span><br><span class="line">// x='a'; y='b'</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = <span class="keyword">set</span>;</span><br><span class="line">// first='a'; rest=['b','c'];</span><br></pre></td></tr></table></figure>

<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str] <span class="comment">//  ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>

<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure>

<p><strong>（3）yield*</strong></p>
<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h2 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h2><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>
<p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["h", "i"]</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">        <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">"bye"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _first: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["bye"]</span></span><br><span class="line">str <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p>
<h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><p><code>Symbol.iterator</code>方法的最简单实现，还是使用下一章要介绍的 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>
<h2 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h2><p>遍历器对象除了具有<code>next</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。如果你自己写遍历器对象生成函数，那么<code>next</code>方法是必须部署的，<code>return</code>方法和<code>throw</code>方法是否部署是可选的。</p>
<p><code>return</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.close();</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next</code>方法，还部署了<code>return</code>方法。下面的两种情况，都会触发执行<code>return</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return</code>方法，关闭这个文件；情况二会在执行<code>return</code>方法关闭文件之后，再抛出错误。</p>
<p>注意，<code>return</code>方法必须返回一个对象，这是 Generator 规格决定的。</p>
<p><code>throw</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p>
<h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = arr[<span class="built_in">Symbol</span>.iterator].bind(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>
<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element); <span class="comment">// red green blue</span></span><br><span class="line">  <span class="built_in">console</span>.log(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>
<p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  "3", "5", "7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>
<h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure>

<p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1]</span></span><br><span class="line"><span class="comment">// ['b', 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure>

<h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ul>
<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li>
<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>
<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>
</ul>
<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>

<h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure>

<p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">'a\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// '\uD83D\uDC0A'</span></span><br></pre></td></tr></table></figure>

<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">  edition: <span class="number">6</span>,</span><br><span class="line">  committee: <span class="string">"TC39"</span>,</span><br><span class="line">  standard: <span class="string">"ECMA-262"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>
<p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法是使用 Generator 函数将对象重新包装一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>

<h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p>
<p><code>for...in</code>循环可以遍历数组的键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环有几个缺点。</p>
<ul>
<li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li>
</ul>
<p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li>
<li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>
<h2 id="14-Generator"><a href="#14-Generator" class="headerlink" title="14. Generator"></a>14. Generator</h2><ul>
<li><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p>
</li>
<li><p>可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
</li>
<li><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
</li>
<li><p>两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
</li>
<li><p>Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p>
</li>
<li><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p>
</li>
</ul>
<h2 id="14-1-yield和yield"><a href="#14-1-yield和yield" class="headerlink" title="14.1 yield和yield *"></a>14.1 yield和yield *</h2><p><code>yield</code>表达式就是暂停标志</p>
<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>
<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>
<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。<br>yield * 用来在generator函数内部嵌套调用其他的generator函数</p>
<p>只要具有Iterator接口，就能够被yield*遍历</p>
<h2 id="14-2-next方法的参数"><a href="#14-2-next方法的参数" class="headerlink" title="14.2 next方法的参数"></a>14.2 next方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p>
<p>通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是一个利用 Generator 函数和for...of循环，实现斐波那契数列的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-3-Generator-prototype-throw"><a href="#14-3-Generator-prototype-throw" class="headerlink" title="14.3 Generator.prototype.throw()"></a>14.3 Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>

<p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure>

<h2 id="14-4-Generator-prototype-return"><a href="#14-4-Generator-prototype-return" class="headerlink" title="14.4 Generator.prototype.return()"></a>14.4 Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;</span></span><br><span class="line">g.next()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="14-5-next-、throw-、return-的共同点"><a href="#14-5-next-、throw-、return-的共同点" class="headerlink" title="14.5 next()、throw()、return() 的共同点"></a>14.5 next()、throw()、return() 的共同点</h2><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式</p>
<h2 id="14-6-作为对象属性的Generator函数"><a href="#14-6-作为对象属性的Generator函数" class="headerlink" title="14.6 作为对象属性的Generator函数"></a>14.6 作为对象属性的Generator函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。</span><br><span class="line"></span><br><span class="line">它的完整形式如下，与上面的写法是等价的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="14-7-应用"><a href="#14-7-应用" class="headerlink" title="14.7 应用"></a>14.7 应用</h2><h3 id="（1）异步操作的同步化表达"><a href="#（1）异步操作的同步化表达" class="headerlink" title="（1）异步操作的同步化表达"></a>（1）异步操作的同步化表达</h3><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p>
<p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> FileReader(<span class="string">"numbers.txt"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.eof) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.readLine(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p>
<h3 id="（2）控制流管理"><a href="#（2）控制流管理" class="headerlink" title="（2）控制流管理"></a>（2）控制流管理</h3><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>采用 Promise 改写上面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>

<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">longRunningTask</span>(<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="keyword">yield</span> step1(value1);</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="keyword">yield</span> step2(value2);</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="keyword">yield</span> step3(value3);</span><br><span class="line">    <span class="keyword">var</span> value5 = <span class="keyword">yield</span> step4(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scheduler(longRunningTask(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> taskObj = task.next(task.value);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.done) &#123;</span><br><span class="line">    task.value = taskObj.value</span><br><span class="line">    scheduler(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p>
<p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterateSteps</span>(<span class="params">steps</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; steps.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> step();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p>
<p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterateJobs</span>(<span class="params">jobs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; jobs.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* iterateSteps(job.steps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p>
<p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> step <span class="keyword">of</span> iterateJobs(jobs))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(step.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p>
<p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> it = iterateJobs(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）部署-Iterator-接口"><a href="#（3）部署-Iterator-接口" class="headerlink" title="（3）部署 Iterator 接口"></a>（3）部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p>
<p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeSimpleGenerator</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; array.length)&#123;</span><br><span class="line">    <span class="keyword">yield</span> array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value <span class="comment">// 'yo'</span></span><br><span class="line">gen.next().value <span class="comment">// 'ya'</span></span><br><span class="line">gen.next().done  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）作为数据结构"><a href="#（4）作为数据结构" class="headerlink" title="（4）作为数据结构"></a>（4）作为数据结构</h3><p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (task <span class="keyword">of</span> doStuff()) &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>
<h2 id="14-8-Generator的异步应用"><a href="#14-8-Generator的异步应用" class="headerlink" title="14.8 Generator的异步应用"></a>14.8 Generator的异步应用</h2><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p>
<p><strong>基本概念</strong></p>
<p><strong>异步</strong></p>
<p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<p><strong>回调函数</strong></p>
<p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p>
<p><strong>Promise</strong></p>
<p>Promise 的写法只是回调函数的改进,它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。</p>
<p><strong>Generator</strong></p>
<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。     </p>
<p><strong>Generator自动执行器的编写</strong></p>
<h2 id="单个异步任务"><a href="#单个异步任务" class="headerlink" title="单个异步任务"></a>单个异步任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获得最终的执行结果，你需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>首先执行 Generator 函数，获取遍历器对象。</p>
<p>然后使用 next 方法，执行异步任务的第一阶段，即 fetch(url)。</p>
<p>注意，由于 fetch(url) 会返回一个 Promise 对象，所以 result 的值为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">value</span>: <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>

<p>最后我们为这个 Promise 对象添加一个 then 方法，先将其返回的数据格式化(<code>data.json()</code>)，再调用 g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。</p>
<h2 id="多个异步任务"><a href="#多个异步任务" class="headerlink" title="多个异步任务"></a>多个异步任务</h2><p>上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个 yield，我们岂不是要在 then 函数中不断的嵌套下去……</p>
<p>所以我们来看看执行多个异步任务的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line">    <span class="keyword">var</span> r3 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/repos'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([r1.bio, r2[<span class="number">0</span>].login, r3[<span class="number">0</span>].full_name].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获得最终的执行结果，你可能要写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result1 = g.next();</span><br><span class="line"></span><br><span class="line">result1.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g.next(data).value;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g.next(data).value</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但我知道你肯定不想写成这样……</p>
<p>其实，利用递归，我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.json();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<p>其中的关键就是 yield 的时候返回一个 Promise 对象，给这个 Promise 对象添加 then 方法，当异步操作成功时执行 then 中的 onFullfilled 函数，onFullfilled 函数中又去执行 g.next，从而让 Generator 继续执行，然后再返回一个 Promise，再在成功时执行 g.next，然后再返回……</p>
<h2 id="启动器函数"><a href="#启动器函数" class="headerlink" title="启动器函数"></a>启动器函数</h2><p>在 run 这个启动器函数中，我们在 then 函数中将数据格式化 <code>data.json()</code>，但在更广泛的情况下，比如 yield 直接跟一个 Promise，而非一个 fetch 函数返回的 Promise，因为没有 json 方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> json1 = <span class="keyword">yield</span> r1.json();</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line">    <span class="keyword">var</span> json2 = <span class="keyword">yield</span> r2.json();</span><br><span class="line">    <span class="keyword">var</span> r3 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/repos'</span>);</span><br><span class="line">    <span class="keyword">var</span> json3 = <span class="keyword">yield</span> r3.json();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([json1.bio, json2[<span class="number">0</span>].login, json3[<span class="number">0</span>].full_name].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<p>只要 yield 后跟着一个 Promise 对象，我们就可以利用这个 run 函数将 Generator 函数自动执行。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>yield 后一定要跟着一个 Promise 对象才能保证 Generator 的自动执行吗？如果只是一个回调函数呢？我们来看个例子：</p>
<p>首先我们来模拟一个普通的异步请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url, cb</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        cb(&#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: url&#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将这种函数改造成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            cb(&#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: url&#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这样的 Generator 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetchData(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetchData(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([r1.data, r2.data].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要获得最终的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line"></span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">    r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来……</p>
<p>同样利用递归，所以我们可以将其改造为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>由此可以看到 Generator 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。</p>
<p>而两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p>
<p>在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = gen();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPromise(result.value)) &#123;</span><br><span class="line">            result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                next(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.value(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = run;</span><br></pre></td></tr></table></figure>

<p>其实实现的很简单，判断 result.value 是否是 Promise，是就添加 then 函数，不是就直接执行。</p>
<h2 id="return-Promise"><a href="#return-Promise" class="headerlink" title="return Promise"></a>return Promise</h2><p>我们已经写了一个不错的启动器函数，支持 yield 后跟回调函数或者 Promise 对象。</p>
<p>现在有一个问题需要思考，就是我们如何获得 Generator 函数的返回值呢？又如果 Generator 函数中出现了错误，就比如 fetch 了一个不存在的接口，这个错误该如何捕获呢？</p>
<p>这很容易让人想到 Promise，如果这个启动器函数返回一个 Promise，我们就可以给这个 Promise 对象添加 then 函数，当所有的异步操作执行成功后，我们执行 onFullfilled 函数，如果有任何失败，就执行 onRejected 函数。</p>
<p>我们写一版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = gen();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(result.value)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> value = toPromise(result.value);</span><br><span class="line"></span><br><span class="line">            value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                next(data);</span><br><span class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkToPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fn(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">j</span><br><span class="line"><span class="built_in">module</span>.exports = run;</span><br></pre></td></tr></table></figure>

<p>与第一版有很大的不同：</p>
<p>首先，我们返回了一个 Promise，当 <code>result.done</code> 为 true 的时候，我们将该值 <code>resolve(result.value)</code>，如果执行的过程中出现错误，被 catch 住，我们会将原因 <code>reject(e)</code>。</p>
<p>其次，我们会使用 <code>thunkToPromise</code> 将回调函数包装成一个 Promise，然后统一的添加 then 函数。在这里值得注意的是，在 <code>thunkToPromise</code> 函数中，我们遵循了 error first 的原则，这意味着当我们处理回调函数的情况时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb(<span class="literal">null</span>, &#123; <span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: url &#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在成功时，第一个参数应该返回 null，表示没有错误原因。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen == <span class="string">'function'</span>) gen = gen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 gen 不是一个迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen)</span><br><span class="line"></span><br><span class="line">        onFulfilled();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.next(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.throw(err);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">            <span class="keyword">var</span> value = toPromise(ret.value);</span><br><span class="line">            <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">            <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise '</span> +</span><br><span class="line">                <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkToPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fn(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">            resolve(res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = run;</span><br></pre></td></tr></table></figure>

<h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><p>如果我们再将这个启动器函数写的完善一些，我们就相当于写了一个 co，实际上，上面的代码确实是来自于 co……</p>
<p>而 co 是什么？ co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。</p>
<p>如果直接使用 co 模块，这两种不同的例子可以简写为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yield 后是一个 Promise</span></span><br><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> json1 = <span class="keyword">yield</span> r1.json();</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line">    <span class="keyword">var</span> json2 = <span class="keyword">yield</span> r2.json();</span><br><span class="line">    <span class="keyword">var</span> r3 = <span class="keyword">yield</span> fetch(<span class="string">'https://api.github.com/users/github/repos'</span>);</span><br><span class="line">    <span class="keyword">var</span> json3 = <span class="keyword">yield</span> r3.json();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([json1.bio, json2[<span class="number">0</span>].login, json3[<span class="number">0</span>].full_name].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen);</span><br><span class="line"><span class="comment">// yield 后是一个回调函数</span></span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb(<span class="literal">null</span>, &#123; <span class="attr">status</span>: <span class="number">200</span>, <span class="attr">data</span>: url &#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetchData(<span class="string">'https://api.github.com/users/github'</span>);</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> fetchData(<span class="string">'https://api.github.com/users/github/followers'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log([r1.data, r2.data].join(<span class="string">'\n'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>

<h2 id="15-async函数"><a href="#15-async函数" class="headerlink" title="15. async函数"></a>15. async函数</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">上面代码的函数gen可以写成<span class="keyword">async</span>函数，就是下面这样。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>

<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<p><strong>错误处理</strong></p>
<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></table></figure>

<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>
<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>
<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> superagent.get(<span class="string">'http://google.com/this-throws-an-error'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p>
<p><strong>async函数的实现原理</strong></p>
<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>
<h1 id="16-class"><a href="#16-class" class="headerlink" title="16. class"></a>16. class</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>
<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的数据类型就是函数，类本身就指向构造函数,构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p><strong>constructor方法</strong></p>
<p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建类的实例</strong></p>
<p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>
<p><strong>getter和setter</strong></p>
<p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure>

<p><strong>class表达式</strong></p>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>采用 Class 表达式，可以写出立即执行的 Class。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<p><strong>（1）严格模式</strong></p>
<p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>
<p><strong>（2）不存在提升</strong></p>
<p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> Foo = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>
<p><strong>（3）name 属性</strong></p>
<p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure>

<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>
<p><strong>（4）Generator 方法</strong></p>
<p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>
<p><strong>（5）this 的指向</strong></p>
<p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决方法是使用箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getThis = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p>
<p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure>

<p><strong>静态方法</strong></p>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>静态方法也是可以从<code>super</code>对象上调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// "hello, too"</span></span><br></pre></td></tr></table></figure>

<p><strong>实例属性的新写法</strong></p>
<p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>
<p><strong>静态属性</strong></p>
<p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个新写法大大方便了静态属性的表达。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p><strong>私有方法和私有属性</strong></p>
<p>现有的解决方案</p>
<p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> myClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(myClass.prototype)</span><br><span class="line"><span class="comment">// [ 'constructor', 'foo', Symbol(bar) ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p>
<p><strong>私有属性的提案</strong></p>
<p>目前，有一个<a href="https://github.com/tc39/proposal-private-methods" target="_blank" rel="noopener">提案</a>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    this.#a = a;</span><br><span class="line">    this.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #sum() &#123;</span><br><span class="line">    return #a + #b;</span><br><span class="line">  &#125;</span><br><span class="line">  printSum() &#123;</span><br><span class="line">    console.log(this.#sum());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="17-Module模块化"><a href="#17-Module模块化" class="headerlink" title="17. Module模块化"></a>17. Module模块化</h1><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<h2 id="17-1-Export"><a href="#17-1-Export" class="headerlink" title="17.1 Export"></a>17.1 Export</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>
<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-import"><a href="#17-2-import" class="headerlink" title="17.2 import"></a>17.2 import</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>模块的整体导入</strong></p>
<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="17-3-export-default"><a href="#17-3-export-default" class="headerlink" title="17.3 export default"></a>17.3 export default</h2><p>为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>

<h2 id="17-4-export和import结合使用"><a href="#17-4-export和import结合使用" class="headerlink" title="17.4 export和import结合使用"></a>17.4 export和import结合使用</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="17-5-import-函数"><a href="#17-5-import-函数" class="headerlink" title="17.5 import()函数"></a>17.5 import()函数</h2><p><code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> MyModual <span class="keyword">from</span> <span class="string">'./myModual'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure>

<p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>
<p><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">'main'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合。</p>
<p>（1）按需加载。</p>
<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./dialogBox.js'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</span><br><span class="line">    dialogBox.open();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* Error handling */</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
<p>（2）条件加载</p>
<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleA'</span>).then(...);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'moduleB'</span>).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>
<p>（3）动态的模块路径</p>
<p><code>import()</code>允许模块路径动态生成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(f())</span><br><span class="line">.then(...);</span><br></pre></td></tr></table></figure>

<p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...·</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>
<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">myModule</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myModule.default);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码也可以使用具名输入的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>: theDefault&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(theDefault);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果想同时加载多个模块，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>import()</code>也可以用在 async 函数之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module1.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module2.js'</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">'./module3.js'</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<h2 id="17-6-Module的加载原理"><a href="#17-6-Module的加载原理" class="headerlink" title="17.6 Module的加载原理"></a>17.6 Module的加载原理</h2><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>HTML 网页中，浏览器通过``标签加载 JavaScript 脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// module code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到``标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，``标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用``标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了</code>标签的<code>defer</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果网页有多个``，它们会按照在页面出现的顺序依次执行。</p>
<script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

一旦使用了`async`属性，``就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。

ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">"./utils.js"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

举例来说，jQuery 就支持模块加载。

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">"./jquery/src/jquery.js"</span>;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'#message'</span>).text(<span class="string">'Hi from jQuery!'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

对于外部的模块脚本（上例是`foo.js`），有几点需要注意。

- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
- 模块脚本自动采用严格模式，不管有没有声明`use strict`。
- 模块之中，可以使用`import`命令加载其他模块（`.js`后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用`export`命令输出对外接口。
- 模块之中，顶层的`this`关键字返回`undefined`，而不是指向`window`。也就是说，在模块顶层使用`this`关键字，是无意义的。
- 同一个模块如果加载多次，将只执行一次。

下面是一个示例模块。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'https://example.com/js/utils.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

利用顶层的`this`等于`undefined`这个语法点，可以侦测当前代码是否在 ES6 模块之中。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="keyword">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

## ES6 模块与 CommonJS 模块的差异

讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。

它们有两个重大差异。

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

第二个差异是因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

下面重点解释第一个差异。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件`lib.js`的例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面代码输出内部变量`counter`和改写这个变量的内部方法`incCounter`。然后，在`main.js`里面加载这个模块。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

上面代码说明，`lib.js`模块加载以后，它的内部变化就影响不到输出的`mod.counter`了。这是因为`mod.counter`是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">get</span> counter() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面代码中，输出的`counter`属性实际上是一个取值器函数。现在再执行`main.js`，就可以正确读取内部变量`counter`的变动了。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

还是举上面的例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

上面代码说明，ES6 模块输入的变量`counter`是活的，完全反应其所在模块`lib.js`内部的变化。

再举一个出现在`export`一节中的例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./m1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

上面代码中，`m1.js`的变量`foo`，在刚加载时等于`bar`，过了 500 毫秒，又变为等于`baz`。

让我们看看，`m2.js`能否正确读取这个变化。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>

上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。

由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

上面代码中，`main.js`从`lib.js`输入变量`obj`，可以对`obj`添加属性，但是重新赋值就会报错。因为变量`obj`指向的地址是只读的，不能重新赋值，这就好比`main.js`创造了一个名为`obj`的`const`变量。

最后，`export`通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sum += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sum);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure>

上面的脚本`mod.js`，输出的是一个`C`的实例。不同的脚本加载这个模块，得到的都是同一个实例。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.add();</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./mod'</span>;</span><br><span class="line">c.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./x'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./y'</span>;</span><br></pre></td></tr></table></figure>

现在执行`main.js`，输出的是`1`。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

这就证明了`x.js`和`y.js`加载的都是`C`的同一个实例。

## Node.js 加载

### 概述

Node.js 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。

Node.js 要求 ES6 模块采用`.mjs`后缀文件名。也就是说，只要脚本文件里面使用`import`或者`export`命令，那么就必须采用`.mjs`后缀名。Node.js 遇到`.mjs`文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定`"use strict"`。

如果不希望将后缀名改成`.mjs`，可以在项目的`package.json`文件中，指定`type`字段为`module`。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解释成 ES6 模块</span></span><br><span class="line">$ node my-app.js</span><br></pre></td></tr></table></figure>

如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成`.cjs`。如果没有`type`字段，或者`type`字段为`commonjs`，则`.js`脚本会被解释成 CommonJS 模块。

总结为一句话：`.mjs`文件总是以 ES6 模块加载，`.cjs`文件总是以 CommonJS 模块加载，`.js`文件的加载取决于`package.json`里面`type`字段的设置。

注意，ES6 模块与 CommonJS 模块尽量不要混用。`require`命令不能加载`.mjs`文件，会报错，只有`import`命令才可以加载`.mjs`文件。反过来，`.mjs`文件里面也不能使用`require`命令，必须使用`import`。

### main 字段

`package.json`文件有两个字段可以指定模块的入口文件：`main`和`exports`。比较简单的模块，可以只使用`main`字段，指定模块加载的入口文件。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"./src/index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码指定项目的入口脚本为`./src/index.js`，它的格式为 ES6 模块。如果没有`type`字段，`index.js`就会被解释为 CommonJS 模块。

然后，`import`命令就可以加载这个模块。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">'es-module-package'</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure>

上面代码中，运行该脚本以后，Node.js 就会到`./node_modules`目录下面，寻找`es-module-package`模块，然后根据该模块`package.json`的`main`字段去执行入口文件。

这时，如果用 CommonJS 模块的`require()`命令去加载`es-module-package`模块会报错，因为 CommonJS 模块不能处理`export`命令。

### exports 字段

`exports`字段的优先级高于`main`字段。它有多种用法。

（1）子目录别名

`package.json`文件的`exports`字段可以指定脚本或子目录的别名。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"./submodule"</span>: <span class="string">"./src/submodule.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面的代码指定`src/submodule.js`别名为`submodule`，然后就可以从别名加载这个文件。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">'es-module-package/submodule'</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br></pre></td></tr></table></figure>

下面是子目录别名的例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"./features/"</span>: <span class="string">"./src/features/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">'es-module-package/features/x.js'</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure>

如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">'es-module-package/private-module.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">'./node_modules/es-module-package/private-module.js'</span>;</span><br></pre></td></tr></table></figure>

（2）main 的别名

`exports`字段的别名如果是`.`，就代表模块的主入口，优先级高于`main`字段，并且可以直接简写成`exports`字段的值。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"."</span>: <span class="string">"./main.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exports"</span>: <span class="string">"./main.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

由于`exports`字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"./main-legacy.cjs"</span>,</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"."</span>: <span class="string">"./main-modern.cjs"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是`main-legacy.cjs`，新版本的 Node.js 的入口文件是`main-modern.cjs`。

**（3）条件加载**

利用`.`这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开`--experimental-conditional-exports`标志。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"."</span>: &#123;</span><br><span class="line">      <span class="string">"require"</span>: <span class="string">"./main.cjs"</span>,</span><br><span class="line">      <span class="string">"default"</span>: <span class="string">"./main.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码中，别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口），`default`条件指定其他情况的入口（即 ES6 的入口）。

上面的写法可以简写如下。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"require"</span>: <span class="string">"./main.cjs"</span>,</span><br><span class="line">    <span class="string">"default"</span>: <span class="string">"./main.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意，如果同时还有其他别名，就不能采用简写，否则或报错。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"./feature"</span>: <span class="string">"./lib/feature.js"</span>,</span><br><span class="line">    <span class="string">"require"</span>: <span class="string">"./main.cjs"</span>,</span><br><span class="line">    <span class="string">"default"</span>: <span class="string">"./main.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### ES6 模块加载 CommonJS 模块

目前，一个模块同时支持 ES6 和 CommonJS 两种格式的常见方法是，`package.json`文件的`main`字段指定 CommonJS 入口，给 Node.js 使用；`module`字段指定 ES6 模块入口，给打包工具使用，因为 Node.js 不认识`module`字段。

有了上一节的条件加载以后，Node.js 本身就可以同时处理两种模块。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"./index.cjs"</span>,</span><br><span class="line">  <span class="string">"exports"</span>: &#123;</span><br><span class="line">    <span class="string">"require"</span>: <span class="string">"./index.cjs"</span>,</span><br><span class="line">    <span class="string">"default"</span>: <span class="string">"./wrapper.mjs"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码指定了 CommonJS 入口文件`index.cjs`，下面是这个文件的代码。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/index.cjs</span></span><br><span class="line">exports.name = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure>

然后，ES6 模块可以加载这个文件。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/wrapper.mjs</span></span><br><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">'./index.cjs'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = cjsModule.name;</span><br></pre></td></tr></table></figure>

注意，`import`命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">'commonjs-package'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">'commonjs-package'</span>;</span><br></pre></td></tr></table></figure>

还有一种变通的加载方法，就是使用 Node.js 内置的`module.createRequire()`方法。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'cjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">'module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">'./cjs.cjs'</span>);</span><br><span class="line">cjs === <span class="string">'cjs'</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

上面代码中，ES6 模块通过`module.createRequire()`方法可以加载 CommonJS 模块

### CommonJS 模块加载 ES6 模块

CommonJS 的`require`命令不能加载 ES6 模块，会报错，只能使用`import()`这个方法加载。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./my-app.mjs'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

上面代码可以在 CommonJS 模块中运行。

### Node.js 的内置模块

Node.js 的内置模块可以整体加载，也可以加载指定的输出项。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">'events'</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line">readFile(<span class="string">'./foo.txt'</span>, (err, source) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

### 加载路径

ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。`import`命令和`package.json`文件的`main`字段如果省略脚本的后缀名，会报错。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br></pre></td></tr></table></figure>

为了与浏览器的`import`加载规则相同，Node.js 的`.mjs`文件支持 URL 路径。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./foo.mjs?query=1'</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure>

上面代码中，脚本路径带有参数`?query=1`，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有`:`、`%`、`#`、`?`等特殊字符，最好对这些字符进行转义。

目前，Node.js 的`import`命令只支持加载本地模块（`file:`协议）和`data:`协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以`/`或`//`开头的路径）。

最后，Node 的`import`命令是异步加载，这一点与浏览器的处理方法相同。

### 内部变量

ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。

首先，就是`this`关键字。ES6 模块之中，顶层的`this`指向`undefined`；CommonJS 模块的顶层`this`指向当前模块，这是两者的一个重大差异。

其次，以下这些顶层变量在 ES6 模块之中都是不存在的。

- `arguments`
- `require`
- `module`
- `exports`
- `__filename`
- `__dirname`

## 循环加载

“循环加载”（circular dependency）指的是，`a`脚本的执行依赖`b`脚本，而`b`脚本的执行又依赖`a`脚本。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。

但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现`a`依赖`b`，`b`依赖`c`，`c`又依赖`a`这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。

对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。

### CommonJS 模块的加载原理

介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。

CommonJS 的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">'...'</span>,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码就是 Node 内部加载模块后生成的一个对象。该对象的`id`属性是模块名，`exports`属性是模块输出的各个接口，`loaded`属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。

以后需要用到这个模块的时候，就会到`exports`属性上面取值。即使再次执行`require`命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。

### CommonJS 模块的循环加载

CommonJS 模块的重要特性是加载时执行，即脚本代码在`require`的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

让我们来看，Node [官方文档](https://nodejs.org/api/modules.html#modules_cycles)里面的例子。脚本文件`a.js`代码如下。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 a.js 之中，b.done = %j'</span>, b.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure>

上面代码之中，`a.js`脚本先输出一个`done`变量，然后加载另一个脚本文件`b.js`。注意，此时`a.js`代码就停在这里，等待`b.js`执行完毕，再往下执行。

再看`b.js`的代码。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 b.js 之中，a.done = %j'</span>, a.done);</span><br><span class="line">exports.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 执行完毕'</span>);</span><br></pre></td></tr></table></figure>

上面代码之中，`b.js`执行到第二行，就会去加载`a.js`，这时，就发生了“循环加载”。系统会去`a.js`模块对应对象的`exports`属性取值，可是因为`a.js`还没有执行完，从`exports`属性只能取回已经执行的部分，而不是最后的值。

`a.js`已经执行的部分，只有一行。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

因此，对于`b.js`来说，它从`a.js`只输入一个变量`done`，值为`false`。

然后，`b.js`接着往下执行，等到全部执行完毕，再把执行权交还给`a.js`。于是，`a.js`接着往下执行，直到执行完毕。我们写一个脚本`main.js`，验证这个过程。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在 main.js 之中, a.done=%j, b.done=%j'</span>, a.done, b.done);</span><br></pre></td></tr></table></figure>

执行`main.js`，运行结果如下。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

上面的代码证明了两件事。一是，在`b.js`之中，`a.js`没有执行完毕，只执行了第一行。二是，`main.js`执行到第二行时，不会再次执行`b.js`，而是输出缓存的`b.js`的执行结果，即它的第四行。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.done = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

总之，CommonJS 输入的是被输出值的拷贝，不是引用。

另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line">exports.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面代码中，如果发生循环加载，`require('a').foo`的值很可能后面会被改写，改用`require('a')`会更保险一点。

### ES6 模块的循环加载

ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用`import`从一个模块加载变量（即`import foo from 'foo'`），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

请看下面这个例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>

上面代码中，`a.mjs`加载`b.mjs`，`b.mjs`又加载`a.mjs`，构成循环加载。执行`a.mjs`，结果如下。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

上面代码中，执行`a.mjs`以后会报错，`foo`变量未定义，这是为什么？

让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行`a.mjs`以后，引擎发现它加载了`b.mjs`，因此会优先执行`b.mjs`，然后再执行`a.mjs`。接着，执行`b.mjs`的时候，已知它从`a.mjs`输入了`foo`接口，这时不会去执行`a.mjs`，而是认为这个接口已经存在了，继续往下执行。执行到第三行`console.log(foo)`的时候，才发现这个接口根本没定义，因此报错。

解决这个问题的方法，就是让`b.mjs`运行的时候，`foo`已经有定义了。这可以通过将`foo`写成函数来解决。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'foo'</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'bar'</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure>

这时再执行`a.mjs`就可以得到预期结果。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

这是因为函数具有提升作用，在执行`import {bar} from './b'`时，函数`foo`就已经有定义了，所以`b.mjs`加载的时候不会报错。这也意味着，如果把函数`foo`改写成函数表达式，也会报错。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br></pre></td></tr></table></figure>

上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。

我们再来看 ES6 模块加载器[SystemJS](https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md)给出的一个例子。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码中，`even.js`里面的函数`even`有一个参数`n`，只要不等于 0，就会减去 1，传入加载的`odd()`。`odd.js`也会做类似操作。

运行上面这段代码，结果如下。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'./even.js'</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

上面代码中，参数`n`从 10 变为 0 的过程中，`even()`一共会执行 6 次，所以变量`counter`等于 6。第二次调用`even()`时，参数`n`从 20 变为 0，`even()`一共会执行 11 次，加上前面的 6 次，所以变量`counter`等于 17。

这个例子要是改写成 CommonJS，就根本无法执行，会报错。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">exports.counter = counter;</span><br><span class="line">exports.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码中，`even.js`加载`odd.js`，而`odd.js`又去加载`even.js`，形成“循环加载”。这时，执行引擎就会输出`even.js`已经执行的部分（不存在任何结果），所以在`odd.js`之中，变量`even`等于`undefined`，等到后面调用`even(n - 1)`就会报错。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">'./even'</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

# 18. 编程风格

## 块级作用域

**（1）let 取代 var**

ES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码如果用`var`替代`let`，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，`var`命令做不到这一点。

`var`命令存在变量提升效用，`let`命令没有这个问题。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

上面代码如果使用`var`替代`let`，`console.log`那一行就不会报错，而是会输出`undefined`，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。

所以，建议不再使用`var`命令，而是使用`let`命令取代。

**（2）全局常量和线程安全**

在`let`和`const`之间，建议优先使用`const`，尤其是在全局环境，不应该设置变量，只应设置常量。

`const`优于`let`有几个原因。一个是`const`可以提醒阅读程序的人，这个变量不应该改变；另一个是`const`比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对`const`进行优化，所以多使用`const`，有利于提高程序的运行效率，也就是说`let`和`const`的本质区别，其实是编译器内部的处理不同。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

`const`声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。

所有的函数都应该设置为常量。

长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时`let`表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。

## 字符串

静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acceptable</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</span><br></pre></td></tr></table></figure>

## 解构赋值

使用数组成员对变量赋值时，优先使用解构赋值。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr;</span><br></pre></td></tr></table></figure>

函数的参数如果是对象的成员，优先使用解构赋值。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = user.firstName;</span><br><span class="line">  <span class="keyword">const</span> lastName = user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure>

## 对象

单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2, &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign`方法。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if reshape unavoidable</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">5</span>,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  id: <span class="number">5</span>,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">  [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

上面代码中，对象`obj`的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建`obj`的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。

另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = <span class="string">'some value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  ref: ref,</span><br><span class="line"></span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  ref,</span><br><span class="line"></span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

## 数组

使用扩展运算符（...）拷贝数组。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> len = items.length;</span><br><span class="line"><span class="keyword">const</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure>

使用 Array.from 方法，将类似数组的对象转为数组。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br></pre></td></tr></table></figure>

## 函数

立即执行函数可以写成箭头函数的形式。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>

箭头函数取代`Function.prototype.bind`，不应再用 self/_this/that 绑定 this。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.apply(self, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acceptable</span></span><br><span class="line"><span class="keyword">const</span> boundMethod = method.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function">(<span class="params">...params</span>) =&gt;</span> method.apply(<span class="keyword">this</span>, params);</span><br></pre></td></tr></table></figure>

简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。

所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用默认值语法设置函数参数的默认值。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## Map 结构

注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要`key: value`的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## Class

总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(contents = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>._queue = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用`extends`实现继承，因为这样更简单，不会有破坏`instanceof`运算的危险。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">  Queue.apply(<span class="keyword">this</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line">inherits(PeekableQueue, Queue);</span><br><span class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 模块

首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用`import`取代`require`。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.func1;</span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.func2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</span><br></pre></td></tr></table></figure>

使用`export`取代`module.exports`。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commonJS的写法</span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Breadcrumbs = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Breadcrumbs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Breadcrumbs</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Breadcrumbs;</span><br></pre></td></tr></table></figure>

如果模块只有一个输出值，就使用`export default`，如果模块有多个输出值，就不使用`export default`，`export default`与普通的`export`不要同时使用。

不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</span><br></pre></td></tr></table></figure>

如果模块默认输出一个函数，函数名的首字母应该小写。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> makeStyleGuide;</span><br></pre></td></tr></table></figure>

如果模块默认输出一个对象，对象名的首字母应该大写。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StyleGuide = &#123;</span><br><span class="line">  es6: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> StyleGuide;</span><br></pre></td></tr></table></figure>

## ESLint 的使用

ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。

首先，安装 ESLint。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -g eslint</span><br></pre></td></tr></table></figure>

然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i -g eslint-config-airbnb</span><br><span class="line">$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react</span><br></pre></td></tr></table></figure>

最后，在项目的根目录下新建一个`.eslintrc`文件，配置 ESLint。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"eslint-config-airbnb"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

现在就可以检查，当前项目的代码是否符合预设的规则。

`index.js`文件的代码如下。

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unusued = <span class="string">'I have no purpose!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">'Hello, World!'</span>;</span><br><span class="line">    alert(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();</span><br></pre></td></tr></table></figure>

使用 ESLint 检查这个文件，就会报出错误。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ eslint index.js</span><br><span class="line">index.js</span><br><span class="line">  1:1  error  Unexpected var, use <span class="built_in">let</span> or const instead          no-var</span><br><span class="line">  1:5  error  unusued is defined but never used                 no-unused-vars</span><br><span class="line">  4:5  error  Expected indentation of 2 characters but found 4  indent</span><br><span class="line">  4:5  error  Unexpected var, use <span class="built_in">let</span> or const instead          no-var</span><br><span class="line">  5:5  error  Expected indentation of 2 characters but found 4  indent</span><br><span class="line"></span><br><span class="line">✖ 5 problems (5 errors, 0 warnings)</span><br></pre></td></tr></table></figure>

上面代码说明，原文件有五个错误，其中两个是不应该使用`var`命令，而要使用`let`或`const`；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。

# 19. 异步遍历器





# 20. 异步遍历器



# 21. Decorator





# 22. 最新提案及参考链接

[最新提案](https://es6.ruanyifeng.com/#docs/proposals)

[参考链接](https://es6.ruanyifeng.com/#docs/reference)

[ES6入门教程](https://es6.ruanyifeng.com/)









]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
